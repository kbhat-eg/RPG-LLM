# Program JV851R – Price Update from NIB (XML) Explained

This IBM RPG/400 (ILE RPG) program (`JV851R`) processes product and price information from an XML-like input file, updating and creating price records for products in Norgros/NIB systems. Below is a detailed walkthrough to help you onboard and understand both the flow and the key components.

---

## 1. **File Declarations**

```rpg
fnxvppf    uf   e           k disk
fjvarl1    if   e           k disk    rename(jvarpfr:jvarl1r)
fjvarl3    if   e           k disk    rename(jvarpfr:jvarl3r)
fjvprlu    uf a e           k disk    rename(jvprpfr:jvprlur)
fjstsl1    if   e           k disk    rename(jstspfr:jstsl1r)
```
- **nxvppf:** Input file (XML lines)
- **jvarl1, jvarl3:** Product master files (reference lookup by internal/NOBB numbers)
- **jvprlu:** Product price file (update/write new prices)
- **jstsl1:** Status code file (for reference)

---

## 2. **Key Data Structures and Variables**

- **Local Data Area:** Used for retrieving user information.
- **`d_vrec`, `d_prec`:** Data structures overlayed for efficient parsing of which field in each XML record.
- **Key variables:** Used for chaining (lookup) into product/price files.
- **Working variables:** Parsing, temporaries, etc.

---

## 3. **Constants**

- **XML tag strings** (e.g., `<Avsender>`, `<Vare>`, `<Pris>` ...)
- **Other constants:** max price, decimal separator, etc.

---

## 4. **Main Program Flow**

### Initialization (`*inzsr`)
- Retrieves the firm number from the entry parameter.
- Initializes key structures for chaining (lookup).

### Main Loop

#### a. **Read and Process XML input**
- Reads through `nxvppf` file record by record (each line of XML).
- Looks for `<Kilde>` tag to identify a valid source (NIB).

#### b. **Item Processing**
- When a `<Vare>` (product) tag is encountered:
  - Calls `beh_vare` subroutine to process the product and its price(s).

#### c. **Deletion**
- Each processed input record is deleted to ensure idempotency.

#### d. **Exit Handling**
- After all input is processed, releases resources and ends.

---

## 5. **Key Subroutines**

### `uttr_kild`
- Extracts and validates the `<Kilde>` (source) field. Processing continues only for correct sources.

### `beh_vare`
- Loops until the end of the `<Vare>` (product) block.
- Calls routines to extract `NIBnr` and `NOBBnr`.
- For each `<Pris>` encountered within the `<Vare>`, calls `beh_pris`.

### `beh_pris`
- Prepares price record and validates references.
- For each recognized price-related XML tag (see mapping), calls corresponding extraction subroutine (e.g., `uttr_salp` for `<Salgspris>`, etc).
- Once a complete `<Pris>` block is parsed, calls `skr_pris` to store/update price record.

---

## 6. **Field Extraction Subroutines**

Each price field (like `<Nobbpris>`, `<Kostpris>`, etc.) has its own extraction subroutine. Typical flow:
- Checks the length and content of the field.
- Parses out numbers and dates, handling decimals (for amounts), removing blanks, and converting XML entities to usable text (via `konv_XML_esc`).

---

## 7. **Price Writing (`skr_pris`)**

- Validates that product reference (`b_vfel`) is good.
- Attempts to find an existing price record (`chain`).
- If found, updates if input data differs and is valid. Otherwise, writes a new record.
- Always updates "search text" by calling external program `JV790R`.

---

## 8. **Field Handling**

- **Date fields:** Parsed, validated, possibly converted to internal format.
- **Amount fields:** Split into integer/fraction (kroner/øre), with validation (max price).
- **Text fields:** Use `konv_XML_esc` to resolve XML escape sequences.

---

## 9. **XML Escape Conversion (`konv_XML_esc`)**

This subroutine scans a text field, translating XML escape codes (like `&amp;`, `&lt;`, etc.) into their ASCII equivalents for use in DB fields.

---

## 10. **Other Practices**

- **Overlayed Data Structures:** Heavy use of overlays for efficient parsing from flat input.
- **Error Handling:** Minimal, but flags are set for invalid fields/records and such records are skipped.
- **Legacy Style:** This code is old-style RPG IV, not full free-format. Understanding the fixed column structure and subroutine flow is useful.

---

## 11. **Customization Points**

- **XML tags:** If input XML changes, update field constants.
- **Price record logic:** How updates/inserts are performed.
- **Error and exception handling:** Currently, invalid data is mostly skipped without notification.

---

## 12. **Summary Table: Main Entities**

| **XML Tag**     | **RPG Field**      | **Usage**                        |
|-----------------|--------------------|----------------------------------|
| `<Vare>`        | d_vare             | Product processing block start   |
| `<NIBnr>`       | d_vare             | Product NIB number               |
| `<NOBBnr>`      | d_nobb             | Product NOBB number              |
| `<Pris>`        | d_prec, d_nobp, etc| Price processing block           |
| `<Salgspris>`   | d_salp, w_salp     | Sales price                      |
| `<Kostpris>`    | d_kosp, w_kosp     | Cost price                       |
| ...             | ...                | ...                              |

---

## 13. **High-level Flow Pseudocode**

```
Initialize
for each XML line (nxvppf):
    If <Kilde> indicates NIB source:
        for each <Vare>:
            parse product keys
            for each <Pris> inside <Vare>:
                parse price fields
                validate product exists
                update/insert new price if valid
                update search keys
            end for
        end for
    end if
    delete processed line
end for
End program
```

---

## 14. **Onboarding Tips**

- **Read up on RPG overlays and chaining** (file I/O).
- **Understand subroutine invocation (`exsr`)**.
- **Familiarize yourself with the product/price file layouts** (specifically fields referenced).
- **Be aware of record deletion:** Input is cleared as it is processed—no reruns without reload.

---

## 15. **Modifications & Maintenance**

If you need to adapt for new or changed XML fields, add a new `c_*` constant, extraction routine (`uttr_*`), and extend the `select` block in `beh_pris` or `beh_vare` as appropriate.

---

This program is a typical example of legacy RPG code integrating external data into business-critical AS/400 systems. The structure, while not modern, is highly modular and follows a clear, predictable loop/subroutine model.

Let me know if you need a walkthrough of any specific subroutine or data mapping!