# Overview

This RPG source code is for an IBM i (AS/400) application, specifically a maintenance program for "Virksomheter" (Business/Enterprises). The program is named `RA123R`. It uses subfiles for displaying and managing lists, and supports typical maintenance operations: display, add, change, copy, and delete records.

Most comments are in Norwegian and the code uses classic ILE RPG (fixed-format), handling file I/O, subfiles, and interactive screens.

---

## File Definitions

- **Physical file definitions**: Several physical file (PF) members (`fra23l1`, `fra23l2`, etc.) are used via `rename` to provide specific record formats.
- **Workstation file**: `fra123d` is defined for the display file (`workstn`) and uses a subfile (`sfile(b1sfl:w_srrn)`).

---

## Data Structures and Variables

- **Local Data Area (LDA)** fields:
  - `l_user`, `l_firm`, `l_fnav` are loaded from fixed LDA positions.
- **Key fields**: Variables like `ra23l1_wkod`, `ra23l2_wtxt`, etc., are used to build keys for file access.
- **Subfile paging/cursor variables**:
  - `w_stel`, `w_spge`, `w_srrn`, `w_sfrn`, `w_ssrn`, etc., manage subfile record numbers, pages, and state.
- **Flags**: Variables like `b_oppr`, `b_forn`, `b_anul` are used as boolean indicators for various subroutines.
- **Constants**:
  - `c_sfil` is set to 14, indicating the subfile page size.

---

## Special Indicators

The code makes heavy use of indicators (`*INxx`) for function keys and screen control:
- E.g., `*IN10` = Rollup, `*IN11` = Rolldown, `*IN12-*IN15` = Subfile control, `*IN21` = Home, `*IN22` = Cursor Position, `*IN30-*IN31` = Field protection or error flags

---

## Screens/Subfile Descriptions

The program references multiple display formats (screens):
- `B1SFL`: Subfile record format
- `B2CTL`: Subfile control format
- `B2CMD`: Command-key screen
- `C1BLD`, `C2BLD`: Entry/change/view screens
- `D1WIN`, `K1WIN`: Windows for delete/copy
- `C1MSG`: Message screen for duplicate creation attempts

---

## Program Flow (Mainline)

1. **Initialization (`*inzsr`)**:
   - Initializes key lists for file access.
   - Sets up `w_firm` (company).
   - Positions to the first record and fills the subfile.

2. **Main loop**:
   - Presents command screen (`write b2cmd`).
   - Loops to handle subfile display and actions (`exsr dsp_subfile`).

3. **Function Key Handling** (`select` block):
   - Exit keys go to `avslutt`.
   - Page Up/Down trigger creation/back of subfile page.
   - F-Key mapped subroutines for "create", "copy", etc.

4. **Subfile Handling**:
   - The subfile is refreshed, paged, updated, and can be repositioned according to search fields.
   - Calls to subroutines do the actual work (search, maintenance, copy/delete).
   - Subfile loop processes each record for possible change, copy, delete, or view action.

5. **Exit**:
   - Sets LR indicator and returns.

---

## Key Subroutines

### `forny`
- Refreshes the subfile from the current position.
- Repositions logical files depending on whether the search is by key (`w_seqe` = blank or 'B').
- Clears subfile and fills it again.

### `posisjoner`
- Handles positioning/searching via either code (`b2wkod`) or description (`b2wtxt`).
- Sets search criteria, repositions logical file, clears and fills subfile.

### `subfile`
- Main handler for user interaction in the subfile.
- Handles toggling display states, possible repositioning, and interprets user action on subfile rows (change, copy, delete, view).

### `xc1bld` (Create New Row)
- Presents the "create" window.
- Validates input, checks for duplicates.
- Calls the maintenance program for further input.
- If the row already exists, shows a message and allows the user to retry or exit.

### `xc2bld` (Edit/Display Row)
- Loads the row for update or display.
- Formats, validates, and updates or creates the record.
- Updates the subfile buffer if necessary.

### `xd1win` (Delete)
- Confirms, then deletes the selected row.

### `xk1win` (Copy)
- Loads the source record, presents a screen for new key input.
- Validates that the new key doesn't already exist.
- Calls maintenance program to create the row with the new key.

### Subfile Maintenance: `clr_subfile`, `crt_subfile`, `bck_subfile`, `dsp_subfile`
- `clr_subfile`: Clears subfile and resets navigation variables.
- `crt_subfile`: Fills the subfile from the current position up to `c_sfil` (page size).
- `bck_subfile`: Moves back one page in the subfile.
- `dsp_subfile`: Displays the subfile control and record screens.

---

## Database Access

- File access is done via CHAIN, SETLL/SETGT, READ/READP, and DELETE/UPDATE/WRITE operations.
- Key-lists (`klist`) are defined for logical file access for different operations.

---

## Screen Processing

- All screen interactions are via `exfmt` (or `write`), invoking the display file for input/output.
- Indicator handling for function keys (`*INKC`, `*INKL`, etc.) is used to determine user action.

---

## Error Handling & User Feedback

- Uses screen-specific indicators (`*IN30-*IN32`) to signal errors (like blank fields or duplicates).
- When trying to create a duplicate row, displays a special message screen and allows the user to retry or abort.

---

## Comments and Documentation

- Most comments are in Norwegian and explain purposes for indicators, variables, and special routines.
- Many comments explain the fields and their use, especially those for subfile navigation and paging.

---

## Summary

**Main purpose:**  
To provide an interactive program to maintain a list/table of "Virksomheter" (business entities), supporting search, paging, add, change, copy, view, and delete, all accessible via subfile-based screens.

**Key RPG concepts demonstrated:**  
- Subfile processing (with logic for paging, clearing, refilling)
- Display file interaction
- Traditional RPG indicator usage
- File and record-level processing
- Use of LDA for context values

**To onboard a new developer:**  
- Understand how subfile paging works in RPG.
- Get familiar with legacy RPG indicators and the display file layouts (DSPF).
- Examine the logical files (`ra23l1`, `ra23l2`, etc.) and their key structures.
- Understand how function keys are mapped and handled (see the indicator comments).
- Most business logic is isolated in subroutines, making the structure modular and straightforward to follow.