# Explanation of IBM ILE RPG Source Code

This RPG program's main function is to **find the next available (unique) suffix** ("suffiks") related to an order number, ensuring that the suffix does not already exist in the order head register, historical invoice table, or deleted orders table. 

It manages suffix values in the interval **0–99**, and, if all suffixes are used (wrapped around 99), it starts over from 0. The program checks all relevant tables to avoid duplicates.

## Header and File Definitions

```rpg
h option(*nodebugio)
```
- Disables certain debugging capabilities to improve performance.

### Physical File Definitions

Each file is opened for input (`if`), externally described (`e`), keyed access (`k`), and, if needed, renamed in the program.

```rpg
ffohelr    if   e           k disk    rename(fohepfr:fohelrr)
ffohel1    if   e           k disk    rename(fohepfr:fohel1r)
fsohel3    if   e           k disk    rename(sohepfr:sohel3r)
ffdellr    if   e           k disk    rename(fdelpfr:fdellrr)
```

- **fohelr**: Order header register
- **fohel1**: Possibly a variant/view of the order header
- **sohel3**: Historical invoice register
- **fdellr**: Deleted orders register

---

## Data Structure and Variable Definition

### Local Data Area
```rpg
d l_user                911    920
d l_filg                931    933
d l_firm                944    946  0
```
- Extracts values from the local data area (LDA) for user, file group, and firm/company.

### Key Fields
Variables to hold the current key values for each file.

### Working Variables
`w_firm`, `w_suff`, `w_osuf`, `w_hsuf`, `w_dsuf`, `p_numm`, `p_suff`, etc.

- `w_firm`: Current company code
- `w_suff`: New suffix under consideration
- `w_osuf`, `w_hsuf`, `w_dsuf`: Highest suffixes found in "Ordre", "Historisk", "Slettede"
- `p_numm`: Incoming order number parameter
- `p_suff`: Outgoing (result) suffix parameter

---

## Constants

Lowercase and uppercase alphabets for possible use in data translation, though not directly referenced in the main logic.

---

## Main Program Logic

### Initialization

```rpg
c                   eval      w_firm = l_firm
c                   eval      w_suff = 0
c                   eval      w_osuf = 0
c                   eval      w_hsuf = 0
c                   eval      w_dsuf = 0
...
```
- Initializes firm, current suffix, and all maximum values to 0.

---

### Find Highest Suffixes

The following subroutines are called:

```rpg
c                   exsr      hnt_o_suf     // From orders
c                   exsr      hnt_h_suf     // From historical invoices
c                   exsr      hnt_d_suf     // From deleted orders
```
Each subroutine sets the highest suffix found in its respective file for the given order number.

---

### Calculate Next Available Suffix

Compares all found maximum suffixes and determines the next available suffix.

```rpg
c                   if        w_hsuf >= w_suff and w_hsuf > 0
c                   eval      w_suff = w_hsuf + 1
c                   endif
c                   if        w_dsuf >= w_suff and w_dsuf > 0
c                   eval      w_suff = w_dsuf + 1
c                   endif
```
- If the highest in history is higher and positive, move `w_suff` up.
- Same with deleted.

**If the suffix "wraps" (is above 99), start over:**
```rpg
c                   if        w_suff > 99
c                   eval      w_suff = 0
c                   endif
```

---

### Uniqueness Check & Increment

Check that the new suffix does not already exist in the order header file (`fohel1`). If it does, increment and repeat.

```rpg
c     ny_suffiks    tag
c                   eval      fohel1_suff = w_suff
c     fohel1_key    chain     fohel1
c                   if        %found
c                   eval      w_suff = w_suff +1
c                   goto      ny_suffiks
c                   endif
```
- Uses a label and a loop (`goto`) to find the first unused suffix.

---

### Return the Result

```rpg
c                   eval      p_suff = w_suff
c                   return
```
- Returns the discovered new suffix as the output parameter.

---

## Subroutines

### `hnt_o_suf`: Find Next Suffix from Orders

- Checks if suffix 99 is already used. If yes, sets `w_osuf=99`.
- Otherwise, finds the highest existing suffix, with some logic to handle wraparound.
- Sets the working suffix for the next step.

### `hnt_h_suf`: Find Next Suffix from Historical Invoices

- Scans this year's and last year's historical invoice lines for the given order number.
- Updates `w_hsuf` to the highest found suffix.

### `hnt_d_suf`: Find Next Suffix from Deleted Orders

- Scans both this year and the previous year for the given order number.
- Updates `w_dsuf` to the maximum found.

---

## Initialization Subroutine (`*inzsr`)

- Handles input parameters: order number (`p_numm`) and output suffix (`p_suff`).
- Sets up all the keylists (key fields) for chaining and reading keyed files.

---

## Keylists

Key lists define the composite keys used to access the files with specific field values (company, order number, suffix, etc.).

---

# Summary

- **Purpose:** Find the next available, unique suffix (0–99) for a given order number across current, historical, and deleted order records.
- **Strategy:** Find the highest currently used suffix, increment, check for uniqueness, and wrap around if necessary.
- **Files Accessed:** Orders, historical invoices, deleted orders.
- **Key points:** Avoids duplicates even over multiple tables, handles wrap-around when maximum suffix is reached, and is robust for multi-year searches.

---

This modular and cautious approach ensures data consistency by preventing duplicate suffixes for the same order number across all relevant tables.