# Explanation of RPG Program: Omberegning av budsjett (Budget Recalculation)

This RPG III/IV (ILE RPG) program, named `RH128R`, runs on IBM i (formerly AS/400) and is used for the recalculation and redistribution of budget amounts. The code is structured as a batch program that reads, processes, and updates financial (budget) records based on a variety of rules. Below is a breakdown of the key parts, main logic, and their purposes.

---

## 1. **File Declarations**

```rpg
frhsal1    if   e           k disk    rename(rhsapfr:rhsal1r)
frhovlr    if   e           k disk    rename(rhovpfr:rhovlrr)
fra13lr    if   e           k disk    rename(ra13pfr:ra13lrr)
frhsalu    uf a e           k disk    rename(rhsapfr:rhsalur)
```
- **frhsal1**: Input file (budget balances, renamed to `rhsal1r`)
- **frhovlr**: Input file (account details, renamed to `rhovlrr`)
- **fra13lr**: Input file (budget keys, renamed to `ra13lrr`)
- **frhsalu**: Update file (updated balances, renamed to `rhsalur`)

---

## 2. **Array/Table Definitions**

```rpg
d sal         s   15  2  dim(14)    // Current balances
d gsa         s   11  2  dim(14)    // Previous record balances
d nsa         s   11  2  dim(14)    // New calculated balances
d isa         s   11  2  dim(14)    // Saldomatrix
d mfo         s    9  6  dim(13)    // Distribution keys
```
- Arrays for storing running totals by account segment/month, distributing and recalculating budget figures.

---

## 3. **Data Structures for Break Logic**

```rpg
d                 ds
d nybrd                        13  0      // New break key
d  nyavd                       4  0 overlay(nybrd)    // Dept.
d  nykto                       5  0 overlay(nybrd:5)  // Account
d  nysps                       4  0 overlay(nybrd:10) // Cost carrier

d                 ds
d gmbrd                        13  0      // Previous break key
d  gmavd                       4  0 overlay(gmbrd)
d  gmkto                       5  0 overlay(gmbrd:5)
d  gmsps                       4  0 overlay(gmbrd:10)
```
- Used to group data and detect when a record in the input stream represents a new break/group for processing.

---

## 4. **Miscellaneous Working Variables**

- `akkbel`: Accumulated amount (for running totals)
- `akkpro`: Accumulated percentage (for running percentages)
- `work2`: Work variable for intermediate calculations
- `n`: Index for looping (typically over months)

---

## 5. **Input Field Mapping**

```rpg
irhsal1r
i              risa01                      sal(01)
...
i              risa12                      sal(12)
i              risa13                      sal(13)
i              risa00                      sal(14)
```
- Each month’s balance, and a summary balance (`risa00`).

---

## 6. **Main Processing Loop**

The **main process** reads all `rhsal1r` records (budget balances), applying filtering and break detection logic.

### Steps:
1. **Initialize Key Variables and Arrays**.
2. **Set File Position and Loop Through Records**.
    - For each record, overlay the relevant fields into the `nybrd` structure.
    - **Filter** records by account, cost carrier, department, year, record type, and budget key.
    - If it’s the first record for a group, initialize break variables (`gmbrd`, `gsa`).
    - On group change (detected by break-key change), call the `behand` subroutine to process the grouped data.
    - After processing, move the new group to the old group and repeat.

### Filtering logic
- Only records within specified ranges for account, cost carrier, department and matching the target year and type are processed.
- If a record’s type doesn't match the expected budget type, it’s skipped.

### Validation
- Chained lookups to related details (e.g. account plan `rhovlrr`) to validate the existence and properties for further processing.
- Check that the correct budget key (nøkkel) is used.

---

## 7. **Subroutines**

### 7.1. **behand (Processing Routine)**
This subroutine recalculates and redistributes budget amounts by month, based on the distribution key.

#### Steps:

1. **Reset Distribution Array** (`mfo`).
2. **Obtain Budget Key**:
    - If not standard (not 99 or 0), look up the key in `ra13lrr` and load distribution percentages.
    - If key=99, assign fixed value of 8.333333 to each month.
3. **Calculate Redistributed Amounts**:
    - Sum up the previous balances (`gsa`).
    - For each month, apply the distribution percentage to the total budget, calculate cumulative amounts, and determine the new value for each month (`nsa`).
4. **Update Target Budget File (`rhsalur`)**:
    - Chain to find the appropriate record.
    - If found, update with the new calculated balances for each month. Reset the summary (`risa00 = 0`).
    - Update timestamp and user for audit purposes.

### 7.2. **INZSR (Initialization)**
- Sets initial values for keys and arrays.
- Initializes key lists for use in chained and keyed file access.

---

## 8. **Program Termination**

```rpg
c                   eval      *inlr = *on
```
- End-of-program indicator: closes any open files, ends the program.

---

## 9. **Audit/Trace Fields**

- In updates, writes timestamps (`riedat`, `rietim`) and user information (`rieusr`) to target records for auditing.

---

## Summary

- **Purpose**: Recalculates and redistributes budget values, applying specified distribution keys, and writes back the updates.
- **Logic**: For each group (account, department, cost center, etc.), filter, check, and, if valid, redistribute budget using a key (distribution matrix).
- **Key Techniques**: Group (break) processing, file chaining, tabular array calculations, auditing changes.
- **Typical Use Case**: Annual or periodic budget recalculation and reallocation in financial ERP systems, supporting both standard and custom budget distributions.

---

## Further Reading / Onboarding Recommendations

- **Files referenced**: Request data dictionary or file layouts for `rhsapfr`, `rhovpfr`, `ra13pfr`.
- **Budget keys/logic**: Discuss with a functional consultant or business analyst how budget keys are set.
- **Testing**: Review with test data to understand record grouping and break logic in a real scenario.

---

This documentation should provide a developer with both a high-level and detailed understanding of how the program runs and its logic for onboarding or maintenance.