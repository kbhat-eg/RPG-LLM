# Program Documentation: `sr124R` – Salesperson Selection (Utvalg Selger)

## Overview

This RPG program, part of the ASSTAT system, implements a workstation-driven selection and maintenance screen for "Selger" (Salesperson) entities. It utilizes subfiles for list display and supports CRUD operations (Create, Read, Update, Delete) with a focus on user-driven interaction via function keys. The program interacts with several database files and is designed for modularity and reuse within the ASSTAT domain.

---

## Main Purpose

- **Display and manage a list of salespersons** using a subfile interface.
- **Allow users to add, update, or delete** salesperson entries.
- **Integrate with related master data** (e.g., code validation, descriptive text lookup).
- **Ensure data consistency** through key-based navigation, validation, and controlled updates.

---

## File Interactions

- **Workstation File**
  - `sr124d` (WORKSTN, SFILE): Main display file with subfile `b1sfl` and control record `b2ctl`.
- **Database Files**
  - `slpml1` (Input, Keyed): Main list of salespersons (renamed record format).
  - `slpmlr` (Input, Keyed): Used for checking if a salesperson already exists.
  - `slpmlu` (Update, Keyed): Used for writing new or updated salesperson records.
  - `ra09l1` (Input, Keyed): Reference table for code validation and description lookup.

---

## Data Structures and Variables

- **Key Variables:** Used for setting and chaining to specific records in each file, following the convention `file_fieldname`.
- **Work Variables:** For subfile row numbers, control flags (`b_forn`, `b_anul`, `b_feil`), and current firm/type/code context.
- **Constants:** `c_sfil` (subfile page size, 12 rows).
- **Local Data Area:** Used for retrieving user, firm, and name information.

---

## Program Flow

### Initialization (`*inzsr`)

- Sets up file keys for all database files.
- Receives parameters from the calling program (`wptype`, `wptext`).
- Initializes working variables and subfile controls.
- Retrieves the firm number from the local data area.
- Positions the database and populates the initial subfile.

### Main Loop

- **Display opening screen** and subfile (`b2ctl`, `b1sfl`).
- **Process function keys**:
  - Exit (`*INKC`, `*INKL`)
  - Refresh (`*INKE`)
  - Add new entry (`*INKF`)
  - Create new subfile page (`*IN10`)
  - Return to main (`*IN21`)
- **Positioning:** If a specific code is entered, position subfile accordingly.
- **Subfile Control:** Handles add/delete logic based on user selection.
- **Subfile Processing:** Handles per-row actions (e.g., delete).

---

## Key Subroutines

### `forny`
- Repositions and refreshes the subfile based on the current key.

### `posisjoner`
- Positions the subfile to a specific starting value (`b2ikod`), then refreshes.

### `control`
- Handles add (`b2valg='1'`) and delete (`b2valg='4'`) requests.
- Performs validation (e.g., missing key).
- Triggers subroutines for add (`xc1bld`) or delete (`xd1win`).

### `subfile`
- Iterates over visible subfile rows.
- Processes row-level delete actions and updates the subfile accordingly.

### `xc1bld`
- Handles the "Add New" screen.
- Validates if entry already exists.
- If new, chains to reference file for description and proceeds to entry screen (`xc2bld`).

### `xc1msg`
- Displays a message if the user attempts to add an already existing entry.

### `xc2bld`
- Handles create/update/view of a salesperson entry.
- Updates or writes the record to the update file (`slpmlu`).

### `xd1win`
- Handles the delete confirmation screen and deletes the selected record.

### `clr_subfile`
- Clears the subfile and resets subfile-related work variables.

### `crt_subfile`
- Fills the subfile with up to `c_sfil` (12) records, starting from the current key position. 
- Only includes records for the current firm, type, and code.

### `dsp_subfile`
- Displays the subfile, managing subfile indicators as needed.

---

## Design Conventions and Patterns

- **Key Structures:** All database access uses composite keys, reflecting multi-tenant (firm) and typed code management.
- **Subfile Paging:** Subfile is managed in pages of 12, with explicit control of row numbers and visible range.
- **Function Key Handling:** Consistent use of RPG indicators for function key detection and branching.
- **Separation of Concerns:** CRUD logic is modularized into dedicated subroutines, making flow control explicit.
- **Error Handling:** Uses indicators and flags to control error display and user feedback.
- **Data Validation:** All adds/updates are validated against reference files to ensure data integrity.

---

## Business and Domain Logic

- **Firm Context:** All operations are scoped to the current firm, supporting multi-company setups.
- **Salesperson Codes:** The system maintains a master list of salespersons, each uniquely identified by a composite key (firm, type, code, value).
- **Reference Validation:** New entries are validated against a reference file to ensure the code exists and to fetch descriptive text.
- **User Interaction:** The workflow is designed for interactive terminal use, with immediate feedback and error correction.

---

## Integration Points

- **RA509R:** External program called for code lookup/validation when adding a new salesperson.
- **Local Data Area:** Used for session context (firm, user, etc.), ensuring proper scoping of operations.

---

## Notable Implementation Details

- **Norwegian Comments:** Many comments and variable names are in Norwegian, reflecting the program’s origin and user base.
- **Subfile Management:** The subfile is aggressively cleared and rebuilt on most operations to maintain consistency.
- **Indicator Usage:** Heavy reliance on classic RPG indicators for screen and function key management.
- **Record Format Renaming:** All file record formats are renamed for clarity and to avoid conflicts.

---

## Summary

This program is a robust, modular tool for managing salespersons within the ASSTAT system. It is designed for interactive, terminal-based use and emphasizes data integrity, user feedback, and maintainability. The codebase follows established RPG patterns for subfile management, composite keying, and modular CRUD operations, all tailored to the business requirements of multi-firm, code-driven master data management.