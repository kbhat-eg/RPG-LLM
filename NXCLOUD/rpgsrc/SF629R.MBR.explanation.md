# RPG Program Explanation: SF629R

This RPG/400 (ILE RPG) program is part of an AS/400 (IBM i) ERP system, designed to generate a "mengde-statistikk" (quantity statistics) report—specifically, to print out statistics by volume (`m3`), amount, and sales figures, with comparison to budget and previous year. The code is in Norwegian, standard for many legacy Scandinavian installs. Below, sections are explained to help you ramp up as a developer.

---

## 1. **Header & Documentation**

- **Program Name:** SF629R
- **Description:** Output of volume statistics (m3)
- **Change Log:** Details changes from 2004 onward, including new features (e.g., seller register, removal of discount group, addition of units).

---

## 2. **File Declarations (`F-specs`)**

```rpg
fskwwpf    ip   e           k disk
fskpml1    if   e           k disk    rename(skpmpfr:skpml1r)
...
fsf629p    o    e             printer oflind(*in30)
```

- **Input files:** Various master files (customers, vendors, items, groups, budgets, etc.), each with unique keys/record formats.
- **Printer file:** `SF629P` is the report output.
- **Record Renaming:** Many files are renamed in the program to avoid naming clashes.

---

## 3. **Array & Table Declarations**

```rpg
d sal             s              9  0 dim(12)
d rt              s             25    dim(60) ctdata perrcd(1)   Rapport-tekster
```
- `sal`: Budget/sales values per month (12 months).
- `rt`: Array holding 60 report texts for headings.

---

## 4. **Data Structure Declarations**

These `DS` are for intermediate and overlay work fields:

- `w_rest`: "rest" info, buffer for selection criteria.
- `beg/k6/.../k2a`: Overlaying for grouping and key manipulation by field length.
- `w_xgrp`: For extracting over/hoved/undergruppe (group) keys.
- `l_...`: For user/session/company info.
- `wxkode`: Budget key mask (for dynamic selection).

---

## 5. **Field Declarations**

Most fields are derived from the database file layouts, and are used for:
- Item, customer, and segment codes.
- Accumulators for report calculations.
- Text fields for headings.
- Fields for period (year/month) logic.

**Naming conventions are explained for variable meanings.**
- 1st char: what is summed (e.g., a=antall/quantity, b=beløp/amount, d=dekningsgrad/contribution margin)
- 2nd char: type (n=netto, s=antall, a=aktuelt, e=nominellt)
- 3rd char: period (p=denne periode/this period, i=hittil/year-to-date)
- 4th char: sorting/group
- 5th char: other logic (group, company total, etc.)

---

## 6. **Input Specifications (`I-specs`)**

Define how file fields map to working variables.

- `skwwpfr`: For selection criteria—`sffirm` (company), `swsrt1/2/3` (sorting/grouping criteria).
- `skbul1r`: For budget data mapped into monthly array `sal`.

---

## 7. **Main Calculation Logic (`C-specs`)**

### a. **Initialization & Break (Level) Logic**
- **L6/L5/L4 tags:** At each group break (change in sorting/grouping value), the respective accumulator variables are zeroed, and headings/units are set up by extracting from the `beg` structure and calling a subroutine (`raprut`) to fetch text.

### b. **Summing & Period Logic**
Handles:
- How values are summed for different grouping breaks (L4 = group 3, L5 = group 2, L6 = group 1).
- Comparison logic for budget (`*in41`) and previous year (`*in42`).
- Accumulation of sales and volume values for both "this year" and "last year", both to period and YTD.

### c. **Level Break Output**
At each level break (L4-L7), calls subroutines like `L4brd`, `L5brd`, etc., to handle subtotaling and moving results to print fields, then issues `WRITE` commands to print subtotals.

---

## 8. **Subroutines**

### a. **`L4brd`, `L5brd`, `L6brd`, `L7brd`:**
- Accumulate current sublevel’s totals into the next level’s accumulators.
- Move results into output fields for printing subtotals at each level.
- Call `beregn` to calculate averages/prices per unit.

### b. **`overflow`:**
- Handles page overflow; prints heading when input indicator 30 is ON.

### c. **`beregn`:**
- Calculates price per m³ for current period (`bnppr`) and YTD (`bnipr`) by dividing net amount by volume.

### d. **`raprut`:**
- "Rapport rutine": looks up and sets report texts (headings and field descriptions) for a given group/sorting field.

### e. **`budsjett`:**
- Builds a key for the budget register and fetches budget data for the current grouping values.
- Sums appropriate months into accumulators for comparison.

### f. **`hntwxk`:**
- Builds the budget key mask (`wxkode`) dynamically, based on report grouping.

### g. **`*inzsr`:**
- Program initialization (run at startup).
- Reads in selection parameters, builds report headings, initializes control fields and groupings, sets flags for comparison logic, and writes the page header.

---

## 9. **Tables**

At the end, there is a CTDATA table (`rt`) storing texts used as headings, printed above report columns depending on grouping logic.

---

## 10. **General Process Flow**

1. **Initialization:** Read parameter file and set up grouping/sorting criteria; prepare report heading.
2. **Read Data:** Main program loop (not shown, but implied) reads sales/statistics records.
3. **Grouping Logic:** 
    - For each level break (firm, group 1, 2, or 3), subtotals are printed.
    - On record read, values are accumulated in group and total variables.
4. **Comparisons:** 
    - Budget and prior-year logic is handled if selected.
5. **Output:** 
    - Writes detail, subtotal, and final total lines to printer file, with proper column headings.
    - Handles field formatting and logic for which values to print for each grouping/subtotal.
6. **End:** Final clean-up and closing handled at end-of-job.

---

## 11. **Adaptation for Developers**

- **To onboard quickly:**
    - Understand the sorting/grouping logic and how subtotals roll up.
    - `raprut` and the `rt` array connect the code logic to headings (see how group/sort values point to correct text).
    - Budget comparison (`budsjett` subroutine) depends on grouping, so see how `wxkode` is built.
    - The program is built around break logic—processing is mostly controlled by detection of level breaks.
    - File layouts (i.e., field names like `sfanta`, `sfakm3`, etc.) are crucial for maintenance; get the DDS/layouts.

---

## 12. **Key Concepts / Abbreviations for RPG Newcomers**

- **do/endo:** Loop/End Loop
- **begsr/endsr:** Begin/End Subroutine
- **chain:** Indexed file read (random access)
- **movel:** Move-Left (string/field copy, padding right)
- **eval(h):** High-precision arithmetic
- **klist/kfld:** Key list for file lookups
- **if/endif:** Conditional logic
- ***inxx:** RPG logic indicators (flags, e.g., for print page overflow, break triggers)
- **WRITE:** Output/print a record
- **overlay:** Multiple fields sharing same storage, for variable key length management

---

## 13. **Summary**

- This program is a classic RPG-level-break report generator for sales/quantity statistics.
- It supports grouping and subtotaling by up to three dimensions, with dynamic headings, and can compare to budget and last year.
- Logic is modular: break handlers, calculation routines, and lookup logic are separated.
- Much of the code manages subtotaling and formatting for multi-level grouping, which is typical for these kinds of legacy reports.
- To modify or expand report behavior, focus on the break handling, the table of headings (`rt`/`raprut`), and the data structure layouts. 

---

For further onboarding, review the DDS (database descriptions) for all referenced physical/logical files, and map field usages accordingly. Most of the logic is table-driven, so understanding how keys and codes are mapped to headings and grouping will be essential for any enhancements.