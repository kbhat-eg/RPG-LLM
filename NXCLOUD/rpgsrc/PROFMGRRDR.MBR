        //Compile1: (Bruk valg 15)
        //CRTSQLRPGI OBJ(*libl/PROFMGRRDR) SRCFILE(*libl/QRPGLESRC) OBJTYPE(*MODULE)
        //Utviklet i NXS_20559, basert pÃ¥ Jira sak NXS-20559

        //Compile2:
        //CRTPGM PGM(*libl/PROFMGRRDR) MODULE(*libl/PROFMGRRDR RWUTIL/MSGRDR)

        ctl-opt PGMINFO(*NO);

       /copy QRPGLESRC,MSGRDRPR

      * (c) EG 2024
      *
      * Objekt.....: PROFMGRRDR
      * Descripton : Read profile manager messages from "kafka"
      * Created dat: 2024-12-11
      * Created by.: baasa
      * Jira task .: NXS-20559
      *
      *****************************************************************
      * Changes:
      * Date   Sign Description
      *
      *
      *****************************************************************
      *
      * Customer changes:
      * Date   Sign Description
      *
      *****************************************************************

       dcl-s myProcPtr pointer(*proc);
       dcl-ds msg likeds(QueuedMessage);

       dcl-s dsplyText            varchar(52);
       dcl-s consumer             varchar(40);
       dcl-s w_messagedata        varchar(32000);
       dcl-s w_firm               packed(3:0);
       dcl-s w_filgrp             varchar(6);
       dcl-s w_string             varchar(1000);
       dcl-s w_inx                packed(4:0);
       dcl-s command              char(500);
       //Article
       dcl-s w_externalNumber     varchar(15);
       dcl-s w_name               varchar(256);
       dcl-s w_productGroupNumber varchar(5);
       dcl-s w_ruleIds            varchar(6);
       //Profile
       dcl-s w_prof_id            packed(6:0);
       dcl-s w_code               varchar(35);
       dcl-s w_prof_name          varchar(128);
       dcl-s w_version            packed(3:0);
       dcl-s w_description        varchar(512);
       dcl-s w_tenantIdentifier   varchar(128);
       dcl-s w_state              varchar(25);
       //Rule
       dcl-s w_rule_id            packed(6:0);
       dcl-s w_rule_name          varchar(128);
       dcl-s w_usageType          varchar(25);
       dcl-s w_actionCode         varchar(64);
       dcl-s w_actionMessage      varchar(128);
       dcl-s w_statusCode         varchar(25);
       dcl-s w_profileId          packed(6:0);

       myProcPtr = %paddr(MyProc);

       //Set librabry list
       command = 'CHGLIBL LIBL(*NONE)';
       exec sql CALL QSYS2.QCMDEXC(:command) ;
       if sqlcod = 0;
          commit;
       endif;

       command = 'ADDLIBLE LIB(QGPL) POSITION(*LAST)';
       exec sql CALL QSYS2.QCMDEXC(:command) ;
       if sqlcod = 0;
          commit;
       endif;

       command = 'ADDLIBLE LIB(QTEMP) POSITION(*LAST)';
       exec sql CALL QSYS2.QCMDEXC(:command) ;
       if sqlcod = 0;
          commit;
       endif;

       command = 'ADDLIBLE LIB(ADB) POSITION(*LAST)';
       exec sql CALL QSYS2.QCMDEXC(:command) ;
       if sqlcod = 0;
          commit;
       endif;

       command = 'ADDLIBLE LIB(NXKORR) POSITION(*LAST)';
       exec sql CALL QSYS2.QCMDEXC(:command) ;
       if sqlcod = 0;
          commit;
       endif;

       command = 'ADDLIBLE LIB(NXCLOUD) POSITION(*LAST)';
       exec sql CALL QSYS2.QCMDEXC(:command) ;
       if sqlcod = 0;
          commit;
       endif;

       command = 'ADDLIBLE LIB(RWUTIL) POSITION(*LAST)';
       exec sql CALL QSYS2.QCMDEXC(:command) ;
       if sqlcod = 0;
          commit;
       endif;

        //Read all messages not read from last.
       consumer = 'Profile_Manager_Consumer';
       SubscribeMessages('profiles-output-channel':consumer:myProcPtr);
       commit;
       return;

       //Internal procedure. Can be used for callbacks
       dcl-proc MyProc;
         dcl-pi *n;
              message likeds(QueuedMessage);
         end-pi;
        if message.status = 500;
        // Propagate exception to caller
          return;
        endif;

       //Check type of data from dataque

            w_firm = 0;
            w_messagedata = message.messageData;
            w_messagedata = %scanrpl('null':'"x"':w_messageData);

       // Find filgroup and set correct librarylist
            w_filgrp = *blanks;
            w_string = *blanks;
            w_inx = %scan('-':message.messageKey);
            if w_inx > 0;
               w_filgrp = %subst(message.messageKey:w_inx+1:6);
               if %trim(w_filgrp) <> *blanks;

               //Set filgrp as current librabry
                command = 'CHGCURLIB CURLIB(' + %trim(w_filgrp) + ')';
                exec sql CALL QSYS2.QCMDEXC(:command) ;

               //Could not change librarylist, get next
                if sqlcod <> 0;
                return;
                else;
                commit;
                endif;

               endif;
            endif;

       //Profile information
        if %scan('profile':message.messageKey) > 0;

        // Extract Jason response into temporary values

       Exec SQL
       select t.id, t.code, t.name, t.version,
         t.description, t.tenantIdentifier, t.state
         into :w_prof_id,
              :w_code,
              :w_prof_name,
              :w_version,
              :w_description,
              :w_tenantIdentifier,
              :w_state
         FROM json_table(:w_messagedata, 'lax $'
         COLUMNS (
           id              numeric      PATH 'lax $.id'
                                        DEFAULT '0' ON EMPTY,
           code            varchar(35)  PATH 'lax $.code'
                                        DEFAULT ' ' ON EMPTY,
           name            varchar(128) PATH 'lax $.name'
                                        DEFAULT ' ' ON EMPTY,
           version         numeric      PATH 'lax $.version'
                                        DEFAULT '0' ON EMPTY,
           description     varchar(512) PATH 'lax $.description'
                                        DEFAULT ' ' ON EMPTY,
           tenantIdentifier varchar(128) PATH 'lax $.tenantIdentifier'
                                        DEFAULT ' ' ON EMPTY,
           state           varchar(25)  PATH 'lax $.state'
                                        DEFAULT ' ' ON EMPTY
                  )
           ) AS t;

       if sqlcod <> 0;
          return;
       endIf;

       exec sql
       update prmpst set
           pmpnam = :w_prof_name,
           pmpver = :w_version,
           pmpdes = :w_description,
           pmptid = :w_tenantIdentifier,
           pmpsta = :w_state
       where
           pmpfir = :w_firm and
           pmppid = :w_prof_id and
           pmpcod = :w_code;

       if sqlcod = 0;
           commit;
           return;
       endif;


         if sqlcod = 100;

          exec sql
             insert into prmpst
              (pmpfir, pmppid, pmpcod, pmpnam, pmpver, pmpdes, pmptid, pmpsta)
               values(:w_firm,:w_prof_id,:w_code,:w_prof_name,:w_version,
                   :w_description,:w_tenantIdentifier,:w_state);

          if sqlcod <> 0;
              return;
             else;
              commit;
          endif;

         endif;

       endif;

       //Article information
       if %scan('article':message.messageKey) > 0;


        // Extract Jason response into temporary values

       Exec SQL
           select t.externalNumber, t.name,
                 t.productGroupNumber, t.ruleIds
          into :w_externalNumber,
               :w_name,
               :w_productGroupNumber,
               :w_ruleIds
          FROM json_table(:w_messagedata, 'lax $'
          COLUMNS (
        externalNumber     varchar(15)  PATH 'lax $.externalNumber'
                                        DEFAULT ' ' ON EMPTY,
        name               varchar(256) PATH 'lax $.name'
                                        DEFAULT ' ' ON EMPTY,
        productGroupNumber varchar(5)   PATH 'lax $.productGroupNumber'
                                        DEFAULT ' ' ON EMPTY,
        ruleIds            varchar(6)   PATH 'lax $.ruleIds'
                                        DEFAULT ' ' ON EMPTY
              )
       ) AS t;

       if sqlcod <> 0;
         return;
       endIf;

       exec sql
       update prmast set
           pmades = :w_name,
           pmagrp = :w_productGroupNumber
       where
           pmafir = :w_firm and
           pmaenr = :w_externalNumber and
           pmarid = :w_ruleIds;

       if sqlcod = 0;
           commit;
           return;
       endif;


       if sqlcod = 100;

             exec sql
              insert into prmast
                (pmafir, pmaenr, pmades, pmagrp, pmarid)
               values(:w_firm,:w_externalNumber,:w_name,:w_productGroupNumber,
                      :w_ruleIds);

                if sqlcod <> 0;
                  return;
                  else;
                  commit;
                endif;

        endif;

       endif;

       //Rule information
       if %scan('rule':message.messageKey) > 0;

        // Extract Jason response into temporary values

            Exec SQL
              select t.id, t.name, t.usageType, t.actionCode, t.actionMessage,
                     t.statusCode, t.profileId
               into :w_rule_id,
                    :w_rule_name,
                    :w_usageType,
                    :w_actionCode,
                    :w_actionMessage,
                    :w_statusCode,
                    :w_profileId
               FROM json_table(:w_messagedata, 'lax $'
               COLUMNS (
                id            numeric      PATH 'lax $.id'
                                        DEFAULT '0' ON EMPTY,
                name          varchar(128) PATH 'lax $.name'
                                        DEFAULT ' ' ON EMPTY,
                usageType     varchar(25)  PATH 'lax $.usageType'
                                        DEFAULT ' ' ON EMPTY,
                actionCode    varchar(64)  PATH 'lax $.actionCode'
                                        DEFAULT ' ' ON EMPTY,
                actionMessage varchar(128) PATH 'lax $.actionMessage'
                                        DEFAULT ' ' ON EMPTY,
                statusCode    varchar(25)  PATH 'lax $.statusCode'
                                        DEFAULT ' ' ON EMPTY,
                profileId     numeric      PATH 'lax $.profileId'
                                        DEFAULT '0' ON EMPTY
                       )
               ) AS t;

             if sqlcod <> 0;
                return;
             endIf;

             exec sql
             update prmrst set
                 pmrdes = :w_rule_name,
                 pmrust = :w_usageType,
                 pmracd = :w_actionCode,
                 pmrams = :w_actionMessage,
                 pmrsta = :w_statusCode,
                 pmrpid = :w_profileId
             where
                 pmrfir = :w_firm and
                 pmrrid = :w_rule_id;

             if sqlcod = 0;
                 commit;
                 return;
             endif;


           if sqlcod = 100;

             exec sql
              insert into prmrst
                (pmrfir, pmrrid, pmrdes, pmrust, pmracd, pmrams, pmrsta, pmrpid)
               values(:w_firm,:w_rule_id,:w_rule_name,:w_usageType,
                      :w_actionCode,:w_actionMessage,:w_statusCode,
                      :w_profileId);

             if sqlcod <> 0;
                return;
                else;
                commit;
             endif;

           endif;

        endif;

         return;
       end-proc MyProc;
