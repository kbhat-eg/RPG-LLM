```markdown
# Program RY881R — Update Supplier in Item Lookup

## 1. Header Specifications
- `H option(*nodebugio) datedit(*dmy)`
  - Disables debug I/O, sets date format to DD/MM/YYYY.
- Comments describe:
  - System: ASVADM
  - Program name: RY881R
  - Purpose: Perform lookup and update supplier in the item-lookup table.

## 2. File Definitions
```rpg
Fjpfalu    uf   e           k disk    rename(jpfapfr:jpfalur)
Fvvarl1    if   e           k disk    rename(vvarpfr:vvarl1r)
Fjvprl1    if   e           k disk    rename(jvprpfr:jvprl1r)
```
- **jpfalu** (update file, keyed disk):
  - Original name `jpfapfr`, renamed to `jpfalur`.
- **vvarl1** (input file):
  - Original name `vvarpfr`, renamed to `vvarl1r`.
- **jvprl1** (input file):
  - Original name `jvprpfr`, renamed to `jvprl1r`.

## 3. Data Area (LDA) Definition
```rpg
D                uds
D l_firm                944    946  0
```
- A user-defined data structure (`uds`) maps program-wide fields from the LDA.
- `l_firm`: stores the firm number (3 digits).

## 4. Working-Storage Fields
```rpg
D vvarl1_vare     s                   like(vvvare)
D jvprl1_vare     s                   like(jxvare)
D jvprl1_ldor     s                   like(jxldor)
D w_firm          s                   like(jcfirm)
```
- **vvarl1_vare**: holds item code from `vvarl1`.
- **jvprl1_vare**, **jvprl1_ldor**: hold item code and quantity‐level for price lookup.
- **w_firm**: local copy of firm number.

## 5. Initialization Subroutine (`*INZSR`)
```rpg
C     *inzsr        begsr
C     jpfalu_key    klist
C                   kfld                    w_firm
C     vvarl1_key    klist
C                   kfld                    w_firm
C                   kfld                    vvarl1_vare
C     jvprl1_key    klist
C                   kfld                    jvprl1_vare
C                   kfld                    jvprl1_ldor
C                   eval      w_firm = l_firm
C                   endsr
```
- **Key lists** define record selection for each file:
  1. **jpfalu_key**: by `w_firm`.
  2. **vvarl1_key**: by `w_firm`, then `vvarl1_vare`.
  3. **jvprl1_key**: by `jvprl1_vare`, then `jvprl1_ldor`.
- Initializes `w_firm` from LDA field `l_firm`.

## 6. Main Logic Loop
```rpg
C     jpfalu_key    setll     jpfalu
C     jpfalu_key    reade     jpfalur
C                   dow       not %eof
C     if        jcvare <> *blank and jcldor = 0
C       eval      vvarl1_vare = jcvare
C       vvarl1_key chain     vvarl1
C       if        %found and vvnlev <> 0
C         eval      jvprl1_vare = vvvare
C         eval      jvprl1_ldor = vvnlev
C         jvprl1_key chain     jvprl1
C         if        %found
C           eval      jcldor = vvnlev
C           update    jpfalur
C         endif
C       endif
C     endif
C     jpfalu_key    reade     jpfalur
C                   enddo
```

Step-by-step:
1. **Set Lower Limit** and **Read Entry** from `jpfalu` using `jpfalu_key`.
2. Loop until end-of-file:
   - Check if `jcvare` (item code in the lookup record) is not blank **and** `jcldor` (supplier code) is zero.
   - If so:
     1. Populate `vvarl1_vare` = `jcvare`.
     2. **Chain** into `vvarl1` to get `vvnlev` (stock level) for that item.
     3. If found and `vvnlev` ≠ 0:
        - Populate `jvprl1_vare` and `jvprl1_ldor` from `vvvare` and `vvnlev`.
        - **Chain** into `jvprl1` to find a matching price entry.
        - If found:
          - Update `jcldor` = `vvnlev` (or the logic-specified supplier code).
          - **UPDATE** the current `jpfalur` record.
3. Read next `jpfalur` record.

## 7. Program Termination
```rpg
C     avslutt       tag
C                   eval      *inlr = *on
C                   return
```
- Sets **Last Record Indicator** `*INLR = *ON` to close files and end the program.

---

This structure ensures that for each item-lookup record without a supplier, the program finds the appropriate stock level and price entry, then updates the supplier code accordingly.