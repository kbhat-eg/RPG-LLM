# RPG Program Walkthrough and Explanation

This RPG program (FO706r) calculates totals per picked order, with and without VAT, based on order lines. It's designed to be used on IBM i systems and accesses several database files. Below, the code is explained section-by-section for onboarding developers.

---

## 1. **File Specifications**

```rpg
fvltyl1    if   e           k disk    rename(vltypfr:vltyl1r)
ffodtl1    if   e           k disk    rename(fodtpfr:fodtl1r)
flwpll1    if   e           k disk    rename(lwplpfr:lwpll1r)
ffohel1    if   e           k disk    rename(fohepfr:fohel1r)
fvvarl1    if   e           k disk    rename(vvarpfr:vvarl1r)
```

- **Files opened:** Order types, order lines, picking file, order header, product register.
- **`if`**: Input file.
- **`e`**: External description.
- **`k`**: Keyed access.
- **`disk`**: Disk file.
- **`rename`**: File is renamed for use within this program.

---

## 2. **Data Structures and Variables**

### 2.1 Local Data Area

```rpg
d                uds
d l_user                911    920
```
- **UDS**: User-defined data structure aligned with the program’s local data area.
- **l_user**: User information from a certain position (911–920).

### 2.2 Arrays (for VAT handling per rate)

```rpg
d mko             s              1    dim(9)
d msa             s              5  2 dim(9)
d mgr             s             11  2 dim(9)
d mbe             s             11  2 dim(9)
d mog             s             11  2 dim(9)
d mor             s             11 2  dim(9)
```
- Arrays hold:
  - VAT codes per rate.
  - VAT rates.
  - Amount bases for VAT.
  - Calculated VAT per rate.
  - Order group amounts.
  - Order-related VAT calculations.

### 2.3 Parameters

```rpg
d p_firm          s                   like(fdfirm)
d p_numm          s                   like(fdnumm)
d p_suff          s                   like(fdsuff)
d p_sumi          s                   like(fototx)
d p_sumu          s                   like(fototx)
```
- **Input:** Company, order number, suffix.
- **Output:** Totals including (p_sumi) and excluding VAT (p_sumu).

### 2.4 Variables for Keys and Working

Definitions like:

```rpg
d vltyl1_ltyp     s                   like(valtyp)
d fodtl1_numm     s                   like(fdnumm)
...
d w_tnet          s                   like(fototr)
d w_xmbe          s                   like(fototr)
```
- Store keys and temporary calculation results as the program processes records.

---

## 3. **Main Program Flow**

### 3.1 Initialization

```rpg
c                   eval      w_tnet = 0
c                   eval      p_sumi = 0
c                   eval      p_sumu = 0
```
- Reset totals at program start.

### 3.2 Reading and Summing Order Lines

```rpg
c                   eval      lwpll1_numm = p_numm
c                   eval      lwpll1_suff = p_suff
c     lwpll1_key    setll     lwpll1
c     lwpll1_key    reade     lwpll1
c                   dow       not %eof(lwpll1)
  ...
c     lwpll1_key    reade     lwpll1
c                   enddo
```
- Set up and read all lines in the picking file (`lwpll1`) that match the given order.

#### **Within the loop:**

1. **Fetch corresponding order line:**
    ```rpg
    c                   eval      fodtl1_numm = mknumm
    c                   eval      fodtl1_suff = mksuff
    c     fodtl1_key    chain     fodtl1
    ```
    - Locate order line matching picked line.

2. **If found, get line type info:**
    ```rpg
    c                   eval      vltyl1_ltyp = fdltyp
    c     vltyl1_key    chain     vltyl1r
    ```

3. **If it’s not a text line, process:**
    ```rpg
    c                   if        valktx = 0
    ```

4. **Calculate net price:**
    ```rpg
    c                   eval      w_npri = fdsums - fdsumr
    c                   eval      w_pris = w_npri / fdanta
    c                   eval      w_tnet = w_tnet + (w_pris * mkantp)
    ```
    - **w_npri**: Net amount for line.
    - **w_pris**: Price per unit.
    - **w_tnet**: Running total (excluding VAT).

5. **If there is a VAT code, call VAT routine:**
    ```rpg
    c                   if        fdomva <> *blank
    c                   eval      w_stat = *blank
    c                   eval      w_mvak = fdomva
    c                   time                    w_dato
    c                   call      'RS205R'
    ...parms...
    c                   if        w_mvas > 0
    c                   eval(h)   w_mvab = w_mvab + (w_npri * w_mvas / 100)
    c                   exsr      xarray
    c                   endif
    c                   endif
    ```
    - Calls `RS205R` (external VAT calculation subprogram).
    - Updates VAT total for the current line if applicable.
    - Calls subroutine **xarray** to accumulate VAT by rate.

### 3.3 After Loop (Summing up)

```rpg
c                   eval      p_sumu = w_tnet
```
- Store net sum (excl. VAT) in output parameter.

#### **Aggregate VAT for different rates:**

```rpg
c                   eval      mbe = (mgr - mor) * msa / 100
c                   xfoot     mbe           w_xmbe
c                   eval      p_sumi = w_tnet + w_xmbe
```
- VAT is computed for each rate; cross-footed to get total VAT; added to net total for gross (incl. VAT).

---

## 4. **Subroutines**

### 4.1 **xarray**: VAT by Rate Accumulation

```rpg
c     xarray        begsr
c     1             do        9             m
c                   if        mko(m) = w_mvak or
c                             mko(m) = ' '
c                   eval      mko(m) = w_mvak
c                   eval      msa(m) = w_mvas
c                   eval      mgr(m) = mgr(m) + w_npri
c                   if        forabp > 0
c                   if        vvkord = 0
c                   eval      mog(m) = mog(m) + w_npri
c                   eval      mor(m) = mog(m) * forabp / 100
c                   endif
c                   endif
c                   leave
c                   endif
c                   enddo
c                   endsr
```
- Looks for the matching VAT code in the array or an empty slot.
- Updates per-rate totals with current line's net price and VAT rate.

### 4.2 **Initialization Subroutine (\*inzsr)**

```rpg
c     *inzsr        begsr
c     *entry        plist
c                   parm                    p_firm
c                   parm                    p_numm
c                   parm                    p_suff
c                   parm                    p_sumi
c                   parm                    p_sumu
...
c                   eval      w_firm = p_firm
c                   endsr
```
- Parameter passing for program call.
- Sets up key lists for file lookups.
- Stores the firm number for use.

---

## 5. **Key Lists**

```rpg
c     vltyl1_key    klist
c                   kfld                    w_firm
c                   kfld                    vltyl1_ltyp
c     fodtl1_key    klist
c                   kfld                    w_firm
c                   kfld                    fodtl1_numm
c                   kfld                    fodtl1_suff
c     lwpll1_key    klist
c                   kfld                    w_firm
c                   kfld                    lwpll1_numm
c                   kfld                    lwpll1_suff
c     vvarl1_key    klist
c                   kfld                    w_firm
c                   kfld                    vvarl1_vare
```
- These are used for indexed access to the various files, based on firm, order number, suffix, etc.

---

## 6. **End of Program**

```rpg
c                   eval      *inlr = *on
c                   return
```
- Sets the last record indicator to close files and end the program.

---

# **Summary**

This program processes all picked lines in an order, sums up the net and gross (incl. VAT) totals using information from several related files. It handles VAT per rate using arrays, calls an external VAT calculation program, and supports different rates by accumulating and finalizing results per rate for the order. 

### **Main takeaways for new developers:**

- **Order line processing:** Iterates over all lines for an order, fetches details, and processes financial values.
- **VAT handling:** Dynamic per-rate VAT calculation using both arrays and an external program.
- **Data organization:** Extensive use of keyed access and arrays for performance and clarity.
- **Modularization:** Subroutines and parameter list for input/output make the program maintainable and extendable.

---

If you need more details on a specific section or logic, feel free to request!