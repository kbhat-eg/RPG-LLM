## Overview

This RPG program (`NW860R`) is a core component of our WAP (Web Application Portal) API order entry process. It is designed to receive, validate, and process order entry data—both headers and lines—by listening to an input data queue and writing processed order information to external files. The program features robust data validation, numbering, and interaction with several master tables (like customer, product, item/part, code), as well as basic messaging capabilities.

## Business Context

- **Receives order data** via a data queue mechanism, making it suitable for API usage or integration with middleware (e.g., a web front-end or EDI).
- **Processes both order headers and order lines**: a two-step order entry supported with related data structures for each step.
- **Validates input**, avoiding duplicate references and looking up master data (e.g., customer names, product names).
- **Writes order data** into external header (`nohelur`) and line (`nodtlur`) files, which are pick-up points for batch/order-processing on the back-end.
- **Interacts with a numbering service**, retrieving the next available document/order number from a number series file.
- **Triggers notifications** to order handlers via messaging (though this is currently commented out).

## File and Data Relationships

### Data Files Accessed

- `nohel6`, `nohelu` (order header master and update file)
- `nodtlu` (order line update file)
- `rkunl1` (customer master)
- `fkprl1` (customer project master)
- `vvarl1` (item/part master)
- `fusrl1` (user master, for notification)
- `nkeol1` (external code, for number series lookup)

The logical relationships:
- All lookups (order header, customer, product, item) are done by `firm` (company) and a relevant key. The new order record is associated with the current firm from parameters.

### Data Queue Processing

- The program sits in a loop, **receiving entries from a queue** (`QRCVDTAQ`), with the queue/input library, wait time, and buffer length passed as parameters.
- Each data queue entry is processed as either:
  - The **order header** (first record for each order)
  - Or an **order line** (subsequent records).
- The loop breaks when a blank record is received.

## Structure and Flow

### 1. Initialization

- The program is invoked with a parameter list (see `*entry` and `plist`) providing company, queue, library, lengths, keys, etc.
- Firm is initialized from the parameter and held in `w_firm`.

### 2. Main Loop

- Loops indefinitely, calling `QRCVDTAQ` to wait for the next input record from the data queue.
- Each non-blank record is passed to the `behandling` (process) subroutine.

### 3. Order Processing (`behandling` subroutine)

- **Order Header Processing**: If it’s the first entry (`b_frst`), process as order header (`behandl_hode`).
- **Order Line Processing**: Otherwise, process as order line (`behandl_linje`).
- After the first header is processed, `b_frst` is set to off.

### 4. Order Header Processing (`behandl_hode`)

- Maps the inbound header buffer (`d_inpu`) to a structured layout using overlays.
- **Duplicate Check**: Looks up in `nohel6` (order headers) for existing order with the same reference. If found, sets error code `2` and exits.
- **Header Values Preparation**: Populates external order header fields from input.
- **Master Data Lookups**:
  - Customer name from `rkunl1`
  - Project (product) name from `fkprl1`, if a project is assigned
- **Date Handling**: Parses/sets incoming order date if provided.
- **Order Number Assignment**: Retrieves next order number via `nkeol1` lookup and a call to the `AS100R` numbering program.
- **Write Header Record**: Writes the record to `nohelur` (header update file), including metadata (timestamps, user IDs).

### 5. Order Line Processing (`behandl_linje`)

- Maps the inbound line buffer to a structured layout.
- **Populates line fields**: Sets product, quantity, unit, descriptions, etc.
- **Line Numbering**: Increments the line number per each call.
- **Product Lookup**: Retrieves standard texts from the item master (`vvarl1`) based on the line's item.
- **Date Handling**: Maps any provided delivery date.
- **Write Line Record**: Writes out to `nodtlur` (line update file).
- **Message Handling**: If a line message exists (e.g., special instructions on the line), processes it as a separate “message-only” line (blank item, description only).

### 6. Notification (Optional)

- The `send_melding` routine (currently commented out) notifies responsible handlers (users flagged in `fusrl1`), invoking another program (`NN821C`) for each.

### 7. Error Handling

- PSSR logic sets error code `1` and exits gracefully.

### 8. Cleanup

- When the input queue is exhausted (`d_inpu = *blank`), the program sets on LR and returns.

## Design Patterns and Conventions

- **Data-driven processing**: Structured overlays and data queues allow separation between API input format and back-end files.
- **Master data validation**: All important references are validated/expanded from their respective Master files to ensure referential integrity.
- **Parametrization**: All runtime variables (firm, queue name, library, lengths, etc.) are provided as parameters, making this codebase suitable for multi-tenant or multi-company environments.
- **Number series abstraction**: The separation of number series logic into an external program (`AS100R`) and file (`nkeol1`) decouples numbering from transactional code, centralizing control and audit of numbering.

## Non-obvious Implementation Details

- **Message as line**: The concept of encoding a line message as a stand-alone order line (with blank item, only text) is domain-specific, often used for comments or special instructions.
- **Overlay and parsing techniques**: The use of overlays for extracting fixed-position segments out of queue input buffers enables processing variable order layouts with a single program, but means input layout must be consistent and coordinated with integration partners.
- **Concurrent processing**: Because this listens on a data queue, multiple instances can in theory run in parallel, promoting throughput—so beware of sequence/numbering collisions unless `AS100R`/numbering is totally atomic.

## Integration Points

- **Data queues**: Integrates with the OS/400 data queue mechanism, typically used for high-volume, decoupled communication between server-side jobs or with external systems.
- **External numbering program**: Calls `AS100R` to guarantee unique order numbers.
- **Master files**: Heavily interacts with customer, project, product, and other reference/master files, so correct population and indexes (keys) are prerequisites.
- **User notifications**: Provides (optionally) messaging integration to alert order handlers of new arrivals.

## Summary

This program is a robust and flexible API endpoint for order entry on the IBM i platform, featuring validation, master data integration, and flexible business logic encapsulated in a strongly parameterized and modular structure. All developers working in this area should pay careful attention to the data queue format, master file contents, and the numbering integration, as these are the primary points for customization, troubleshooting, and extension.