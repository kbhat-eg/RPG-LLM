# Explanation of RPG Program FX805R

This RPG program, named **FX805R**, is designed to update inventory balances (`lagerbeholdning`) based on dispatch notes (`pakkseddel`). It processes order headers and order lines, updates inventory if required, and keeps tracking information up to date. The code is classic ILE RPG (pre-free format), with record-level access to physical files and a few subroutines for structure.

Below is a breakdown of the important sections of the program.

---

## **1. Header (H-Spec) and History**

```rpg
h option(*nodebugio)
```
- Disables debug I/O optimization for the program.

The first commented block documents program versions, references, and purpose:
- **Program purpose:** Updates inventory balances from dispatch notes.
- **Change history:** Lists modifications, enhancements, and bug-fixes.

---

## **2. File Declarations (F-Specs)**

```rpg
ffstsl1    if   e           k disk    rename(fstspfr:fstsl1r)
ffohel1    if   e           k disk    rename(fohepfr:fohel1r)
ffohelu    uf a e           k disk    rename(fohepfr:fohelur)
ffodtl1    if   e           k disk    rename(fodtpfr:fodtl1r)
fvotyl1    if   e           k disk    rename(votypfr:votyl1r)
```
- Declares database files used for reading/writing.
- Uses `rename` to map external format names to internal format names.
- Files correspond to system codes:
  - `fstsl1`: Company code register
  - `fohel1`, `fohelu`: Order header files (different formats for update/read)
  - `fodtl1`: Order detail (lines)
  - `votyl1`: Order type register

---

## **3. Data Structures (D-Specs)**

### **a. Local Data Area Extraction**
```rpg
d                uds
d l_wsid                901    910
d l_user                911    920
d l_firm                944    946  0
```
- Reads user, workstation id, and company (firm) number from the user data section (`uds` â€“ system area).

### **b. Inventory Update Structure (`hlrec`)**
```rpg
d                 ds
d hlrec                        128
d  hlvare                       15    overlay(hlrec)
d  hllage                        2  0 overlay(hlrec:16)
...
d  hlonum                        8  0 overlay(hlrec:90)
d  hlolin                        4  0 overlay(hlrec:98)
```
- A single 128-byte structure used for passing inventory update information.
- Each field overlays a portion of `hlrec`, giving the structure for the inventory update API/program.

### **c. Key and Helper Variables**
Defines variables for building keys and holding data (e.g., `w_firm`, `fohelu_numm`, etc.).

---

## **4. Main Logic**

### **(a) Read All Order Headers for the Company**

```rpg
c     fohel1_key    setll     fohel1
c     fohel1_key    reade     fohel1
c                   dow       not %eof
```
- Begins by reading each order header for the current company.
- `setll/reade/dow` pattern reads a group of records with a common key.

### **(b) Filtering/Skipping Logic**

```rpg
c                   if        faalag = 0
c                   goto      les_hode
...
c                   if        foolag = 1
c                   goto      les_hode
```
- Skips orders that don't require inventory management or have already been updated.

### **(c) Check Order Type Requirements**

```rpg
c                   eval      votyl1_otyp = footyp
c     votyl1_key    chain     votyl1r
c                   if        not %found or vaoakk <> 2
c                   goto      les_hode
```
- Reads the order type register to verify that the type requires inventory update (`vaoakk = 2`).

### **(d) Process Order Lines**

```rpg
c                   exsr      les_linjer
```
- Calls `les_linjer` subroutine to process all lines for this order.

### **(e) Mark Order Header as Inventory Updated**

```rpg
c                   eval      fohelu_numm = fonumm
c                   eval      fohelu_suff = fosuff
c     fohelu_key    chain     fohelu
c                   if        %found
c                   eval      foolag = 1
...
c                   update    fohelur
c                   endif
```
- Updates the order header to indicate the inventory has been updated.
- Sets last update date/time/user.

### **(f) End-of-loop and Program Exit**

```rpg
c     les_hode      tag
c     fohel1_key    reade     fohel1
c                   enddo
...
c                   eval      *inlr = *on
c                   return
```
- Continues processing all order headers. Sets LR (last record) to `on` and exits at end.

---

## **5. Subroutine: `les_linjer` (Read Order Lines)**

Processes all lines for the current order:

```rpg
c     les_linjer    begsr
...
c     fodtl1_key    setll     fodtl1
c     fodtl1_key    reade     fodtl1
c                   dow       not %eof
   ... determine w_dato (date to use)
   c                   exsr      opp_lag
c     fodtl1_key    reade     fodtl1
c                   enddo
c                   endsr
```
- Reads all order lines (`fodtl1`) for the current order header.
- For each line, determines the appropriate delivery date to use.
- Calls `opp_lag` to update inventory for this line.

---

## **6. Subroutine: `opp_lag` (Update Inventory)**

Prepares and calls the inventory update program:

```rpg
c     opp_lag       begsr
...
c                   eval      hlvare = fdvare
c                   eval      hllage = folage
c                   eval      hlenhe = fdenh1
c                   eval      hldato = w_dato
c                   eval      hltime = *loval
c                   eval      hlotyp = footyp
c                   eval      hlltyp = fdltyp
c                   eval      hlanta = fdanta
c                   eval      hlkopr = fdkopr
c                   eval      hlrefr = 'O:' + %char(fdnumm) + 'L:' + %char(fdline)
c                   eval      hlonum = fdnumm
c                   eval      hlolin = fdline
c                   eval      hlsyst = 'F'
c                   eval      hlaltk = *blank
c                   eval      hlrest = *blank
c                   move      fdlety        hllety
...
c                   eval      w_lrec = hlrec
c                   call      'VL001R'
c                   parm                    w_stat
c                   parm                    w_lrec
c                   endsr
```
- Moves relevant values from the order line into `hlrec`.
- Calls external program `VL001R` to update inventory.

---

## **7. Subroutine: `*inzsr` (Program Initialization)**

Sets up keys and starting values for the program:

```rpg
c     *inzsr        begsr
...
c                   eval      hltype = *blank
c                   eval      w_firm      = l_firm
c                   time                    w_date
c     fstsl1_key    chain     fstsl1r
c                   endsr
```
- Initializes keys for files.
- Sets company number, blank-initializes certain fields, fetches today's date, and reads company code register.

---

## **8. Keylists (`klist`)**

The program uses `klist` definitions for building composite keys for database operations:
- `fstsl1_key`, `fohel1_key`, `fohelu_key`, `fodtl1_key`, `votyl1_key`

Each is built with relevant fields for use in database lookups and updates.

---

## **Summary of Main Flow**

1. **Initialization (`*inzsr`)**
2. **For each order header** (for current company):
   - If inventory needs update, and order type requires it:
     - For each order line:
         - Build inventory update record.
         - Call inventory update program.
     - Mark order header as "inventory updated", update time/user.
3. **Exit program**

---

## **Key Points for Onboarding**

- **Files:** Know the file layouts (company, order header, order line, order type).
- **Subroutines:** Logic separated into reading lines and updating inventory.
- **Inventory Update:** Handled by `VL001R`, which is called with a packed record containing all details.
- **Re-entrancy:** The program processes all order headers for the firm; it skips those not requiring inventory or already processed.
- **Error Logic:** Minimal explicit error handling; skips orders as needed based on file contents.
- **Extensibility:** Change history shows adaptation to new requirements (fields, external program parameters, etc.).

---

## **Modernization Tips**

- This program uses classic (fixed-format) RPG. New development is usually free-form RPG.
- Database access uses record-level op-codes (`reade`, `chain`, `update`, etc.).
- Consider extracting business rules into service programs or using SQL access for future enhancements.

---

**In summary:**  
The program reviews unprocessed order headers for a company, and for each line that impacts inventory, it prepares and sends inventory update instructions to an external inventory program, and then marks the order header as processed. The logic is modular, and well-documented, and follows classic IBM i RPG conventions.