# RPG Program JR763R – Onboarding/Code Walkthrough

## Overview

This ILE RPG program processes input records (`S4` records from a file), parses various record types describing products, and updates a product master along with related tables (packaging, price, campaign, etc.) for "Løvenskiold Handel" (supplier 9999). 

**Main features:**
- Reads and parses an external file containing several different record formats describing products and prices.
- Updates the internal product master and associated tables.
- Special logic to only process products with supplier 9999.
- Handles campaign (promotion) header and item records.
- Calls subroutines/programs for updating searchable product texts.

## File Descriptions

- Files like `jrvapf`, `jvarl8`, etc., are *physical* or *logical* files for product data, packaging, price, campaign, lookup tables, etc.
- `jrvapf` is the incoming data file.
- `jvarl8`, `jvarl3`, etc. are various logical views for finding and updating master data.

## Data Structures and Variables

### Parameter and Local Data

- `p_list` – Parameter received by the program (probably from a CL).
- `d_list`, `d_firm`, etc. – Used to overlay and extract specific fields like company (firm), report type, and date from parameter.
- The user is pulled from the local data area (LDA).
- Various variables/fields are setup for working with keys, data transformations, and temporary fields for updates.

### Input Record Structures

Each incoming record from the source file is 75–167 chars. Each type of record (`161`, `162`, ..., `169`, `181`, `191`) has its own *overlay* structure for easy parsing (e.g., `m1_list`, `m2_list`, ...). The first three chars always specify the type (`w_rect`).

**Examples:**
- `161` – Main product record (`m1_list`)
- `162` – Product text lines (`m2_list`)
- ...etc.
- `181` – Campaign header
- `191` – Campaign item

Each record segment is parsed into appropriate fields using overlays.

## Main Loop

```rpg
c     read      jrvapf                                 90
c     dow       *in90 = *off
   ...
c     read      jrvapf                                 90
c     enddo
```

- Loops through all input records in file `jrvapf`.
- For each, reads three chars into `w_rect` to identify record type.
- Depending on `w_rect`, stores the data into the proper `mX_list` variable (select/case on type).
- For each new `161` ("main" product) record, if not first, processes the *previous* queued product by calling subroutine `oppdater` (which updates all the DB files for that product).
- At EOF, ensures the last product is also updated.

## Record Parsing

Within the loop, depending on `w_rect`:
- `161`–`169`: Store current line in the respective structure (`m1_list`, ..., `m9_list`).
- `181`: Campaign header – parsed and processed in `kamp_hode`.
- `191`: Campaign item – parsed and processed in `kamp_vare`.

## oppdater Subroutine

### Purpose

Updates or creates a product with all details collected from the set of `mX_list` records (for the current product) in the internal database files.

### Flow

1. **Supplier check:** Only processes products where `m3_ldor = '9999'`.
2. **Initialize numeric fields in empty records** (set to zero).
3. **Convert alpha "number" fields to numeric fields** as needed (group codes, dates, etc.).
4. **Prepare group codes and dates** for writing.
5. **Find existing product:**
   - If found (`chain` returns found): Calls `endr_vare` to delete old packages/prices.
   - If not found: Calls `ny_vare` to allocate next product number.
6. **Update or create main product record**, writing key fields, descriptions, etc.
7. **Call `oppd_pakning` to handle product packaging records.**
8. **Call `oppd_pris` to handle product price records.**
9. **Call external program to update search texts (call 'JV790R').**

## endr_vare Subroutine

- For *existing* product:
    - Deletes all non-manual package and price records for this product (and "9999" supplier).
    - Removes product-supplier links for supplier "9999".
    - If the product status is nonstandard, keeps it; otherwise, sets to `1`.

## ny_vare Subroutine

- For *new* product:
    - Sets status to `2`.
    - Allocates next product number from control file (`jstslu`).
    - Sets creation date.

## konkatiner Subroutine

- Concatenates product description lines 1 and 2, splits into 35-char chunks, left-justified, for re-storing in master.

## oppd_pakning Subroutine

- Writes packaging records for up to 5 units, for the product.
- Uses auxiliary file `fenkl1` to convert/enrich units of measure as needed.

## oppd_pris Subroutine

- Writes price record.
- If the price is zero, attempts to get fallback prices from other records.
- Deletes old package records (for "9999" supplier) and re-creates them (logic repeated from `oppd_pakning`).
- Registers supplier links as needed.

## kamp_hode / kamp_vare Subroutines

- Create or update campaign header (`181` records) and items (`191`) for the product, using related files and similar logic to above.

## Key Lists

- KLIST sections define composite keys for efficient lookups/chains into various DB files (by product/vendor, etc.).

## Initialization

- *INZSR subroutine parses incoming parameter, extracts company number, initializes key values, etc.

---

## Summary Table

| Subroutine      | Purpose                                      |
|-----------------|----------------------------------------------|
| **oppdater**    | Process and update product record set        |
| **endr_vare**   | Delete existing product packages/prices      |
| **ny_vare**     | Allocate new product number and init fields  |
| **konkatiner**  | Concatenate/truncate product texts           |
| **oppd_pakning**| Register packaging units                     |
| **oppd_pris**   | Register prices and re-write package records |
| **kamp_hode**   | Handle campaign headers                      |
| **kamp_vare**   | Handle campaign items                        |
| **INZSR**       | Startup/parameter parsing/init               |

---

## Key Business Rules

- **Only supplier '9999' is handled.**
- **Product records must be built from multiple record types** before writing (collect `161` - `169` then process).
- **On 'main' record boundary**, triggers product write, not every record.
- **Campaign records** are handled independently.
- **Search text updates** are handled by an external program.
- **Numeric conversions** (especially for group and date fields) are performed carefully.

---

## Onboarding Advice

- **Start with the `mX_list` record structures:** These overlays are crucial to understand how the input data is parsed.
- **Follow the main loop:** See how a product is built from a set of consecutive records.
- **Explore subroutines:** Each subroutine handles a distinct logical "update" or "creation" task in the database.
- **Note the exclusive focus on supplier 9999.**
- **Be careful with key management:** Many files have composite keys; trace them in the KLIST sections.

---

## Common Pitfalls

- **Record boundaries:** Must process records only when all relevant segments for a product have been collected.
- **Data integrity:** Deletes and rewrites for packages/prices can cause loss of manual records if not flagged correctly.
- **Character code translation:** The program translates special Norwegian chars from legacy code pages.

---

# Conclusion

This program is a "record processor"/"importer" for product master data and related tables, with special handling for a particular supplier. It's modular, with separation of concerns across subroutines. The main logic revolves around segmenting input records, collecting parts, and triggering updates on boundaries (new product or campaign).

If onboarding, start by tracing a single product through the main loop and into `oppdater`, and then follow how the supporting files are updated. Understanding the data structures and file layouts is key for making changes or debugging.

---

**Tip:** If you need to add new product fields, start by understanding the overlays in the `mX_list` structures!