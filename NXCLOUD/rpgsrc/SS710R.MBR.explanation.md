# Program Overview

This RPG program calculates the start date (Monday) and end date (Sunday) for a given ISO year and week number. It returns these dates along with a status code. The program handles input validation, assignment of dates based on ISO week rules, and considers the special case where week 53 might not exist in every year.

---

## Parameters

| Name     | Type    | Description                       | Direction |
|----------|---------|-----------------------------------|-----------|
| p_aarr   | 4,0S    | Year (input)                      | In/Out    |
| p_week   | 2,0S    | Week number (input)               | In/Out    |
| p_fdat   | Date    | Start date (Monday, output)       | Output    |
| p_tdat   | Date    | End date (Sunday, output)         | Output    |
| p_stat   | CHAR(1) | Status ('0'=OK, '1'=Invalid input)| Output    |
| p_inlr   | CHAR(1) | LR flag, governs program end      | In        |

---

## Main Logic

### 1. **Initialization**
- The program initializes the status code (`p_stat`) to blank, and both output dates (`p_fdat`, `p_tdat`) to their lowest possible values (`*loval`).

### 2. **Input Validation**
- Checks if the year or week is less than 1 or if the week number is greater than 53.
  - If invalid, status is set to '1', and the program jumps to label `avslutt` (end).

### 3. **Find January 4th**
- Utilizes ISO week rules: the week with the 4th of January is always week 1.
- Constructs a date string with the parameter year and '01-04' for January 4th, then parses it.

### 4. **Find the Day of the Week for January 4th**
- Calculates the difference in days between January 4th and a known Monday (2001-12-31).
- Uses mod 7 math to determine the weekday (1=Monday).

### 5. **Find Monday of First Week**
- If January 4th is a Monday, it's the start of week 1.
- Otherwise, subtracts the number of days necessary to back up to the previous Monday.

### 6. **Find Monday and Sunday of the Input Week**
- Calculates the Monday of the requested week by adding `(week-1) * 7` days to the first Monday.
- Sunday is 6 days after that Monday.

### 7. **Output Assignment**
- Assigns the calculated Monday and Sunday to output parameters.
- Sets status to '0' (OK).

### 8. **Special Check for Week 53**
- Verifies if week 53 exists (i.e., its Sunday is still within the current year).
- If it overlaps into the next year, increments the year and sets week to 1.

### 9. **End/Return**
- If `p_inlr` is not 'on', sets the internal LR indicator to end the program.
- Returns.

---

## Entry and Initialization Subroutine (`*inzsr`)

- Handles parameter list (`*entry plist ... parm ...`).
- Initializes output parameters to blank or lowest values.

---

## Additional Notes

- **Indicators**: Traditional RPG indicators are documented for display and error handling but are not used within the core logic here.
- **Special Comments**: Comments are in Norwegian; the code is well-commented for purpose and logic.
- **Date Manipulations**: Makes heavy use of ISO date arithmetic for accuracy with ISO week rules.
- **p_inlr**: Controls whether the RPG program ends; if not set, it sets *INLR to *ON, signaling program end.
- **Error Handling**: If input is invalid, the output dates are not set, and the status flag is '1'.

---

## Summary

**Purpose:**  
Given an ISO year and week, return the date of Monday and Sunday of that week, or set status '1' if invalid input.

**Usage:**  
This routine is useful for any system needing to convert ISO year/week to actual dates, such as reporting or scheduling programs. It is accurate to the ISO calendar definitions and gracefully handles corner cases like week 53.

---

### Example

If you call the program with:
- `p_aarr = 2023`
- `p_week = 15`

Output:
- `p_fdat` = 2023-04-10 (Monday)
- `p_tdat` = 2023-04-16 (Sunday)
- `p_stat` = '0'

If `p_week` is 0 or 54, or `p_aarr` is 0, output:
- `p_stat` = '1'
- Dates not set

---

**Good to Know:**  
- This code is written in traditional (fixed-format) RPG IV.
- Comments and variable names are in Norwegian, but logic is clear and easily adapted.  
- The program is self-contained, processes in-memory, and is typically called as a utility/procedure.