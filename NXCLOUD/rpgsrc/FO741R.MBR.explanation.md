# RPG Program FO741R – Explanation

This RPG (Report Program Generator) source code implements the business logic for **automatic generation of purchase orders from sales orders**, with the ability to **view and process purchase orders per supplier**. The program is quite comprehensive and handles order lines, purchase proposal creation, supplier selection, price group logic, inventory updates, and more.

It is heavily commented with history logs (in Norwegian), showing continuous development and adaptation over many years.

Below is an onboarding-focused, readable overview and explanation of the code sections and main logic.

---

## 1. Control Specifications and Header

```rpg
h datedit(*dmy) option(*nodebugio)
```

- `datedit(*dmy)`: Date format Day-Month-Year.
- `option(*nodebugio)`: Optimizes runtime I/O, disables certain debugging options.

---

## 2. File Declarations (`F` specs)

- Multiple logical files are declared, many with alternate record formats (`rename`), for order headers/lines, purchase headers/lines, suppliers, customers, items, etc.
- The display file `FO741D` is used for interactive processing with a subfile named `B1SFL`.
- Examples:
  ```rpg
  ffodtl2    if   e           k disk    rename(fodtpfr:fodtl2r)
  ffo741d    cf   e             workstn sfile(b1sfl:w_srrn)
  ```

---

## 3. Data Structure and Variable Declarations (`D` specs)

### a. LDA (Local Data Area) Mapping

- Maps workspace ID, user, firm number, etc., from the LDA for use in audit and process logic.

### b. Feedback Data Structure

- For handling display file feedback (e.g., which function keys users pressed).

### c. Inventory Update Data Structure

- `hlrec` overlays various fields for sending inventory transactions to another program.

### d. Local Variables

- Numerous variables for order/purchase numbers, line numbers, types, flags, sums, and work fields.

- Typical variables:
  - `w_firm`: Company number.
  - `w_numm`: Order number.
  - `w_best`: Purchase number.
  - `w_ldor`: Supplier number.

---

## 4. Main Program Logic (Calculation Specs)

### a. Program Initialization

- Initializes key lists (`klist`) for file access.
- Handles entry parameters (order, supplier, etc.).
- Loads status codes for current context.

### b. Main Loop & Display Handling

- The main tag is `d1taga`, which controls screen display and event processing.
- Subfiles are managed for displaying order lines and allowing the user to perform actions (edit, delete, create purchase, etc.).

### c. Function Key Handling

- Handles keys for:
  - Refresh/F10: Reloads the subfile.
  - Next/Prev page
  - Show All (toggle display of all lines)
  - Create Purchase (`F9`)
  - Exit (`F3`)

---

## 5. Subroutines

### a. `forny` – Refreshes Subfile

- Resets the subfile and repopulates it from the latest order data.

### b. `subfile` – Subfile Processing

- Loops through user selections (e.g., change/delete on lines) and dispatches to handler routines for the chosen action.

### c. `endre_linje` & `slett_linje` – Change/Delete Order Line

- Currently, stubs for more detailed per-line change/delete logic.

### d. `clr_subfile` – Clear Subfile

- Resets subfile-related control fields and status indicators.

### e. `crt_subfile` – Create/Populate Subfile

- Reads order lines, applies visibility and selection checks, and writes lines to the subfile buffer.
- Calls `VL710R` for each line to fetch price group/type information.
- Only displays eligible lines (e.g., not already ordered, valid for selection).

### f. `bck_subfile` – Page Back in Subfile

- Handles back paging logic for subfile display.

### g. `dsp_subfile` – Display Subfile

- Prepares control indicators and displays the subfile screen for user interaction.

### h. `hent_ordre` – Fetch Order Information

- Reads the order header (and associated customer, order type, and supplier info), then updates display fields.
- Determines if the process is for an actual purchase order or a proposal.

---

## 6. Purchase (Bestilling) Logic

### a. `lag_best` – Create Purchase Order

- Checks:
  - If order already has a purchase.
  - If supplier is valid (and prompts for selection if not).
- Retrieves the next purchase order number.
- Builds keys for purchase files.
- Calls `bes_lin` to create purchase order lines.
- If lines exist, calls `bes_hode` to create the purchase header.

### b. `bes_lin` – Create Purchase Order Lines

- Reads order lines, checks for eligibility, and creates corresponding purchase lines.
- Applies price and cost logic (calls other programs for group/type, uses cost/price fields).
- Updates inventory via a call to `VL001R`.
- Updates the original order lines to indicate quantities already ordered.

### c. `bes_hode` – Create Purchase Header

- Summarizes totals, populates all relevant header fields, and creates the purchase order header record.
- Also writes a supplementary record (for EDI transmission if needed).

---

## 7. Purchase Proposal (Bestillingsforslag) Logic

### a. `lag_best_for`

- Same structure as `lag_best`, but creates a **proposal** instead of an actual order.
- Retrieves proposal number, creates proposal lines and header.

### b. `bes_lin_for` & `bes_hode_for`

- Analogous to `bes_lin` and `bes_hode`, but for proposals.
- Uses relevant data structures and additional logic related to proposals.

---

## 8. Utility Routines

### a. `hntltx` – Fetch Warehouse Text/Address

- Calls `FØ720R`, moves text/address info into header fields, then fetches logistics point if needed.

### b. `hent_logp` – Fetch Logistics Point

- Calls `MJ500R` to retrieve logistics/warehouse location data for the line.

### c. `opplag` – Update Inventory

- Loads inventory movement data and calls `VL001R` to update inventory.

### d. `hntnum` – Fetch Next Sequence Number

- Calls `AS100R` to get the next available purchase/proposal number.

### e. `hent_total` – Summarize Totals

- Sums up cost, price, and discount totals for the purchase order.

---

## 9. Entry Parameters

- The program accepts five parameters: company (`p_firm`), order number/suffix, bestilling (purchase) number, and supplier number.
- These are used to initialize the runtime context.

---

## 10. Key Points and Customization

- Many fields, selection rules, and price/group logic are driven by business-specific requirements (Norwegian variable names reflect system domain).
- The code is highly modular, with clear separation of subroutines for each functional area.
- Extensively commented with references to feature changes, versioning, and bug fixes.
- Calls several external programs for price group, number sequences, status, warehouse info, and inventory updates.

---

# **Summary**

- **Purpose**: Automate the process of creating purchase orders or proposals from sales orders, allowing user interaction to edit or confirm lines, select suppliers, and update the inventory and status appropriately.
- **User Interaction**: Via subfiles, for per-line action, and summary screens.
- **Integration**: With inventory, item, supplier, customer, and order type files, and other programs for logic and updates.

---

## **Onboarding Recommendations**

- **Understand the Files**: Familiarity with the logical files and data structures used (order headers, purchase headers, item master, etc.) is essential.
- **Business Rules**: Review the Norwegian comments and version notes for business logic context on order types, supplier handling, and price group logic.
- **External Programs**: Be aware of dependencies on external programs (e.g., `VL710R`, `AS100R`, `VL001R`).
- **Navigation and Display**: Understand how RPG subfiles work for paging, selection, updating, and refreshing lists.
- **Error Handling**: Most error-handling is manual/user-prompted (e.g., missing supplier).

---

**This program is a central component in an order-to-purchase workflow with a focus on control, audit, and accuracy across order, inventory, and supplier operations.**