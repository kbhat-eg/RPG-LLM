# RPG Program Explanation: RE121R

This program is a classic ILE RPG (RPG/400) batch program, primarily for processing and transforming transaction data coming from PC systems into an IBM i (AS/400) environment. Specifically, it parses CSV-like input records, extracts fields, and writes output transactions. The user documentation and variable names suggest it's related to financial transactions (vouchers, invoices, customer data, etc.) in a Norwegian system.

Below, you’ll find a walkthrough of the structure and logic with explanations suitable for onboarding a developer new to this codebase.

---

## 1. Program-Level Keywords

```rpg
h datedit(*dmy) option(*nodebugio)
```
- `datedit(*dmy)`: Sets default date format to Day-Month-Year.
- `option(*nodebugio)`: Excludes I/O fields from debug view.

---

## 2. File Declarations

```rpg
fre0ipf    ip  ae           k disk
fafirl1    if   e           k disk    rename(afirpfr:afirl1r)
fraa3l1    if   e           k disk    rename(raa3pfr:raa3l1r)
fraa4l1    if   e           k disk    rename(raa4pfr:raa4l1r)
fre0tpf    o    e           k disk
fre0kpf    o    e           k disk
```
- **Input Files**: `re0ipf`, `afirl1`, `raa3l1`, `raa4l1` (keyed, external description, sometimes renamed for clarity).
- **Output Files**: `re0tpf`, `re0kpf` (transaction data to be output).
- The renamed files indicate use of logical or physical files related to accounting (company, periods, etc.).

---

## 3. Variable Declarations

- **wrec**, **wflt**: Work arrays used for extracting and manipulating fields.
- **per**: Array for periods.
- **txt**: Array for voucher texts, loaded from compile-time data (see the end of the source).
- **Several packed/char fields**: Used for storing parsed field values (company, period, dates, user, text fields, etc.).
- Various `wxxxxN` variables: Temporary holding of extracted fields.

---

## 4. Field Extraction Logic

### **CSV Parsing**

The main body is a large (classic) RPG cycle, reading one record at a time and parsing it field by field.

#### **Steps:**
1. **Combine input fields (`rpcin1`, `rpcin2`, `rpcin3`) into a single work array (`wrec`).**
2. **For each expected CSV field:**
   - Re-initialize work arrays (`wflt`, `wfelt`) to blanks.
   - Use a loop (`DOU`) to copy characters from `wrec` to `wflt` until the separator is found (`,` or `"` depending on the field).
   - Move the result into a named variable.
   - Special handling for fields (e.g., dates, voucher types, text fields).

#### **Example - Voucher Code:**
```rpg
c                   z-add     1             x
c                   z-add     1             y
c                   eval      wflt = *blank
c                   eval      wfelt = *blank
B001 c                   dou       wrec(x) = ','
c                   move      wrec(x)       wflt(y)
c                   add       1             y
c                   add       1             x
E001 c                   enddo
c                   movea     wflt          wfelt
c                   movel     wfelt         rtbilk
```
- Zeros out pointers, blanks out work fields.
- Loops through `wrec` starting at position `x`, copying up to the next `,`.
- Moves the string to `rtbilk` (voucher code).

#### **Special Cases:**
- **Dates**: Use of `move` with date edit specification to convert to proper date format.
- **Voucher Codes**: Some codes (`9860`, `9861`, etc.) are mapped to specific descriptions/IDs and overrule parsed values for compatibility.
- **Text Parsing**: For text fields that are quoted, loop until a `"` (not `,`).
- **Amounts**: Parse, move into multiple variables, perform conversion logic (e.g., to integer, to 9-digit value).

---

## 5. Output Record Assembly

Once all fields are parsed, the program assembles the output transaction record:

- Sets header and detail fields: company, voucher type, batch number, line number, etc.
- Copies over the parsed data.
- Sets various default/control fields (many are set to blanks or zeros).
- Writes the output record to `re0tpfr` (transaction file) and `re0kpfr` (customer file).

---

## 6. Subroutine: Initialization (`*inzsr`)

At program start, some initialization occurs:
- Sets firm from local value.
- Zeroes work variables.
- Increments batch number.
- Reads from reference files (`afirl1`, `raa3l1`, `raa4l1`) for field population.
- Handles the case where expected data isn't found (e.g., sets a note value to 0).

---

## 7. Compile-Time Data

At the very end, voucher text labels are defined:

```
**   Bilagstekster
Faktura
Kreditnota
�reavrunding
Gebyr
Utg. MVA
```
These texts are loaded into the `txt` array for mapping certain voucher codes to human-readable text.

---

## 8. General Observations

- The program is highly procedural, reflecting its age.
- It is designed to be flexible with variations in voucher records, handling special cases for codes and defaulting missing values.
- The code is heavily commented (in Norwegian), with maintenance history tracked.

---

## 9. Key Points for Onboarding

- **Field Extraction**: The bulk of the logic is in extracting fields from input, delimiter-based, using manual looping.
- **Special Mapping**: Several voucher codes trigger specific business logic (text and code overrides).
- **Output Preparation**: After parsing, output records are assembled with both parsed and default values.
- **Reference Files**: Several input reference files are used for lookup and batch/company context.
- **Text Constants**: Voucher description texts are handled via the `txt` array and compile-time data.

---

## 10. Modernization Notes

- This code represents a style predating free-format RPG.
- Field parsing could be made more robust and maintainable using modern string handling (for future refactoring).
- Heavy manual data movement (using `movea`, `movel`, `move`) is typical for classic RPG, but modern RPGLE would use assignment and built-in functions for clarity.

---

**Summary:**  
This program reads input voucher/transaction data (from PC systems), parses the fields, applies some business logic for special voucher codes, and outputs formatted accounting transactions to the system's transaction files. The logic is repetitive but systematic, allowing onboarding developers to follow along field by field. Understanding the field extraction loops is key to understanding the whole program.