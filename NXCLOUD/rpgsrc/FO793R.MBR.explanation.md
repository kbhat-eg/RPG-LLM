# RPG Program Overview

This RPG (Report Program Generator) source code is an ILE RPG program used on IBM i (AS/400) systems. The purpose of the program is to generate XML output for integration with Cobuilder, an external system, based on data read from several physical and logical files. The generated XML reflects order data and related information, and is written to the IFS (Integrated File System), possibly triggering other processes.

The program is heavily commented (in Norwegian) and features version control, maintenance notes, and a significant number of enhancements.

Below is an explanation, grouped by relevant sections:

---

## 1. Control Specifications

```rpg
H decedit('0.') datedit(*dmy-) option(*nodebugio)
H DftActgrp(*No) BndDir('CGIDEV2/CGIDEV2')
/copy hspecsbnd
```
- `H decedit('0.')` and `datedit(*dmy-)`: Specify decimal and date editing.
- `option(*nodebugio)`: Disables I/O debugging to improve performance.
- `DftActgrp(*No)`: The program runs in its own activation group (ILE concept).
- `BndDir('CGIDEV2/CGIDEV2')`: Binds the program to the `CGIDEV2` service program/binding directory for HTML/XML processing utilities.
- `/copy hspecsbnd`: Includes a copybook for binding specifications.

---

## 2. File Declarations

```rpg
ffbdol1    uf   e           k disk    rename(fbdopfr:fbdol1r)
...
```
- Each line declares a file object. For example, `fbdol1` is an update-capable (`uf`), externally described (`e`), keyed (`k`) database file. The `rename(from:to)` clause allows using an alias record format.
- Several files are opened, each representing different business entities (`customers`, `items`, `suppliers`, `projects`, etc.).
- Some files are commented out or conditionally included for versioning.

---

## 3. Standalone Variables / Data Structures

```rpg
d p_bnum          s             15
d rkunl1_kund     s    like(rkkund)
...
```
- Numerous variables are defined for intermediates, parameters, and data storage, often with `like(fieldname)` to match types/lengths from external file fields.
- Common business concepts are present, such as order numbers, customer numbers, product numbers, project details, and contact details.
- Special attention is given to string processing variables for XML output.

### Local Data Area (LDA)

```rpg
d                uds
d l_user                911    920
d l_filg                931    933
d l_firm                944    946  0
```
- The `uds` keyword defines data overlays, here extracting fields from the Local Data Area for the user, file, and firm.

---

## 4. Prototypes / Imports

```rpg
/copy prototypeb
/copy usec
...
DCL-PR CO402R EXTPGM('CO402R');
...
```
- Includes prototype/call interface definitions for external procedures and programs.
- `CO402R` is an external program called for certain lookups or logic (e.g. invoice type determination).

---

## 5. Main Logic Flow

The program logic is written in classic RPG cycle with subroutines (`begsr`/`endsr`), manually controlled file reads, and a mix of fixed/column and free-format code.

### Initialization

- Fetches company (`afirl1`) and configuration (`afpslrr`) data to determine XML paths, output paths, and flags for additional processing (like data queue trigger).
- Initializes state variables.

### Main Processing Loop

```rpg
// Iterate through 'fbdol1' records (order lines) for a given order number
Read and process each order line:
    - If first line: call xml_env & xml_header subroutines to start the XML (template, header section)
    - For each order line:
        - If eligible, call 'hent_gtin' (get GTIN number), then 'xml_line' to add a line section to the XML.
        - Mark the record as processed (fwcovf = 1 or 9)
After all lines:
    - If at least one line was processed, call 'xml_end' to finish the XML and write to IFS
```

**Error handling:** `goto avslutt` is used on missing critical data.

---

## 6. Subroutines

### `xml_env` (Initialize XML Template)

- Loads XML template from the IFS path.
- Uses CGIDEV2 routines (`GetHTMLIFS`, `ClrHtmlBuffer`) to set up working XML buffer.

### `xml_header` (Order Header Processing)

- Loads relevant data for the order, customer, and supplier.
- Scans and cleans up strings for XML encoding (using 'AP613R' subroutines).
- Populates order/project/contact variables.
- Sets up values for order/customer/supplier-related fields for the XML header.
- Uses CGIDEV2 routines like `WrtSection` and `UpdHTMLVar` to inject variables into the XML structure.

### `xml_line` (Line Item Processing)

- Attempts to resolve the supplier organization number (orgnr) for the item by chaining through multiple item/supplier files.
- Avoids writing lines if the item type is not eligible.
- Writes each order line’s data (article, GTIN, description, supplier ID, quantity, etc.) to the XML.

### `xml_end` (Finalize & Write XML)

- Writes the closing XML tags and summary fields.
- Constructs the output filename based on parameters and writes the XML using CGIDEV2's `WrtHtmlToStmf`.
- (Disabled code for writing to a data queue for "sniffer" processes).

### `hent_gtin` (Fetch GTIN Number)

- Attempts to locate a GTIN (Global Trade Item Number) for the given item across multiple tables and keys.
- Uses a special call ('VE714R') to retrieve GTIN details.
- Skips writing lines for specific “Trelastindustriens” (Lumber Industry) GTINs that should not be documented.

### `va_sjekk` (Special GTIN Check for VA Items)

- Specialized logic to find GTIN for VA (likely "water & sewage" category) products.

### `*inzsr` (Initialization Subroutine)

- Sets up key lists for all file accesses.
- Initializes main variables.
- Calls external program `CO402R` to determine supplier ID and a processing flag.

---

## 7. Key Lists

- Key fields (`klist`/`kfld`) are defined for each file access, for efficient `chain`/`reade` operations (direct record access using keys).

---

## 8. Use of CGIDEV2

- The program uses CGIDEV2 library routines to:
    - Build up HTML/XML templates ("sections")
    - Substitute variables inside templates
    - Write the final XML to the IFS.

---

## 9. Comments / Versioning

- Extensive comments in Norwegian maintain a change log, with version numbers and dates.
- Each enhancement or bugfix is tracked and annotated alongside code sections using conditional comments (e.g., `6.21`, `7.05`).
- The code employs both hard-coded and parameter-driven logic, making it relatively easy to adjust for future requirements.

---

## 10. String Cleaning

- Wherever strings are used in XML output, they're "scanned" and sanitized via calls to an external program (`AP613R`), likely to prevent invalid XML or encoding issues.

---

## 11. Program Entry

- Program accepts a parameter (`p_bnum`, order number).
- All processing is for the order number passed on invocation.

---

## 12. Error Handling

- Early exits with `goto avslutt` or `leavesr` are used when mandatory data is missing.

---

## 13. Selected Variable Naming & Norwegian Translations

- `kunde` = customer
- `vare` = product/item
- `prosjekt` = project
- `leverandør` = supplier
- `navn` = name
- `adresse` = address
- `kontaktperson` = contact person
- `telefon` = phone
- `ordrenummer` = order number

---

## 14. Summary

**Purpose**:  
The program produces an XML file reflecting order and line data, suitable for Cobuilder, using business data from several files and complex lookup logic. It’s highly parameterized and versioned, allowing for adaptation to changes in requirements or external system interfaces.

**Main Steps**:
1. Loads configuration and paths.
2. For each order line:
   - Loads/validates master data (customer, supplier, project).
   - Gathers and cleans string fields.
   - Constructs and writes XML sections for header and each line.
3. After all lines, finalizes XML and writes to IFS.

**External Integration**:  
- Uses `CGIDEV2` for XML templating/output.
- Calls out to other programs (`AP613R`, `VE714R`, `CO402R`) for string cleaning and business logic.

---

**Best for onboarding**:  
- Focus early on the sequence of subroutines and how the program fetches and validates data for each order and line.
- Understand the key usage of CGIDEV2 templates and the variable-substitution model.
- Pay attention to the extensive comments and version notes—they document business rules and changes over time. 

If you are new:  
- Start by tracing the main loop: from program entry, through template loading, header creation, line population, and final XML writing.
- Practice with the CGIDEV2 routines and understand how data from the DB files ends up in the XML file.  
- Use the commented logic to see where new requirements or logic branches were added—these offer critical business context.