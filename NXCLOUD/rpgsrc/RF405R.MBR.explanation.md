## Overview

This RPG program is named `RF405R`, and its main purpose is to "move a company" within the system ASOKON by copying records from a set of source files to corresponding output files, while updating the "firm" (company) number in each record.

The program works with a large series of files, copying data from `l1` files to `lu` files (e.g., from `raa1l1` to `raa1lu`), updating a specific "firm" field in each record as it goes.

Below is a structured explanation to help new developers understand the logic and layout.

---

## File Declarations

The file section declares a large number of logical files (with the `if e k disk` or `o e k disk` statements):

```rpg
fraa1l1    if   e           k disk    rename(raa1pfr:raa1l1r)
fraa1lu    o    e           k disk    rename(raa1pfr:raa1lur)
...
fra70l1    if   e           k disk    rename(ra70pfr:ra70l1r)
fra70lu    o    e           k disk    rename(ra70pfr:ra70lur)
```

- **Input Files (l1)**: Are read and records are extracted.
- **Output Files (lu)**: Are written with processed (updated) records.

`rename()` is used to map an external file name and record format to an internal file/record name.

---

## Definition Section

```rpg
d                uds
d l_user                911    920
d l_firm                944    946  0
d l_navn                951    980

d w_firm          s              3  0
```

- **l_user / l_firm / l_navn:** Likely data structure fields representing user, firm, and name information, possibly from a user space.
- **w_firm:** A 3-digit numeric working variable used to store the target firm (company) number to be assigned to records as they're copied.

---

## Main Processing Logic

### 1. Loop for Each Table

For each file (e.g., `raa1l1`, `raa2l1`, ...), the program follows a similar algorithm:
- **Set the file pointer** to the correct key for the source file.
- **Read** a record.
- **While** there are records (i.e., the EOF indicator, `*in90`, is off):
    - **Assign** the `w_firm` value to the record's firm field (e.g., `ra1fir = w_firm`).
    - **Write** the updated record to the output file.
    - **Read** the next record.
- **Repeat** for all tables listed.

Example for one file:

```rpg
c     raa1l1_key    setll     raa1l1                                 90
c     raa1l1_key    reade     raa1l1                                 90
c                   dow       *in90 = *off
c                   eval      ra1fir = w_firm
c                   write     raa1lur
c     raa1l1_key    reade     raa1l1                                 90
c                   enddo
```

- `setll` sets up for sequential keyed access.
- `reade` reads a record by key.
- Loop continues until EOF (`*in90 = *on`).
- For each record, the company is updated (`ra1fir`) and then written to the output file (`raa1lur`).

### 2. Repetition

This structure is repeated for many different file pairs, each with its own record structure and firm field name (such as `ra1fir`, `ra2fir`, etc.).

The comment lines indicate the business meaning of each file group (e.g., "Statuskoder", "Bilagskoder", "Betalingsmåter", etc.).

---

## Program End

At the end of the code:

```rpg
c     avslutt       tag
c                   eval      *inlr = *on
c                   return
```

- **`*inlr = *on`**: Turns on the LR (last record) indicator, which performs clean-up/closure of files.
- **`return`**: Exits the program.

---

## Subroutine: *inzsr (Initialization)

The initialization subroutine (`*inzsr`) is called at program start:

```rpg
c     *inzsr        begsr

c     *entry        plist
c                   parm                    w_firm
...
c                   endsr
```

- **Parameter List (`plist`)**
  - Expects the new firm number (`w_firm`) as an incoming parameter.

- **Key lists (`klist`)**
  - For each file, a keyed list (`klist`) is set up, typically with `l_firm` as the key field.
  - This is used in the main processing when using `setll` and `reade` operations, providing keyed access to each table by firm.

---

## Summary

**In essence, the program:**
- Accepts a target company/firm number as input.
- For each data table related to a company:
    - Reads all records from the source ("l1") file.
    - Updates each record's firm field to the new firm number.
    - Writes the record to the output ("lu") file.
- Handles a large variety of company-related tables (status codes, payment terms, departments, etc.).
- The structure is highly repetitive but systematic.

**This code is typical of "company move" or "data copy/clone" batch jobs in IBM i environments, where data for a new company is created by copying and adjusting data from templates or existing company data tables.**

---

## Onboarding Tips

- **Most logic is repeated per file; learn one, you know them all.**
- **Field naming follows a pattern:** the firm field in each record is similar to the file name (e.g., raa1l1 → ra1fir).
- **To support new tables**, add similar file and loop constructs as above.
- If you need to change the firm number for a new company, adjust the parameter passed in.
- **All business-specific details** (like which codes are in which files) are described in program comments.

---

## Glossary

- **setll**: Set lower limit for keyed access.
- **reade**: Read record equal (by key).
- **write**: Output a record.
- **klist/kfld**: Key list/field for keyed I/O.
- **LR indicator (`*inlr`)**: Signals program end, handling file closures.
- **`*inzsr`**: Initialization subroutine, runs before main cycle.

---

This program is a classic data migration/conversion utility for multi-company ERP systems on IBM i, written in traditional fixed-format RPG.