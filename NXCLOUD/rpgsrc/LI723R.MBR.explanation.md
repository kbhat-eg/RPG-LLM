# Explanation of the ILE RPG Program `LI723R`
---

This documentation explains the provided RPG (Report Program Generator) source, focusing on its structure, logic, and purpose. The comments and variable names indicate it's a program used for the **automatic import of EDI invoices** ("Automatisk innlesing av fakturaer") for a system named ASLAGR, with customizations for a client, "Gipling".

## 1. **Header and Documentation**
The header documents the program’s history, versioning, and modifications. Examples:
- *221118 bsa* – Tweaks to rounding.
- *271118 bsa* – Stops if an order number exists, does not check if invoiced.
- Version 8.01 expands the message number from 6 to 8 digits.

## 2. **File Declarations**
- **Files Used**:
  - `ledilu`/`ledil5`: EDI message files; renamed to use alternate record formats and prefixed fields.
  - `fohel1`, `lohel1`: Order and purchase order header files; again using alternate record formats for structure.
- **Purpose**: These files provide data about incoming EDI messages, orders, and purchase orders, and are updated based on processing logic.

## 3. **Data Structures**
- **LDA Area**: Picks up user/firm info from the job’s Local Data Area.
- **Invoice header (`d_fakh1`)**: Stores parsed invoice header fields.
- **Additions/deductions (`d_fakh2`)**: For lines with adjustments.
- **Free text (`d_fakh3`)**: Text lines related to invoice headers.
- **Parts info (`d_fakh5`), transport info (`d_fakh6`)**: Store more details found in invoice EDI.
- **Invoice line (`d_fakl`)**: Describes a single line on an invoice, holding part and pricing details, along with adjustment lines.
- **Invoice totals (`d_fakt`)**: Used for sum totals, taxes, and adjustments from the invoice.
- **Feedback structure (`dspfbk`)**: Used for display file feedback (not heavily used in this batch program).

## 4. **Variable Definitions**
Variables are declared to hold:
- File keys (for chained reads).
- Flags for controlling logic, such as `b_upda` (update), `b_katg`, `b_kobl`, `b_edim` (EDI in process), etc.
- Working storage for current firm, dates, times, and other calculation fields.
- Several constants for letter casing, digits, etc., used by the program logic.

## 5. **Main Processing Loop**
### a. **Initialization**
- The program skips “debug IO” (`h option(*nodebugio)`) and uses a date edit format.
- Reads messages from `ledil5` file, specifically those with type `FAKT` (invoice) and blank status.

### b. **Loop through Messages**
- Repeatedly reads EDI message lines from `ledil5r` (the renamed record format).
- Changes firm triggers a subroutine (`sjk_mnum`) to handle any EDI in progress and jumps to the end of the program.
- Manual test lines (guarded with `9.xx` or commented out) can skip certain messages (ex: for message number 676382).

### c. **EDI Message Handling**
- For each message:
  - **New EDI transaction?**: If `s_mnum` (saved message number) differs from the current, previous EDI is processed and a new one is started.
  - **Error Conditions**: If the line is a header (line number `100001`) but has error status or the order flag is on, disables further EDI processing for this message.
  - **Save Invoice Header**: For header record (line 100001), saves invoice header details and order numbers.
  - **Invoice Totals**: For line 900001, stores invoice totals. If it’s a credit note (type 381), ensures the amount is negative.

### d. **Subroutines for Processing**
#### `sjk_mnum` – Check Automatic Update Rules
- Controls whether the EDI message should be updated automatically.
- Calls `best_match` to try matching the invoice to the correct purchase order suffix by comparing total amounts.
- Attempts to find orders and set flags if found; disables updating if a corresponding order is found (prevents duplicate invoicing).

#### `best_match` – Match Order by Amount
- Tries to match a purchase order with the same number but different suffix by amount, updating the EDI message with a new suffix if matched.

#### `upd_suff` – Update Suffix on EDI Message
- Sets the new suffix (`xisuff = s_suff`) for the matching EDI message in file and updates timestamp/user.

#### `set_status` – Set EDI Message Status (Deactivated)
- Logic present, but guarded by `if 1=2`, so never executed. Meant to update status of EDI message in the database.

#### `upd_mnum` – Automatic Update of EDI Message
- Calls another program (`LI724R`) with parameters to process/update the invoice message.
- Resets totals afterward.

## 6. **Initialization Subroutine (`*inzsr`)**
- Used for initial setup: reading parameters, setting up file keys, getting current time/date, and populating firm variable.

---

## **Summary of Program Flow**
1. For each EDI invoice message:
   - Reads and collates header, totals, and relevant lines.
   - When firm or message number changes, processes previous EDI "in memory".
   - Checks if invoice already exists, or if there are errors/duplicate orders.
   - Matches by purchase order totals and (if necessary) updates the EDI’s suffix to correspond to the correct order.
   - If successfully validated, calls `LI724R` to process the message.
   - Ends by marking program as completed.

---

## **Typical Use & Onboarding Notes**
- **Data Flow**: This is a batch, file-driven process. Each message is an EDI invoice to be auto-processed, unless exceptions (error codes, duplicate orders, mismatched totals) interfere.
- **Database Design**: Knowledge of the underlying files (`ledilu`, `ledil5`, `fohel1`, `lohel1`) is crucial for extending or debugging.
- **Error Handling**: Most “blocking” conditions are handled by turning off flags to stop updates, rather than explicit exceptions.
- **Customization**: Logic is client-specific (e.g., comments about Giro, handling of Norwegian letters).
- **Testing & Maintenance**: Test lines are present in the code but commented out or conditional.

---

## **Key Takeaways for New Developers**
- Focus on how EDI invoice messages are grouped, validated, and updated.
- Understand the use of working storage and record format renaming for flexible file handling.
- Pay special attention to how the program prevents double-processing and ensures correct matching to orders by amount and suffix.
- Business rules are intertwined with technical logic—read comments for context on why certain matches or skips occur.

---

**Tip**: While some subroutines (like status update) are disabled, this structure lets you easily enable or expand the logic if new requirements arise. This is a classic example of Norwegian/Scandinavian RPG legacy code in EDI-processing environments.