# Explanation of the RPG Source Code (JV165R)

## Overview

This RPG program, **JV165R**, is part of a system for handling product/warehouse information and price calculation logic related to sales or procurement orders. The primary goal is to enable the entry or calculation of prices and conditions for a product (vare) as selected from an order. The program is structured in classic ILE RPG, using subroutines for various units of work, and performs validation, calculations, and calls to other programs or stored procedures to handle price data.

---

## Key Sections and Workflow

### 1. File and Display Declarations

- `fjvarl1` and `fjlevl1`: Logical file declarations for products and suppliers, respectively.
- `fjv165d`: Workstation file for screen/display file processing.

### 2. Parameters and Variables

#### Entry Parameters

These are the variables received by the program, defining the context (company, item, price group, units, prices, etc.), e.g.:
- `p_firm`, `p_vare`, `p_prgr` ... (`d`-specs).
- These are populated at program entry via the `*entry plist`.

#### Working Variables

Local variables used in calculations and to temporarily store information:
- `w_*` variables for working copies of input.
- `s_*` variables for saving previous values to check if they've changed.

#### Key Variables

For chaining (reading by key) into the files:
- `jvarl1_vare`, `jlevl1_ldor`

---

### 3. Main Program Logic

#### Item Lookup

- Loads product info using a `CHAIN` to `jvarl1` by item number.
- If product not found, the program exits (`goto avslutt`).

#### User Display

- Calls the `xc1win` subroutine to handle screen display and possible user edits.

#### Returning Data

- If the user did not cancel, copies the calculated/selected outputs (`c1*` fields) back to the main parameter variables (`p_*`), which are output to the caller.
- Handles date formatting and ends execution by setting `*INLR = *ON`.

---

### 4. Subroutines

#### `xc1win`: User Screen Subroutine

- **Initialization**: Copies input parameters to working/display fields (`c1*`).
- **Old Value Save**: Remembers important values to detect changes.
- **Display**: Presents the screen via `EXFMT`.
- **Function Key Handling**:
  - F3: Cancel/exit (`*INKC`/`*INKL`)
  - F13: Choose price-setting supplier (calls `prisgiver`)
  - F14: Choose condition (calls `betingelse`)
- **Validation**: Ensures at least one valid price is set.
- **Change Detection**: If prices, factors, etc., change, recalculates using `sjekk_pasl` (check for special markup logic) and `kalk_priser` (recalculate prices), and loops back to display.

#### `prisgiver`: Select Price-Setting Supplier

- Calls external program `JX500R` to pick a supplier and updates fields if selection changed.
- Then retrieves new base data and recalculates prices.

#### `hent_grunnlag`: Get Base Information

- Calls `JV751R` to fetch detailed item and price info, updating many fields by reference.
- Handles date logic and sets output variables accordingly.

#### `betingelse`: Choose Condition

- Calls `JP505R` to pick/set a condition for this product/supply.
- Updates relevant price variables and recalculates prices as needed.

#### `kalk_priser`: Price and Factor Calculation

- Based on current `c1enhe` (unit), determines conversion factors.
- Calculates net price (or purchase price) and relevant factors:
  - If net price present, copies it to input price; otherwise, uses a calculated value.
- Updates cost price if anything changed.
- If any base for sale price changed, recalculates sale price based on various rules.
- Updates shadow (s_*) variables for further change detection.

#### `sjekk_pasl`: Special Markup Check

- Uses embedded SQL to see if, for the current item and condition, a special markup ("påslag") applies that requires the sale price to be set equal to the NOBB price (a reference price standard).
- Sets flags used in further calculation logic.

#### `*inzsr`: Initialization Subroutine

- Standard RPG initialization structure.
- Loads entry parameters.
- Resets `b_avik` flag.

---

### 5. External Program Calls

The program calls several external RPG programs for specialized processing:
- **JX500R**: For selecting a price-setting supplier.
- **JV751R**: For retrieving base price/product information.
- **JP505R**: For editing/selecting item conditions.

---

### 6. Embedded SQL

The program uses embedded SQL for condition lookup, e.g., in `sjekk_pasl` to determine if the item's sale price should match the NOBB price under specific conditions.

---

## Notable Business Rules

- **Unit Conversion**: Prices and quantities are carefully recalculated for different units.
- **Condition Handling**: The program supports flexible selection of sales/buying conditions, which affect the resulting prices.
- **Special Markups**: Certain item and condition combinations (utilizing NOBB logic) override regular price calculation.
- **User Interaction**: The screen logic enforces that required pricing information is entered/selected before exiting.

---

## Summary

This program acts as an interactive utility for entering, validating, and calculating product prices within the context of an order, handling multiple units, special markup rules, and allowing users to pick suppliers and conditions. It coordinates data between user edits, database records, and business logic via a combination of RPG data structures, subroutines, and embedded SQL/program calls.

For onboarding:
- Become familiar with the domain (product pricing, NOBB system, etc.).
- Understand the flow: parameter in, item lookup, display/edit cycle, conditional logic, parameter out.
- External program specs (JX500R, JV751R, JP505R) will be crucial for in-depth troubleshooting.
- Main modifications likely involve business rules in subroutines like `kalk_priser` and `sjekk_pasl`. 

A strong knowledge of RPG’s screen handling, parameter passing, and file/database access is assumed.