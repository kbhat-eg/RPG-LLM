# IBM ILE RPG Program FW725R - Overview & Explanation

This RPG program (`FW725R`) is part of the system `ASOFAK`. Its function is to ingest (import) new product prices from a spreadsheet (regneark) and update a supplier's item register. The program was initially written for T.M. Bergersen and has been updated over the years for new requirements, such as extending the price group field and tracking information.

## 1. File Declarations (FLDs)
```rpg
fflvwpf    if   e           k disk
ffenkl1    if   e           k disk    rename(fenkpfr:fenkl1r)
fvvarl1    if   e           k disk    rename(vvarpfr:vvarl1r)
fvvprl1    if   e           k disk    rename(vvprpfr:vvprl1r)
fvvenl2    if   e           k disk    rename(vvenpfr:vvenl2r)
fvvprlu    uf a e           k disk    rename(vvprpfr:vvprlur)
```
**Purpose:** These lines define database files the program will use.  
- `flvwpf` is the input file (likely the spreadsheet import).
- The other files are product, price, and unit conversion master files used for lookups, updates, and inserts.
- Rename clauses ensure internal record formats match program expectations.

## 2. Data Structure for Input
```rpg
d                 ds
d d_inpu                       256
d  d_evar                       15    overlay(d_inpu:1)
... (other fields - overlays for parsing input)
```
**Purpose:** Defines a 256-byte area (`d_inpu`) with several overlayed fields for extracting specific pieces of data (product number, texts, prices, units, etc.) from each input record.

## 3. Key Variables, Working Variables, and Constants
- **Key Variables:** Used to hold key values for file operations (lookups, chains).
- **Working Variables:** Temporaries for holding calculation results, units, prices, etc.
- **Constants:** For character translations and formatting.

## 4. Main Program Loop
```rpg
c                   read      flvwpf
c                   dow       not %eof
  ... (main logic)
c                   read      flvwpf
c                   enddo
```
- Reads each record from the input file.
- Clears and fills the data structure from the record (`exsr utled_ds`).
- If parsing successful and product number is numeric, finds the product (`chain` to vvarl1).
- If product found, calls subroutine to update prices (`exsr oppd_pris`).
- Loops for all input records.

## 5. Price Update Subroutine (`oppd_pris`)
```rpg
c     oppd_pris     begsr
  ... (calls finn_enhe, processes up to 3 price units)
c                   endsr
```
- First, calls `finn_enhe` to determine possible sales units for the product.
- For each of up to three possible units (enhet-1, -2, -3):
  - If all necessary data is present (non-blank unit, non-zero prices), looks up or adds/updates a price record in `vvprlu`.
  - Updates relevant fields: prices, timestamps, user, etc.

## 6. Find Sale Units Subroutine (`finn_enhe`)
```rpg
c     finn_enhe     begsr
  ... (finds up to 3 sales units for the product)
  ... (calculates conversion rates/prices for each unit)
c                   endsr
```
- Starts by clearing/enumerating unit (enhet) and conversion variables.
- For the current product, uses the unit conversion file to fetch up to three associated sales units.
- For each unit, determines prices (sale, cost, purchase) by applying conversion rates.

## 7. Input Line Parsing Subroutine (`utled_ds`)
```rpg
c     utled_ds      begsr
  ... (parses the semi-colon separated spreadsheet line into fields)
  ... (extracts and formats numeric fields, replaces blanks with zeros, handles decimals)
c                   endsr
```
- Breaks down the raw input string (assumed semi-colon delimited, as from Excel exports).
- Sequentially extracts product number, type, unit, text fields, and relevant price fields.
- Handles formatting for numeric values, ensuring proper leading zeros, decimal places, and replacing blanks.

## 8. Initialization Subroutine (`*inzsr`)
```rpg
c     *inzsr        begsr
  ... (defines key lists, initial values, date conversion)
c                   endsr
```
- Sets up key definitions for file operations.
- Initializes company and date variables.

## 9. Key Lists (`klist`)
Defined for multiple lookups (unit conversion, product, sale unit, price records), to standardize file accesses and improve code readability.

---

# Key Concepts and Flow

1. **Input is a Spreadsheet Export:**  
   Each row is parsed and mapped into working storage. Data is delimited and handled field by field.

2. **Product Validation:**  
   Numeric check on the product number ensures only valid lines are processed.

3. **Reference Lookups:**  
   Product details and possible sales units are fetched from reference (master) files.

4. **Unit Conversion:**  
   Finds up to 3 sales units per product and calculates prices for each based on conversion factors.

5. **Price Record Update/Insert:**  
   For each unit with valid data, the relevant price record is updated if it exists or inserted if not, along with tracking information.

6. **Robust Formatting:**  
   Handles various input quirks (blanks, missing decimals, leading spaces) to ensure all price data is correctly formatted for numeric fields.

# Special Features

- **Field Overlays:** Efficient mapping of input data for both character and numeric subfields.
- **Data Cleansing:** Ensures all numeric fields are valid, non-blank, and correctly formatted, substituting zeros where needed.
- **Extensible Design:** Support for 3 units per product, price group expansion, and tracking (by user and timestamp).
- **Separation of Concerns:** Uses subroutines for parsing, unit calculation, and price updating.

# For New Developers

- **Start at the Main Loop:** Understand how each input line is processed.
- **Review Data Structure (`d_inpu`):** How input is mapped into fields.
- **Check Subroutines:** How the program breaks complex steps into subroutines for clarity.
- **File Interactions:** Most logic centers around lookups, updates, and inserts into key database files.
- **Parameterization:** Pay attention to fields like `p_firm` (company), as these may come from outside the program.

---

> **In summary:** This program automates importing and updating item prices from an external spreadsheet, validating and formatting data as needed, and integrating the results into several master tables, keeping company and change tracking in mind. If you are onboarding, start by understanding the data flow: input record → parse → validate → fetch product → fetch units → calculate prices → write/update price records. Each step is encapsulated in a well-defined subroutine for maintainability.