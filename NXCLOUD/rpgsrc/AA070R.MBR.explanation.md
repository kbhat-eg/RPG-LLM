# RPG Program: ASPGPL / AA070R - Maintenance of File Copy Header Register

## Overview

This ILE RPG program manages the maintenance of a file copy "header" register in the ASPGPL system. Its main function is to present, add, change, show, copy, or delete records that control file copying operations. It provides a subfile-driven user interface with various screens for interaction.

The program is built using "cycle" RPG with subroutines, indicators, and traditional DDS-based screens and subfiles.

---

## Structure

### 1. **File Declarations**

```rpg
facphl1    if   e           k disk    rename(acphpfr:acphl1r)
facphl2    if   e           k disk    rename(acphpfr:acphl2r)
facphlr    if   e           k disk    rename(acphpfr:acphlrr)
facphlu    uf a e           k disk    rename(acphpfr:acphlur)
facpllr    if   e           k disk    rename(acplpfr:acpllrr)
facpllu    uf a e           k disk    rename(acplpfr:acpllur)
faa070d    cf   e             workstn sfile(b1sfl:w_srrn)
```

- **acphl1, acphl2, acphlr, acphlu**: Files related to the "header" (hode) of the file copy register.
- **acpllr, acpllu**: Files related to the "lines" (linje) of the file copy register.
- **aa070d**: Workstation display file using a subfile (`b1sfl`) for presenting lists.

### 2. **Data Structures and Variables**

- **Arrays**: `a_meld` holds messages for creation, change, display, etc.
- **User Data Area**: Maps LDA fields (e.g., `l_user`, `l_firm`).
- **Key Variables**: For each file, variables like `acphl1_hfgr`, `acphl1_hfir` represent parts of the key.
- **Subfile Navigation Variables**: `w_srrn`, `w_spge`, etc., manage subfile paging and positions.
- **Flag Variables**: `w_forn`, `w_anul`, `w_feil` indicate statuses.
- **Constants**: `c_sfil = 11` for subfile page size.

### 3. **Indicators**

Used throughout to control subfile display, messages, field protection, function key logic, and file operations.

---

## Core Logic

### Main Loop & Display Handling

The program follows the classic RPG C-spec `TAG/GOTO` structure, looping on subfile display and responding to user inputs.

#### **Main tags:**

- **b2taga**: Show command screen (`b2cmd`).
- **b2tagb**: Show subfile screen.
- **avslutt**: End program.

#### **User Inputs Processed:**

- F3 (Cancel), F12 (Return): Exit program.
- F5: Refresh subfile.
- F10: Create new subfile entry.
- Home/key: Move cursor.
- Otherwise: Depending on the selection (`b2valg`), process via `control` subroutine.

---

## Subroutines

### **forny** - Refresh Subfile

- Positions the file pointer depending on the sequence (`w_seqe`).
- Calls `clr_subfile` to clear subfile area and `crt_subfile` to reload data.

---

### **posisjoner** - Position in Subfile

- Positions the list (using setll) for filgruppe or firma depending on user input.
- Clears and repopulates subfile after positioning.
- Clears the fields used for positioning.

---

### **control** - Subfile Control Handler

Handles all operations based on `b2valg`:
- **1**: Create new (`xc1bld`)
- **2**: Change (`xc2bld`)
- **3**: Copy (`xk1win`)
- **4**: Delete (`xd1win`)
- **5**: Show (`xc2bld`)
- **7**: Maintain lines (calls `AA071R`)

Performs validation of keys and sets error indicators/messages.

---

### **subfile** - Row Processing in Subfile

Iterates over subfile records, handling per-row options:
- **2**: Change record
- **3**: Copy
- **4**: Delete
- **5**: Show
- **7**: Maintain lines (calls `AA071R`)

Each operation clears out chosen row's option after processing.

---

### **xc1bld**, **xc1msg**, **xc2bld** - Maintenance Screens

- `xc1bld`: Handles the "create new" entry dialog, checks for existing records, shows messages if exists.
- `xc1msg`: Displays a message if the row already exists and handles user cancellation.
- `xc2bld`: Used for create/change/show, updates or writes the header record, manages field protection, sets messages and error states, and writes audit info (`acheus`, `acheda`, `acheti`).

---

### **xd1win** - Delete Record

- Presents a delete confirmation dialog.
- Deletes the header and all associated lines.

---

### **xk1win** - Copy Record

- Copies a header and all associated lines to a new key.
- Checks if the destination exists; if so, shows an error.
- Copes underlying file line records to the new header.

---

### **clr_subfile**, **crt_subfile**, **dsp_subfile**

- `clr_subfile`: Clears the subfile and resets counters.
- `crt_subfile`: Reads and fills the subfile page by page.
- `dsp_subfile`: Displays the subfile (handles roll, page up/down, and field protection indicators).

---

### **Key Lists Initialization (\*inzsr)**

Sets up key lists used with I/O operations:
- For each logical file and operation, a `klist` is defined with its key fields.
- The subfile is initially loaded by positioning at the start and calling the creation subroutine.

---

## Subfile Displays (DDS Screens)

- **b1sfl**: Rows of the subfile (list of header records).
- **b2ctl**, **b2cmd**: Subfile control and command areas.
- **c1bld**, **c2bld**, **d1win**, **k1win**: Screens for create, change/show, delete, and copy operations (respectively).

---

## Indicators & Messaging

- **Indicators 10-99**: Various purposes; e.g. 31–79 for field errors/messages, 90–99 for file errors.
- **a_meld array**: Holds screen messages for "new", "change", "view" actions, mapped in code to display screens.

---

## Business Rules & Flow

- Users see a subfile list with options to create, update, show, copy, or delete file copy headers.
- Each operation validates data, updates the physical/logical files accordingly, and may cascade (e.g., delete lines with header).
- The program supports standard function keys (cancel, return, refresh, etc.).
- Modular: Maintenance of the lines of a file-copy header is handled by another program (`AA071R`).

---

## Summary

- **Subfile-driven RPG program** for maintaining a register of file copy "headers" (file copy templates/info).
- Highly interactive with keyboard-driven navigation and options.
- Maintains referential integrity (deletes/copies lines with headers) and provides audit info.
- Follows traditional pre-ILE RPG program design, using subroutines, indicators, and explicit I/O logic.

Use this as a foundation for onboarding, debugging, or extending functionality, particularly if modernizing to free-format or moving to a more event-driven model!