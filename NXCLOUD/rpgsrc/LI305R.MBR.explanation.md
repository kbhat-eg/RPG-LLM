# RPG Program LI305R - Picking of Single Colli for Approval

This ILE RPG program is designed to facilitate the picking of individual colli (parcels/packages) linked to EDI packing slips, and updating their status for further processing, such as approval, consolidation, or inventory updates.

The code contains several distinct operational sections, with detailed comments and versioned modifications reflecting business requirements over time.

## 1. **File Declarations**

The program uses a number of physical and logical files (`f` specs). Most files represent application-specific objects such as orders, packing slips, picking lists, inventory, and working files. Files are often renamed for clarity within the program (`rename` keyword) and opened in input (`if`), update (`uf`), or combined modes. A display file (workstation) is used for user interaction.

## 2. **Variable and Array Declarations**

- **Arrays**: Used for holding up to 20 orders or parcels being processed in the current session:
  - `bnr`, `bsu`, `oty`, `ssc`: Holds order numbers, suffixes, order types, and SSCC codes.
- **Parameter variables**: Used for input parameters (e.g. type, order number, SSCC, etc) to drive the processing.
- **Key field variables**: Used to store values for file access keys.
- **Miscellaneous variables**: Holding flags, counters, status, working values, and temporary data.
- **Data Structures**: For overlaying and formatting record data, especially for passing to subroutines or external programs.

## 3. **Main Logic Flow**

### **Program Initialization (`*INZSR`)**

- Entry parameters are assigned to local variables.
- Key lists are populated for all files that will be accessed by key.
- `rlevl1` is checked: If a certain "resting" condition is set for the supplier, a flag is activated.
- Initial file lookups are performed to prepare for processing.

### **A1: Picking EDI Packing Slips**

#### **1. Find Valid Orders/Parcels**

- The program loops through all records in `lbhoi2` matching the provided SSCC (`p_paid`) and checks if:
  - Order number is not zero.
  - Arrival year matches.
  - Status is '50' (active?).
- If found, additional validity checks are performed by chaining into `lohel1` and looking up order type in `votyl1`.
- Only orders with the proper "next order type" and not already looked up are added to the selection arrays.

#### **2. Screen Output / User Interaction**

- Data is prepared for user display and selection.
- If no valid order was found, indicator 31 is set and the user is returned for further input.
- User can exit (`F3`), inquire (`F4`), or continue the process.

#### **3. User Authorization & Setting Locks**

- User rights are checked via `lusrl1`.
- The packing slip header (`lphoiur`) is locked (status set to '30', user and timestamp updated) to avoid double picking.

#### **4. Picking Processing Loop**

- For each valid order in the arrays:
  - Call an external program (`LO709R`) to update the order as "in processing".
  - The order header is locked.
  - The subroutine `scan_li210` (see below) is called to generate the picking list for the scanned parcel(s).
  - Another external program (`LI301R`) is called for printing or further processing.
  - The order is unlocked (reset lock status).

#### **5. Status Update Loop**

- For each order:
  - Set the order's linking and packing slip/colli records' statuses to '90' (received/finished) in header and line files.
  - Sub-entries are updated accordingly.
  - Picking lines are locked to prevent duplicate picking.

#### **6. Finalize Packing Slip Status**

- Checks whether the entire packing slip is picked/scanned, i.e., all colli have status '90'.
- If so, the packing slip overall status is set to '90'.
- Orders are consolidated (`LI306R`), but only if *all* colli are scanned.

#### **7. Inventory Resting Handling**

- If consolidation is complete, loop to transfer any resting lines (unpicked lines, suffiks 0) and update inventory accordingly, possibly by deleting/resting lines from working registers and updating warehouse balance (`oppdat_lager` subroutine).

### **Exit Program (Tag `xslutt`)**

- Ends the program and releases resources.

---

## 4. **Subroutines**

### **scan_li210 (Picking List Generation)**

- For the selected order/collo, the subroutine:
  - Reads all scanned picking lines (from `lbliir`) matching the current SSCC.
  - Locates the corresponding order line in `lodtl1`.
  - Handles "resting" (partial picking) situations by possibly writing work entries (`lbreiur`).
  - Writes the picking line into the picking list file (`lplllur`).
  - Takes care to also pick any associated comment/description lines ("tekstlinjer") by scanning continuous lines above/below for lines marked as 'TX' and writing them as 'picked'.
  - Writes the picking list header (`lplolur`) after all lines are picked.

### **oppdat_lager (Inventory Update)**

- Prepares a transfer data structure with all relevant inventory movement information.
- Calls another external program (`VL001R`) to actually update the inventory, unless the item is flagged as already in "LVR" (likely a legacy or special area).

---

## 5. **Key List Definitions**

- Multiple key lists are defined for all file accesses (reading, chaining, updating, deleting).
- The keys combine fields such as company, order numbers, suffixes, lines, product codes, etc.
- This enables fast and precise file operations.

---

## 6. **Version Notes (7.00, 7.01, ... 7.06)**

- The code contains a running changelog showing modifications for business rules (e.g., only consolidate if all colli are scanned, handling of "resting," etc.).
- It also shows the evolution of handling for status codes, text lines, partial picking, and inventory movements.

---

## 7. **Business Process Covered**

The program is a typical part of an EDI or warehouse management solution, covering:

1. **Verification of incoming EDI orders and packing slips.**
2. **User-driven selection and picking of packages.**
3. **Automatic and manual status updates, with full traceability (timestamps, users, status codes).**
4. **Consolidation and finalization of orders only when all items/colli are processed.**
5. **Subtle handling of "resting" (unpicked or delayed lines).**
6. **Full inventory integration, ensuring physical stock and system stock match.**

---

## 8. **Important RPG Techniques in This Program**

- Extensive use of arrays for session data.
- Overlay data structures for record formatting and transfer.
- Use of user data structure (UDS) for job/user/session info.
- File-level and field-level renaming for clarity.
- Modularization with external program calls for key business logic (e.g., inventory update, consolidation).
- File operations using `setll`, `reade`, `chain`, `update`, and `delete`.
- Conditional logic for enforcing business rules at every step.
- Subroutine factoring for code reuse (picking list, inventory update).

---

## 9. **Onboarding Notes**

- **Business Knowledge Required:** To fully maintain/extend this code, understanding the specific business terms (e.g., SSCC, suffiks, pakkseddel, "resting," etc.) is crucial.
- **RPG Language Proficiency:** You should be comfortable with traditional RPG III/IV syntax and ILE conventions, as well as external program calling conventions.
- **File Structures:** Ensure you have access and understanding of the file layouts referenced (physical/logical files).
- **Integration Points:** Be aware of the programs called externally and their interface requirements (`LO709R`, `LI301R`, `LI306R`, `VL001R`).
- **Version Control:** Each section with a version marker (e.g., 7.06) correlates to evolving business requirements. Always check the latest version for relevant changes.

---

### **Summary**

This RPG program is at the heart of the colli picking processâ€”ensuring EDI orders are picked, tracked, and updated in the system, with strong controls to prevent errors and guarantee accurate inventory and process flow. Key processing is performed in loops over candidate orders, with heavy file interaction, user intervention points, and carefully managed status changes. 

If you are onboarding, first get familiar with the files and their relationships, then walk through the logic flow for a test case. This approach will facilitate troubleshooting and further development.