# Explanation of the RPG Program `EK711R` - Customer Bonus Calculation and Update

## Overview

This RPG (Report Program Generator) program, named `EK711R`, is designed for IBM System i (AS/400) platform and is responsible for calculating, updating, and managing customer bonus data across several levels and types for a given company, customer, and period. It operates on several database files containing bonus definitions, customer data, sales statistics, etc.

The comments and code are primarily in Norwegian. The main business goals are:

- Calculate bonus basis and bonuses at multiple levels (e.g., customer, discount category, sales group, individual items).
- Update the relevant records in bonus and sales statistics files.
- Support extended logic based on bonus types, period, and category constraints.
- Be extensible for future bonus handling rules and logic.

---

## Main Sections of the Program

### File Declarations

The program uses many database (DISK) files with `IF`, `UF` (Input, Update), and `Rename` or `Prefix` clauses to reference specific record formats or avoid name clashes. Notable files include:

- `ekbost` (Customer bonus base)
- `ekbest` (Customer bonus elements)
- `ekbtst` (Customer bonus type summary)
- `ekbsst` (Bonus type steps/thresholds)
- `rkunpfr` (Customer master)
- `sstapfr` (Sales statistics)
- `vvarpfr` / `vvaspfr` (Item master, deleted items)
- `vbotpfr` (Bonus type master)

### Parameter Definitions

Defines parameters for input to the program (via *ENTRY plist):

- `p_firm`, `p_bkun`, `p_paar` (Company, Bonus customer, Year)
- `p_tbot`, `p_peri`, `p_fper` (Bonus type, To-period, From-period)
- `p_inlr` (End-of-job flag)

### Arrays

- `a_boty` array (99 elements): Holds bonus types found for a sales record (prevents double-counting).

### Key Data Area

- Multiple key lists (`KLIST`) for reading/updating records in various files based on composite keys.

### Variables for Keys and Values

Defines numerous variables for working with keys and updating fields in files. These are mapped using `LIKE()` to the relevant record fields.

---

## Mainline Logic

The main logic flow (not inside a subroutine) follows these major steps:

1. **Parameter Handling**: Moves the input parameters into working variables.
2. **Customer Register Read**: Loads customer information, possibly to use category/group info in bonus calculation.
3. **Zeroing Bonus Basis**: Resets bonus basis fields in bonus registers.
   - Loops over all relevant bonus base and element entries for the customer, setting amounts and dates/times to zero.
   - Flags if any bonus is assigned at customer/category/project level, which means "read all sales statistics."
4. **Zeroing Bonus Type Level**: Similar zeroing for summary bonus type entries (`ekbtiu`).
5. **Calculate Bonus Basis**: Calls subroutine `bonusgrunnlag` to sum up the sales statistics for the year and group by level and bonus type.
6. **Calculate Bonuses**: Calls subroutine `bonus` to calculate actual bonuses per element and update the files.
7. **Update Sales Stat with Bonus**: (Currently disabled by `if 1 = 2`) - would call `statistikk` subroutine to post bonus amounts onto sales statistics file.

---

## Subroutine Logic

### `bonusgrunnlag` - Calculate and Store Bonus Basis

Loops over sales statistics for the selected customer/year, applies logic to determine which bonus levels/types apply for each sale (using `bonusnivå` subroutine), and updates the relevant bonus basis records.

- Uses nested criteria to check if a sale matches a defined bonus level for this customer (there are 160+ possible bonus level combinations, see large comment block).
- Sums up net sales for the matching level, updates the corresponding record.

### `bonus` - Bonus Calculation per Element

For every bonus definition for the customer (base table), loops over related bonus element records (with thresholds and rates), and:

- For each, calculates the applicable bonus based on thresholds, bonus rate, and whether bonus should be calculated at total or element level.
- Sets bonus amount, updates corresponding entries in files.
- At the end, also updates summary bonus type records.

### `statistikk` - (Disabled) Update Sales Statistics with Calculated Bonus

If enabled, would insert the calculated share of bonus into the sales statistics for each sale.

### `bonusnivå` - Determine Applicable Bonus Level (Heavily Repeated Code)

A complex logic block, matching a sales record against 160+ possible bonus level combinations (mixes of discount category/rabattkategori, customer, customer project, groupings, item, unit, delivery type, etc.), and flags which bonus type(s) apply for a given sale.

- Uses nested IFs and repeated SETLL/READE loops to walk through all possible matching records.
- Avoids double-counting by checking if a bonus type is already in the `a_boty` array.

### Other Subroutines

#### `sr_kbonus` (6.14): Calculate Bonus Based on Totals

Handles calculation when the bonus type is marked to be calculated based on totals (not per element).

- Applies bonus rates/thresholds to the total basis for the bonus type.
- Updates summary bonus records.

#### `sr_breduk` (6.14): Reduce Bonus by a Percentage

Handles cases where the bonus amount should be reduced (for shipping, adjustments, etc).

#### `sr_belem` (6.14): Sum Bonus per Element to Bonus Type Register

Sums up bonus across all elements for a given bonus type, and updates the summary record.

---

## Key Concepts and Patterns

- **SETLL/READE Pattern**: Standard way in RPG/400 to loop over records with a given key.
- **Threshold Processing**: Most bonus element logic compares the sales against defined from/to thresholds to decide which rate to apply.
- **Avoiding Double Counting**: The array `a_boty` is used to track which bonus types have already been handled for a sales line in a given iteration.
- **Flexible Bonus Logic**: The extensive "Nivårekkefølge" (level sequence) logic supports a vast number of ways to set up bonus calculation by customer, category, project, group, item, unit, delivery type, etc.

---

## Table/Field Naming Conventions

- All table and field names are mapped via `RENAME` and `LIKE()` so the code can use local variable names that match the business logic.
- Examples: `ekboi1_*` for bonus base keys, `ekbei2_*` for bonus element keys, etc.
- `sf*` prefixes for sales statistics fields/keys.

---

## What to Focus on When Onboarding

- **Business Rules**:
  - How are bonus levels set up in your system?
  - Which levels and combinations does your company actually use?
- **Performance**:
  - The "bonusnivå" subroutine is highly repetitive and complex; any change to how bonus levels are matched will require changes at many locations.
- **Extensibility**:
  - Additional bonus logic for new levels or types requires careful insertion in the nested "bonusnivå" routines and corresponding file update logic.
- **Debugging**:
  - This program makes intensive use of file I/O; test with realistic volumes.
  - Note that bonus updating of sales statistics is currently disabled.
- **Parameter Passing**:
  - The program is normally called with company, customer, year, bonus type, and (optionally) period range.

---

## Quick Pseudocode Summary

```plaintext
Mainline:
  If end-of-job requested, exit.
  Move params to working vars.
  Load customer category info from master.
  Zero all bonus basis fields for customer.
  Zero all bonus element fields for customer.
  Zero all bonus type summary fields for customer.
  Calculate bonus basis for all sales in year (bonusgrunnlag).
  For all bonus base levels, calculate and store bonuses (bonus).
  Optionally: update sales stat with bonus share (statistikk).
  Exit.

Subroutine bonusgrunnlag:
  For all sales stat records for customer/year:
    For all possible bonus levels:
      If this sale matches the bonus level:
        Calculate net sales amount.
        Update basis in bonus base table.
        Mark bonus type as handled for this sale.

Subroutine bonus:
  For all bonus base records for customer:
    If basis > 0:
      For all matching bonus element records:
        If threshold matches:
          Calculate bonus.
          Update bonus element record.
          Add to bonus sum for this base.
      Update bonus base with sum.
  For all bonus type summary records:
    Sum up total bonus for type.
    Update summary.
  For all bonus types:
    If marked to calculate by total:
      Calculate and update accordingly.
    Else, sum up from elements and update.

Subroutine statistikk:
  (Not currently used; would propagate bonus share back to sales statistics)

Subroutine bonusnivå:
  For a sales stat record, check in order of 160+ possible bonus level combinations if it matches any defined in the bonus base table for the customer. If so, set flag and leave subroutine.

Other subroutines (6.14):
  sr_kbonus: calculate bonus by total, not element.
  sr_breduk: reduce bonus by percentage.
  sr_belem: sum bonuses per element and update type summary.
```

---

## Final Note

This program is core to the bonus calculation logic of the system and is a linchpin for any promotions or rebate programs offered to customers. To modify or debug it, you need a clear understanding of both the code structure and the business’s rules for handling bonus programs. The code is heavy on file IO and legacy RPG/400 patterns, so experience with this style is important. The multitude of bonus level combinations can make onboarding challenging without a clear mapping to your company’s actual setup. Invest time in understanding how your organization's bonus levels and thresholds are mapped into these tables.

---