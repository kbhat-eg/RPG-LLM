## High-Level Program Overview

This RPG program (`VV700R`) is designed to **find the next available (unused and not deleted) item number (`varenummer`) for a company (`firmanummer`)**. Specifically, it:

1. Receives as input a company number and a "starting" item number.
2. Searches for the next free item number that:
    - Does not exist in the `vvarl1` (active items) file.
    - Is not present in the `vvasl1` (deleted items) file.
3. Returns the next available item number via a parameter.

The program logic is in Norwegian, and the comments are quite illuminating for the intent.

---

## Key Files Used

- **`vvarl1`**: The main item registry file (active items list).
- **`vvasl1`**: The deleted item registry file (tracks deleted item numbers).
- Both files are keyed by company and item number.

---

## File Declarations

```rpg
fvvarl1    if   e           k disk    rename(vvarpfr:vvarl1r)
fvvasl1    if   e           k disk    rename(vvaspfr:vvasl1r)
```
- Defines two input files:
    - `vvarl1` (active items register)
    - `vvasl1` (deleted items register)
- Both are externally described, keyed (`k disk`), and renamed for this program.

---

## Parameter and Variable Definitions

```rpg
d p_firm          s                   like(vvfirm)
d p_pvar          s                   like(vvvare)
d p_vare          s                   like(vvvare)
...
d w_firm          s                   like(vvfirm)
d w_vare_lest     s              8  0
d w_pvar          s              8  0
d w_vare          s              8  0
```
- **Input/Output Parameters**
    - `p_firm` : Company number (input)
    - `p_pvar` : Item number for positioning (input)
    - `p_vare` : Next available item number (output)
- **Work Variables**
    - Used to process and manipulate item numbers and company codes.

---

## Entry / Parameter Handling

```rpg
c     *inzsr        begsr
...
c     *entry        plist
c                   parm                    p_firm
c                   parm                    p_pvar
c                   parm                    p_vare
```
- The program expects 3 parameters passed in/out.
- Parameters are mapped to the internal program variables.

---

## Main Program Logic

1. **Initialize the Output Parameter**
    ```rpg
    c                   eval      p_vare = *blank
    ```
    Clears the output parameter before processing.

2. **Prepare Starting Item Number**
    ```rpg
    c                   movel     p_pvar        w_pvar
    c                   if        w_pvar > 0
    c                   eval      w_pvar = w_pvar - 1
    c                   endif
    ```
    - Positions to the parameterized starting item number (`p_pvar`).
    - If greater than 0, decrements by 1 to ensure the next available is found.

3. **Iterate Through Active Items (vvarl1) for the Company**
    ```rpg
    c                   movel     w_pvar        vvarl1_vare
    c     vvarl1_key    setll     vvarl1
    c                   read      vvarl1                                 90
    c                   dow       *in90 = *off
    ```
    - Sets the key to the item number just before the start.
    - Reads sequentially through the `vvarl1` file (active items).

4. **Check for Company Match**
    ```rpg
    c                   if        vvfirm <> p_firm
    c                   leave
    c                   endif
    ```
    - If the current record is for another company, stop processing.

5. **Find Gaps in Item Numbers**
    ```rpg
    c                   movel     vvvare        w_vare_lest
    c                   eval      w_vare = w_pvar + 1
    c                   dow       w_vare < w_vare_lest
        ...
        c                   eval      w_vare = w_vare + 1
    c                   enddo
    ```
    - For each "hole" between the last item key examined (`w_pvar`) and the current item number (`w_vare_lest`), check each potential number (`w_vare`).

6. **Check if Candidate Item is In Deleted Items**
    ```rpg
    c                   movel     w_vare        vvasl1_vare
    c     vvasl1_key    chain     vvasl1                             91
    c                   if        *in91 = *on
    c                   leave
    c                   endif
    ```
    - For each candidate, checks if the item number does **not** exist in the deleted items file (`vvasl1`).
    - If the candidate number is *not* found, it's available.

7. **Return the First Available Item Number**
    ```rpg
    c                   if        w_vare < w_vare_lest
    c                   movel     w_vare        p_vare
    c                   leave
    c                   endif
    ```
    - On finding a free item number, sets the output param and exits.

8. **Continue Search if Not Found**
    ```rpg
    c                   eval      w_pvar = w_vare_lest
    c                   read      vvarl1                                 90
    c                   enddo
    ```
    - If not found, continue scanning the next item in `vvarl1`.

---

## Program Exit

```rpg
c                   eval      *inlr = *on
c                   return
```
- Turn on last record indicator (`*inlr`) and end the program.

---

## Subroutine *INZSR (Initialization)

- Populates the key lists for file operations.
- Copies company parameter (`p_firm`) to the work variable (`w_firm`).

---

## Summary Table

| Variable     | File      | Purpose                                    |
|--------------|-----------|--------------------------------------------|
| `vvarl1`     | Active    | Main items register (active items)         |
| `vvasl1`     | Deleted   | Tracks deleted item numbers                |
| `p_firm`     |           | Input: company number                      |
| `p_pvar`     |           | Input: starting position item number       |
| `p_vare`     |           | Output: next available item number         |

---

## Flow Summary

1. Get the firm and starting item number as parameters.
2. Begin searching from just before the input item number.
3. For each active item, search for gaps between item numbers, skipping over any number present in the deleted register (i.e., not "recycling" deleted numbers).
4. Return the first found available number.

---

## Onboarding Notes

- The logic is based around **finding the next "gap" in item numbers** that isn't invalidated by a deleted record.
- Reading and chaining over two files are essential for ensuring the next number is truly available.
- All main logic is in the main C-spec block; initialization and parameter handling are in the *INZSR subroutine.
- Key lists are used for efficient file access based on composite keys (company + item number).

---

## Danish/Norwegian terminology cheatsheet

- **Vare**: Item, product
- **Nummer**: Number
- **Slettet**: Deleted
- **Nest(e)**: Next
- **Ledige**: Available, free
- **Register**: Registry, file
- **Firma**: Company

---

If you need clarifications on ILE RPG syntax, file handling, or specifics about how key lists work, just ask!