## Purpose and Overview

This program (JA901R, part of the system *ASVADM*) creates standard default "routine" records in the "Formular-rutine-register" file. The routines likely represent print jobs, processing tasks, or business flows related to forms, documents, or campaigns, as indicated by the descriptions in the embedded comments and literal data.

The main purpose is to ensure a set of predefined routines exists in the routine register file (`aforlu`). For each routine in its list, if a corresponding record does not already exist, the program creates it with default values. It does **not** update routines that already exist (update logic is commented out and was deliberately deprecated as per the header revision log).

## File and Data Structure

- **File: `AFORLU`**  
  This is the key disk file (user open, externally described, renamed to `aforlur` in this program). It serves as the routines register. Records are identified by a key (the routine ID, `afruti`).  
  The file fields (prefixed `af*`) store various configuration values for each routine, such as description, form type, output queue, and many operational flags.

## Data Areas and Variables

- **`rut1`** and **`rut2`**  
  These arrays each hold 14 entries, populated via `ctdata` (compile-time data – see end of source).  
  - `rut1` holds routine metadata as 80-character strings (routine code, program name, description, form, outq).
  - `rut2` holds operational parameters for those routines, also as 80-character strings (encoded fields for flags/parameters).

- **Data Structures (`DS`)**
  - One DS parses `rut1` into routine id, program name, description, form, and output queue.
  - One DS parses `rut2` into various numeric and character configuration fields, each mapping offsets/lengths as packed/character data.  
    Notably, many of these field names (`acpi`, `alin`, `oflw`, etc.) map identically to fields in the `AFORLU` file.
  
- Some unused/unexplained structures (`l_firm`, `l_fnav`) likely relate to company name/number and are not touched by the logic here.

- **Key Variable**  
  `aforlu_ruti` (same type as file’s key field) is prepared for each lookup/insertion.

## Main Processing Logic

1. **Initialization (`*inzsr` subroutine)**  
   This routine sets up initial field values (resets `i` to zero) and defines the file key list for lookups.

2. **Main Loop (Routine Creation)**  
   Iterates across all 14 routines:
   - For each index `i`, parses one entry each from `rut1` and `rut2` into their respective DS layouts, extracting all needed fields.
   - Sets the key variable (`aforlu_ruti`).
   - **File Lookup (`chain`)**: Checks if this routine (by ID) exists in the register file.
   - **If not found**:  
     - Copies all appropriate fields from parsed arrays into the file buffer fields (`af*`).
     - Sets some fields to blanks or zeros (standard blanks for text, zeros for numeric flags, likely reflecting a required default state).
     - Writes the new routine record to `AFORLU`.

   - **If found**:  
     - **No update is performed** (the code for this is commented out, as per V5.50 change notes).
   
   - Loop continues for all routines.

3. **End and Exit**  
   Enters end-of-program tag, sets last record indicator (`LR`), and returns.

## Compile-time Data

At the end of the source, the actual 14 routines and their initialization data are listed as `ctdata` (compile-time data, to be bound into the program at compile time).  
- Block 1: User-facing fields (routine code, program name, description, etc.).
- Block 2: Operational/parameter fields, presumably technical flags, priorities, and config per routine.

## Design Patterns and Conventions

- **Bulk Initialization via Compile-Time Arrays**  
  Using two parallel arrays (each row corresponding to one routine) enables batch processing and easy maintenance of default data without hardcoding values in the program body.

- **Externally-Described File with Field Naming Convention:**  
  File fields are all prefixed similarly (`af*`), and the program mirrors this in its variable naming, ensuring easy mapping.

- **Selective Upsert Logic**  
  The program *only inserts new routines*; update logic is now deprecated and commented out (likely to protect existing configurations from being overwritten by re-running the program).

- **Extensive Use of Data Structures for Parsing**  
  Reads each 80-character record into a DS for field extraction, following the fixed layout of compile-time data.

- **Change Management**  
  The header comment block documents versions, dates, and descriptions of each significant change, a legacy practice but useful for this type of tightly controlled data maintenance program.

## Business or Domain-Specific Logic

- **Routine Register**  
  The AFORLU register appears to be foundational—possibly defining valid print or processing jobs related to sales, logistics, or campaign workflows.
- **Routine Codes**  
  Codes like `JH601`, `JM601`, etc., seem to be structured:  
  - The first character probably denotes a module or sub-application (e.g., "JX" for price jobs, "JV" for product registry).
- **Descriptions and Parameters**  
  The literal descriptions (see compile-time data) are user-facing: specifying various report or process outputs (e.g., "Utskrift av vareavtaler" – Print item agreements; "Matching, Utskrift matchede varer" – Matching, print of matched items).
- **Operational Flags**  
  Fields like `prty` (priority), `form`, `outq` (output queue), etc., control output destination and behavior.

## Relationships and Dependencies

- **AFORLU File**:  
  This program both reads and writes this register. The expectation is that other jobs in the system will reference or use these routines (by routine code) as a basis for job execution, reporting, or user options.

- **No Direct API Calls**:  
  This is a classic RPG batch loader program: it works with direct file IO, no external APIs are called.

## Noteworthy Design Notes

- **Safety via Idempotency**:  
  By refusing to overwrite existing routines, the program ensures safe repeated usage (won't lose any manual changes or updates made after initial load).

- **Legacy Practices**:  
  The presence of `*ctdata` and explicit DS parsing routines reflects both the era of the code and its intention for stability and batch automation.

- **Upgrades**:  
  The V5.40 and V5.50 lines in the header show regular update cycles for handling new business routines and refining update logic.

## Summary

This program is a batch loader/initializer that defines and inserts a set of standard routines into the system's central routine register, ensuring that key business processes (print, match, update, etc.) have default configuration available. It is designed for one-off or repeated safe use during upgrades/installations and reflects careful legacy design to protect existing production configuration. Any program interacting with job routines will likely depend on the AFORLU register populated (at least partially) by this program.