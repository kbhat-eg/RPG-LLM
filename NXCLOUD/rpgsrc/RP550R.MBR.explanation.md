# RPG Program Explanation

This ILE RPG program (`rp550R`) is a classic AS/400 interactive application that manages and displays orders and purchase orders per project using subfiles. The program is written in a mixture of Norwegian and standard RPG conventions. Below is a detailed explanation covering its structure, purpose, and main logic.

---

## High-Level Purpose

The program allows users to view and query orders and purchase orders by project. It uses subfiles to present records to the user, lets them browse details, and provides navigation and function key handling.

---

## Header Section

```rpg
h datedit(*dmy) option(*nodebugio)
```
- Sets the date format to day-month-year.
- Turns off debug I/O.

---

## File Definitions

```rpg
ffohel1    if   e           k disk    rename(fohepfr:fohel1r)
flohel1    if   e           k disk    rename(lohepfr:lohel1r)
frlevl1    if   e           k disk    rename(rlevpfr:rlevl1r)
frp550d    cf   e             workstn sfile(b1sfl:w_srrn)
f                                     infds(dspfbk)
```
- **fohel1, lohel1, rlevl1**: Physical/logical files for orders, purchase orders, and supplier info, respectively. The files are renamed for local use.
- **rp550d**: Workstation (display) file using a subfile (`b1sfl`) for interacting with the user. Field feedback info is stored in `dspfbk`.

---

## Indicator Assignments

Comments explain which indicators are used for which purposes, e.g.:
- LR — Last record (end program)
- 10–16 — Subfile and display navigation/management
- 21–22 — Cursor placement, home key, etc.
- 30–99 — Field protection, error warnings, work/file indicators

---

## Data Structures and Variables

### Info Structure for Subfile Data

```rpg
d                 ds
d tr_info                      139    dim(500)
d  tr_numm                       8  0 overlay(tr_info:1)
...
d  tr_salg                      11  2 overlay(tr_info:128)
```
- Defines an array (`tr_info`) of 500 elements for holding subfile records.
- Uses overlays to map various fields (order number, type, customer name, status, user, date, time, etc.) within each element for easy access.

### Other DS, Variables, and Parameters

- `d_prec`, `d_firm`, etc.: Used for specific key or result info.
- `p_firm`, `p_proj`: Parameters for company and project.
- Local Data Area (`lda`): Used for user, firm, project name, etc.
- Many working variables (`w_*`): For controlling subfile navigation, paging, tracking current record, etc.

---

## Key Lists

Key lists are declared for fast keyed access to files (`fohel1`, `lohel1`, `rlevl1`).

---

## Main Program Logic

### *INZSR Subroutine (Initialization)

- Loads parameters (company, project).
- Initializes key lists and working variables.
- Sets up subfile with a call to `crt_subfile`.

### Main Loop

- Displays main screen (`b2cmd`).
- Calls display subroutine (`dsp_subfile`).
- Handles function keys:
    - F3/F12: Exit program.
    - F5: Refresh subfile.
    - Home key: Set cursor for new input.
- Calls subfile handling routine (`subfile`).
- Loops back for further user interaction.

### Ending the Program

- Sets on *INLR to exit cleanly.

---

## Subroutine Details

### forny (Refresh Subfile)

- Re-reads current subfile record if needed.
- Clears and recreates the subfile.

### subfile (Handle Subfile Interaction)

- Toggles cursor placement indicator.
- Reads through displayed subfile records:
    - If user requests details (`b1valg = 5`), determines whether it's an order or purchase order, and calls the relevant display program (`FO505R` or `LO505R`).
    - Updates record after viewing.
- Leaves when all records processed.

### clr_subfile (Clear Subfile)

- Sets indicators to clear the subfile.
- Writes control record to indicate clear.
- Resets page/record counters.

### crt_subfile (Create/Fill Subfile)

- Clears info table (`null_tab`).
- Populates subfile data for orders (`finn_ordre`) and purchase orders (`finn_bestill`).
- Sorts the combined result (`sort_tab`).
- Writes entries to the subfile.

### dsp_subfile (Display Subfile)

- Handles subfile display:
    - If subfile has records, shows the select line.
    - If not, shows the command screen.
    - Manages indicators for field and cursor placement.

### null_tab (Clear Info Array)

- Zeros and blanks all elements in the `tr_info` array.

### finn_ordre (Populate Orders)

- Runs embedded SQL to select all orders for the current project and firm.
- Fetches each order, reads detailed data with `CHAIN`.
- Fills info array with order details.

### finn_bestill (Populate Purchase Orders)

- Runs embedded SQL to select all purchase orders for the current project and firm.
- Fetches each PO, attempts to get detailed info.
- If some fields are blank, chains to supplier record for more data.
- Fills info array with purchase order details.

### sort_tab (Sort Info Array)

- Sorts the subfile array by the `tr_sort` field.

---

## Special Field/Screen Handling

- Uses indicators to control subfile roll, clear, end, and cursor position.
- Supports both orders (`'O'`) and purchase orders (`'B'`) in the same display, differentiating them by type code.

---

## Subfile Operation Summary

1. At startup, builds a list of orders and purchase orders for the current project.
2. Fills subfile, sorting and paginating as needed.
3. User can roll, page, or request details for any line.
4. Details are displayed via external programs, depending on type.
5. Supports refresh and clear operations.

---

## Quick References

- **Subfile**: A technique in RPG to display lists (records) on a screen.
- **CHAIN**: Reads a record by key.
- **WRITE/UPDATE/READC/EXFMT**: Screen I/O operations.
- **Indicators**: Used to control flow and screen behavior.

---

## Conclusion

This program is a robust, interactive subfile app typical of classic AS/400 business applications. It efficiently combines data from orders and purchase orders, offers in-place drilling into details, and uses indicators and subroutines to handle all display and user interaction tasks. 

If you are onboarding to this program, pay close attention to:
- The use of arrays (`tr_info`) for subfile data.
- The two-step population of display data (orders and POs).
- The indicator handling for subfile controls.
- Embedded SQL for dynamic data gathering.
- How detail programs for orders and POs are called.

If you need to enhance or troubleshoot, these are the main areas to focus on.