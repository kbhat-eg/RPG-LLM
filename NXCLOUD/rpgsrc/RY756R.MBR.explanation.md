# RPG Program Walkthrough: RY751R

This program is written in ILE RPG (RPG IV) for the IBM i platform. Its purpose is to read SKU records from an external file (the "CHRIST" file), update purchase prices, and create mark-up records at the item level.

## 1. **File Declarations**
```rpg
fjrvapf    if   e           k disk
fjvarl8    if   e           k disk    rename(jvarpfr:jvarl8r)
fjvdtl1    if   e           k disk    rename(jvdtpfr:jvdtl1r)
fjvprlu    uf a e           k disk    rename(jvprpfr:jvprlur)
fjpfalu    uf a e           k disk    rename(jpfapfr:jpfalur)
```
- **fjrvapf**: Main driver file, read-only (input, keyed).
- **fjvarl8, fjvdtl1, fjvprlu, fjpfalu**: Other files needed for lookups and updates, renamed for clarity within this program.

## 2. **LDA / Field Definitions**
**User Data Area (LDA):**
```rpg
d l_user                911    920
d l_firm                944    946  0
```
- These read user and firm codes from the Local Data Area, positions specified.

**Input Record Layout:**
```rpg
d                 ds
d d_inpu                       160
d  d_pdat                        6  0 overlay(d_inpu:1)     // Date from supplier
...
d  d_inpr                        9  2 overlay(d_inpu:134)   // Purchase price
d  d_sapr                        9  2 overlay(d_inpu:152)   // Sale price
```
- A data structure overlays a 160-byte string for input, mapping out relevant fields for each item.

**Work Variables/Keys:**
- For matching and updating records, variables like `w_firm`, `w_lvar`, and keys for each file are defined.

## 3. **Main Program Loop**
```rpg
c                   read      jrvapf                                 90
c                   dow       *in90 = *off
// ... process record ...
c                   read      jrvapf                                 90
c                   enddo
c                   eval      *inlr = *on
c                   return
```
- Reads each record from `jrvapf` (input file).
- For each, loads the input fields and calls the **`oppdater`** subroutine to process.

## 4. **oppdater Subroutine**
Handles the main logic for each input record.

### Steps:
1. **Skip if Purchase Price is 0**
    ```rpg
    c                   if        d_inpr = 0
    c                   leavesr
    c                   endif
    ```
2. **Create trimmed item number (w_lvar) for lookups**
    ```rpg
    c                   eval      w_lvar = %trim('0' + %subst(d_vare:8:6))
    ```
3. **Look up in `jvarl8` (item/variant table)**
    ```rpg
    c                   eval      jvarl8_ldor = 009998
    c                   eval      jvarl8_lvar = w_lvar
    c     jvarl8_key    chain     jvarl8                             91
    c                   if        *in91 = *on
    c                   leavesr
    c                   endif
    ```
    - If no match, exit.

4. **Call `oppd_pris` Subroutine**
    - To update the purchase price for this item.

5. **If sale price not present, exit**
6. **Check in `jvdtl1` (item detail)**
    - Only if the detail exists **and** not marked with HKO=1, proceed.

7. **Prepare and write a mark-up record to `jpfalur`:**
    - Set various fields, calculate mark-up as `sale price / purchase price`.
    - Timestamp fields are set to current time.

## 5. **oppd_pris Subroutine**
Handles the updating or creation of purchase prices for items.

- Uses the item identifier as a key to look up in `jvprlu`.
- Fills fields, sets start date (`jxgdat`) if available.
- If found, updates the record; otherwise, writes a new one.

## 6. **Initialization Subroutine (\*inzsr)**
- Sets up key lists for chained file access.
- Pulls the firm number from the LDA.

## 7. **Key Lists**
- `jvarl8_key`: For item/variant lookup.
- `jvdtl1_key`: For item detail.
- `jvprlu_key`: For purchase price update.

## 8. **Other Features**
- Uses time and date built-ins for timestamps.
- Calculates mark-up ratio and writes to the mark-up file.

---

## **Summary of Program Flow**
1. **Initialization**: Set up key-lists and retrieve firm number.
2. **Main Loop**: For each input record from the CHRIST file:
    - Unpack fields from the input string.
    - If purchase price exists and the item exists in master data:
        - Update purchase price.
        - If sales price is present and item is "released", write a new mark-up record.
3. **End**: Close files and terminate.

---

## **Key Concepts in Use**
- **File I/O (CHAIN, UPDATE, WRITE):** Directly manipulating DB2 tables ("files") via RPG op-codes.
- **Data Structures and Overlays:** Efficiently map input formats to usable fields.
- **Key-driven Logic:** Lookups and updates are always performed via keys for performance and consistency.
- **Program Structure:** Classic RPG with subroutines for code reuse and organization.

---

## **Business Context (from Comments)**
- Reads supplier data (CHRIST) and ensures item master & price files are updated with new/changed purchase and sales prices.
- Automatically creates mark-up records at the SKU level if new sales prices are present.

---

## **Onboarding Tips**
- **Understand the external file layouts**, especially how input data is mapped and how keys are built.
- **Familiarize yourself with RPG file operations** (`CHAIN`, `UPDATE`, `WRITE`, subfile keys).
- **Observe Error Handling**: Skips records with missing prices or keys not foundâ€”could be enhanced with logging.

---

This is a robust batch update program managing critical item/pricing data. If you need to extend, troubleshoot, or adapt it:
- Add log or error capture in subroutines for smoother operations.
- Ensure all file layouts and field mappings are always current with the DB2 design.