# RPG Program LL612R – Explanation

This program is a classic IBM i ILE RPG (RPG IV) program, used for data selection and extraction in support of an "ABC analysis" (often used for inventory segmentation and valuation). The program processes inventory records, applies filtering and business rules, calculates prices and values, and writes the result to a work file. Below is a detailed breakdown by section.

---

## Specifications and File Declarations

- **Header Spec**  
  ```
  h datedit(*dmy) option(*nodebugio)
  ```
  - `datedit(*dmy)`: Date editing is DD/MM/YY.
  - `option(*nodebugio)`: Disables debugging of record I/O.

- **File Specs:**  
  Various files are defined for reading (input, keyed) and writing (output, work file).  
  - Files renamed for local naming.
  - Most read files are inventory, item, group, and statistics master files.

---

## Data Structures and Fields

### Parameters

- A data structure, `p_prec`, overlays a 128-character buffer for parameter passing and splits it into individual operational parameters: periods, item number ranges, warehouse ranges, group ranges, vendor and responsible codes, etc.

### Item Group Keys

- Data structures for representing item groupings (over, main, sub group) for "from", "to" and "current" values, mainly for filtering.

### Local Variables

- Various fields for holding keys, dates, prices, calculations, and temporary fields for processing.

### Key Lists

- Key lists (`klist`/`kfild`) are used for indexed access (`chain`, `setll`) on the files. They define composite keys for rapid lookups.

---

## Main Logic Flow

### Entry and Initialization (`*inzsr` subroutine)

- The program starts by reading the parameter buffer and breaking it into fields.
- Key lists for indexed file access are established.
- The initial "from" values (`p_fvar`, `p_flag`) are loaded as start points in the inventory file.

### Main Processing Loop (`les_lager` label)

The loop processes inventory ("lager") records. For each record, it performs:

1. **End-of-File/Termination Checks:**  
   - Ends the loop if out of inventory records, out of firm scope, out of item/warehouse range, etc.

2. **Inventory Filtering:**
   - Ensures the record matches the specified firm.
   - Checks warehouse number is within range.
   - Confirms the item exists in the item master.
   - Verifies if the groupings fall within specified ranges.

3. **Group Stock Control Checks:**  
   - Verifies, for under/main/over-group, if stock control ("lagerstyres") is enabled.

4. **Supplier and Handler Checks:**  
   - If a supplier or responsible handler is specified, checks it matches the item.

5. **Stock Item Check:**  
   - Only processes stock items (`vlvtyp = 'L'`).

6. **Sorting Key Construction:**  
   - Builds a sorting key (`p_mkey`) per user-specified sort order.

7. **Price Determination and Calculation:**  
   - Looks up price group (via subroutine/call).
   - Calls external program `'VP730R'` to get pricing information.
   - Calculated prices and item values are assigned.

8. **Sales Data Accumulation:**  
   - Calls `akk_salg` subroutine to accumulate sales statistics for the current period and item/warehouse combination.

9. **Value Calculations:**  
   - Computes sales value, cost, margin, and inventory value.

10. **Writing Output:**  
    - Writes the processed record to the work file.

11. **Next Record:**  
    - Loops back to process the next warehouse record.

### Program Termination

- On completion or error, sets LR (`*inlr = *on`) to end the program.

---

## Subroutines

### `akk_salg` – Accumulate Sales

- Reads the sales statistics file (`sstal2`) for the relevant item, period, and warehouse.
- Loops through, accumulating sales quantity (`sfanta`) only for the specified firm, item, period, and warehouse, within the date/month bounds.

### `hent_prisgr` – Fetch Price Group

- Calls external program `'VL712R'` to determine the item's price group, based on warehouse and firm.

---

## Key Implementation Notes

- **Indicators:**  
  Standard RPG numeric indicators are used for error, end-of-file, and special condition handling.
- **Parameter Handling:**  
  Overlaying a single input buffer (`p_prec`) with multiple fields allows passing many parameters succinctly (common in classic RPG).
- **Sorting:**  
  Dynamic sort key construction supports flexible output order.
- **File Access:**  
  Heavy use of keyed access (`chain`, `setll`) for performance.
- **External Programs:**  
  Pricing logic and price group lookup are externalized, probably central in business logic.
- **Comments:**  
  Richly commented in Norwegian, with version history and detailed descriptions.

---

## Typical Flow Diagram

```
Start -> Init (*inzsr) -> Loop lager
    -> Filter/validate record (firm, item, warehouse, group, etc.)
    -> If passes all checks:
          -> Build sort key
          -> Get price group (external)
          -> Get prices (external)
          -> Accumulate sales (akk_salg)
          -> Calculate values
          -> Write to work file
    -> Next record
End (when no more records or out of range)
```

---

## Use Case

This program is used to extract and pre-calculate inventory statistics for later ABC analysis, segmenting inventory by value, group, sales, or other criteria, often forming the basis for reporting or further ERP processing.

---

## Onboarding Tips

- **Understand the files:** Know the structures of inventory, item master, groups, and sales statistics files.
- **Parameter buffer (`p_prec`):** Learn how parameters are packed/unpacked for flexible batch execution.
- **Key lists:** RPG's way of constructing composite keys for indexed lookups.
- **External Calls:** Pricing is handled in external programs; you'll need to reference their interfaces.
- **Indicators:** Used for EOF, file errors, and various logical tests—understand their mapping from comments.
- **Modify Logic:** To adjust for new selection/filtering rules, edit the appropriate `if` blocks.

---

## Conclusion

This is a robust classic ERP batch extraction program, relying on RPG idioms and IBM i architecture. Its modular filtering, subroutine structure, and external price determination make it both powerful and adaptable for standard inventory control and analytics workflows.