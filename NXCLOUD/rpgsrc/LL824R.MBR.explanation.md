# RPG Program LL824R – Explanation

## Overview

This RPG program (LL824R) is designed to **delete items from the inventory register** (LAGER-REGISTER) if they meet certain strict conditions, and if they **do not exist** in the inventory counting register (LAGER-TELLE-REGISTER).

The code is written in traditional (fixed-format) RPG IV (ILE RPG) and contains detailed comments in Norwegian. The main data flow is:

1. Sequentially read items from the inventory file (`VLAGL1`).
2. Check multiple conditions to ensure the item can be deleted (e.g., no stock, no orders, etc.).
3. Double-check that the item is **not** present in the counting register (`LTELL2`).
4. If all criteria are met, delete the item from the logical update file (`VLAGLU`).

---

## File Definitions

```rpg
FVLAGL1    IF   E           K DISK
F                                     RENAME(VLAGPFR:VLAGL1R)
FVLAGLU    UF   E           K DISK
F                                     RENAME(VLAGPFR:VLAGLUR)
FLBCHL1    IF   E           K DISK
F                                     RENAME(LBCHPFR:LBCHL1R)
FLTELL2    IF   E           K DISK
F                                     RENAME(LTELPFR:LTELL2R)
```

- **VLAGL1**: Inventory (Lager) register, input file.  
- **VLAGLU**: Inventory (Lager) register, update/delete capable.  
- **LBCHL1**: Batch register file, input file.  
- **LTELL2**: Inventory counting register, input file (to check if items have counting records).

Each file uses the `RENAME` keyword to map a physical file record format to a logical name used in the program.

---

## Data Structures

```rpg
D                 DS
D  DSPREC                 1     64
D  DSBATC                 1     10
D  DSVAL1                11     11  0
D  DSVAL2                12     12  0
...
D                UDS
D  DSFIRM               944    946  0
```

- **DSPREC**: 64 bytes, used for input parameters.
- **DSFIRM, DSBATC** etc.: Help extract fields from the parameter record (e.g., company number, batch).
- **UDS (User Data Structure)**: Used to hold local data (company number `DSFIRM`, etc.).

---

## Main Logic Details

### Initialization & Parameter Handling

- `*ENTRY PLIST`: Receives a 64-character parameter (`WWPARM`), then loads it into the internal data structure (`DSPREC`), extracts company number, batch number, and sets corresponding fields in the key structures.

### Main Deletion Loop

1. **Initialize Loop:**
    ```rpg
    C     LAGKEY        SETLL     VLAGL1R
    XSTART TAG
    C                   MOVE      *OFF          *IN90
    C                   READ      VLAGL1R                                90
    C     *IN90         CABEQ     *ON           XSLUTT
    ```
    - Position to start of file, begin loop with label `XSTART`.
    - Read next record; if no more, branch to `XSLUTT` (end).

2. **Company Check:**
    ```rpg
    C     VLFIRM        CABNE     LAGFIR        XSLUTT
    ```
    - Only process records for the correct company (matches parameter).

3. **Skip Records with Activity:**
    - For each of these fields, if they are *not zero*, skip to the next record:
        - `VLBEHL`, `VLPAKK`, `VLOORD`, `VLORES`, `VLBBES`, `VLBRES` (stock, orders, reservations, etc.)
        - `VLINNG`, `VLUTTA`, `VLJUST`, `VLSALG`, `VLRETU`, `VLBEVE` (different transaction types: inbound, outbound, adjustments, sales, returns, movements)
    - Ensures only items with **no activity** are considered for deletion.

4. **Check for Existence in Counting Register:**
    ```rpg
    C                   MOVE      VLVARE        TVAVAR
    C                   MOVE      VLLAGE        TVALAG
    C     TVAKEY        CHAIN     LTELL2                             92
    C     *IN92         CABEQ     *OFF          XSTART
    ```
    - If the item exists in the counting register (`LTELL2`), skip deletion.

5. **Delete the Item:**
    ```rpg
    C                   MOVE      VLVARE        LAGVAR
    C                   MOVE      VLLAGE        LAGNUM
    C     LAGKEY        CHAIN     VLAGLU                             94
    C     *IN94         IFEQ      *OFF
    C                   DELETE    VLAGLUR
    C                   END
    ```
    - Find the same record in the update file (`VLAGLU`), and if found, delete it.

6. **Repeat Loop:**
    ```rpg
    C                   GOTO      XSTART
    ```

---

### Ending the Program

```rpg
C     XSLUTT        TAG
C                   SETON                                        LR
C                   RETURN
```
- When reaching end of file or certain conditions, set LR (last record) to signal RPG runtime to clean up and end the program.

---

### Initialization Subroutine (*INZSR)

- Defines extensible keys for files (`KLIST`/`KFLD`).
- Extracts relevant data from input parameter to fill key fields.
- Loads information from the batch register if needed.

---

## Summary Table

| Step                      | Operation                                                     |
|---------------------------|--------------------------------------------------------------|
| Read Inventory            | Read record from `VLAGL1`                                    |
| Company Match             | Only process if company matches parameter                    |
| Activity Checks           | Must have zero stock, zero orders, zero transactions         |
| Counting Register Check   | Must *not* exist in `LTELL2`                                 |
| Delete Item               | Find and delete from `VLAGLU`                                |
| Loop                      | Go to next record                                            |
| Exit                      | End when EOF or company mismatch                             |

---

## Key Points for Onboarding

- **Purpose:** Remove "inactive" items (with no stock or activity) from the inventory register, provided they are not present in the counting register.
- **Safety:** Multiple checks prevent accidental deletion of items with any kind of activity or reservation.
- **Parameterization:** Program is company-specific, takes records to process via input parameter (64 chars).
- **Extensibility:** Uses `KLIST` for keys, reused in multiple files.

**Tip:** When maintaining or enhancing, pay attention to the zero checks for all activity and transaction fields—adding new types of activity fields similarly will maintain integrity. Also, confirm that any changes to record layouts are reflected in key definitions and parameter parsing.

---

**If you need explanations for any specific section or logic, let me know!**