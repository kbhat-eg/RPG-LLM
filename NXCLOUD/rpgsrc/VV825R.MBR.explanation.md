# RPG Program VV824R - Explanation

This ILE RPG program, VV824R, is responsible for updating product prices in an internal price file from a data source called "SOLVE," which provides XML-format price data. It converts prices based on the base unit to prices for all found units related to each product.

Below is an in-depth walkthrough of its sections and main logic, to help developers onboard quickly.

---

## Program Overview and Purpose

- **Program Name:** VV824R
- **Main Function:** Reads pricing data from an XML view (`PRIS_XML_SOLVE_VIEW`), recalculates these for different units, checks and updates the internal price register, and logs anomalies or issues.
- **Change Log:** The comments at the top describe key changes, especially in handling suppliers and units.

---

## File Declarations

Several physical or logical files are declared with different purposes and aliases:
- `vvprlu` (update file): Price register (main update target).
- `rlevlb`: Supplier master file (relation to NOBB number).
- `vvenl1`, `vvenl2`, `vvenl4`: Product/unit master files (handle different unit types and relationships).
- `vvprl1`: Old price lookup file.
- `jstsl1`: Job status control.

---

## Data Structures and Variables

- **Key Variables**: Separate variables for each field used in composite keys for file access.
- **Job Logging**: Variables like `p_jnav`, `p_jbid`, `p_jtxt`, etc., are used for logging the process and errors.
- **Parameters**: Variables like `p_filNavn`, `p_lengde`, `p_sistDato`, `p_stat` are parameters fed to the program (e.g., file name, length, last date, status).
- **Working Variables**: For each price, product, or calculation, there are working variables for price fields, unit codes, base price, conversion coefficients, and so on.
- **Constants**: `c_digi` holds a string of digits for character validation.

---

## Main Program Logic

### 1. Initialization

- The program begins by reading parameters (`p_filNavn`, etc.).
- Constructs the XML file name, gets today's date.
- Sets the name of the XML file to be processed using embedded SQL.

### 2. Opening the SQL Cursor to Read XML Data

- Declares and opens a SQL cursor (`c1`) over `PRIS_XML_SOLVE_VIEW` (joined to supplier master file for additional fields).
- For each row in the cursor (i.e., for each price record from the XML):
  - Fields are read into variables like `x_vare`, `x_nldo`, `x_prgr`, `x_enhe`, etc.

### 3. Main Loop Over Input Data

- **Termination Condition**: The loop continues until a SQL fetch fails (either error or end-of-file).
- **Validation**: Only processes records where the product (article) number consists of digits.
- For each valid record, it calls subroutine `skr_pris` to process the price.

### 4. Subroutine: `skr_pris` (Write/Update Price)

Handles the core logic for each price record:

#### Supplier Validation
- Checks if the supplier number (`x_nldo`) is provided.
- If not, logs an error and leaves the subroutine.

#### Find Supplier Account
- Converts the supplier's NOBB participant number to internal account number by lookup in `rlevlb`.
- If lookup fails, logs an error and leaves the subroutine.

#### Validate Product/Unit Existence
- Validates the product-unit combination exists.
- If not, logs an error and leaves.

#### Find All Units for Product
- Calls `finn_enhet`, which populates up to five possible units for the product (sale, purchase, etc.).

#### Prepare Price Calculations
- Converts string prices to numeric, handles defaults, calculates date fields, etc.

#### Process Each Unit
- For each found unit (`w_enh1`â€“`w_enh5`), calls `pris_enhet` subroutine to process/validate/update the actual price.

---

### 5. Subroutine: `finn_enhet` (Find Related Units)

- **Purpose**: For a given product, finds up to five relevant units:
    - Prioritizes sales units (`vvenl2`).
    - Adds purchase units (`vvenl4`) that are not already included.
    - (In version 7.02) Adds units that are neither sales nor purchase units, as a last resort.

- **Process**:
    - Iterates over eligible rows and fills slots for up to five units with related conversion factors (`w_omrX`).

---

### 6. Subroutine: `pris_enhet` (Process Each Unit Price)

- **Validation:**
    - Checks for unrealistic prices (too high) for each price type (sales, cost, purchase prices, etc.), logging an error and skipping update if problems are found.

- **Calculations:**
    - Multiplies basic price values with unit conversion coefficients to get "unit-specific" prices.

- **Change Detection:**
    - Calls `finn_gml_pr` to read the previous price, and avoids rewriting the price if no change is detected.

- **File Update:**
    - If record exists, updates the relevant price fields and audit information.
    - If new, fills in the record and writes it.

---

### 7. Subroutine: `finn_gml_pr` (Find Old Price)

- Uses key fields to look up the existing price record for the product/unit/supplier/date.
- Updates "old" values (`s_sapr`, etc.) for comparison, and sets the flag `b_pris` to indicate a valid record was found.

---

### 8. Logging Subroutines

- **`start_logg`**: Initiates, if not already done, job logging through a call to system program `AB700R`.
- Logging of errors/issues throughout is consistently handled by calls to `AB705R`, passing specific error messages and job information.

---

### 9. Cleanup and End

- After the main loop, closes the SQL cursor.
- Sets the output parameter `p_sistDato` to today's date.
- Marks job status as complete, and returns.

---

## Additional Technical Notes

- The program uses embedded SQL for reading the XML-derived data because it is imported into DB2/400 as a SQL view.
- Data integrity and referential checks are strictly enforced at every step, with detailed job logging.
- Multiple "key lists" (`klist`) are defined for quick and clear file access patterns.

---

## Summary

- **Input**: XML-based price records, passed as a file name parameter, loaded into a view.
- **Process**: For each price record, determines all relevant units, validates and transforms price data, compares to existing prices, and updates the internal price register as necessary.
- **Output**: Updated price register, job logging, error tracking, and timestamping.

---

This program is carefully structured to ensure accurate and auditable updates from external price sources, with comprehensive error handling and a modular design to handle changes in product, supplier, or unit relationships as business needs evolve.