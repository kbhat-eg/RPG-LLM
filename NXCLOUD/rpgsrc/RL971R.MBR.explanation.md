```markdown
# ILE RPG Code Explanation – RL971R

This RPG program, `RL971R`, is designed to update supplier (leverandør) balances and yearly purchases in a set of files (physical and logical files associated with suppliers and transactions). Below is a walkthrough of the major parts and logic of the program.

---

## **1. Header & Documentation**

- `h option(*nodebugio) datedit(*dmy)`  
  Compiler directives:
  - `*nodebugio` disables debug data for input/output operations.
  - `datedit(*dmy)` sets the default date format to day/month/year.

- The long comment block describes system, program name, history of changes, and the purpose ("Leverandører, oppdaterer saldo/kjøp i år" – Suppliers, update balance/purchase this year).

---

## **2. File Declarations**

```rpg
frltrl1    if   e           k disk    rename(rltrpfr:rltrl1r)
frlevl1    uf   e           k disk    rename(rlevpfr:rlevl1r)
frlevlu    uf   e           k disk    rename(rlevpfr:rlevlur)
fra01l1    if   e           k disk    rename(ra01pfr:ra01l1r)
```

- Declares four files:
    - `rltrl1` (supplier transactions, input)
    - `rlevl1` (supplier master, update)
    - `rlevlu` (supplier master, update, alternate access)
    - `ra01l1` (voucher codes, input)

---

## **3. Data Definitions**

A mix of imported fields and working storage (work variables, starting column 7 with `s` or referencing database fields with `like()`).

- Example:
    - `w_akod` – work variable with same type as `raakod`
    - `w_faar` – work variable for last year
    - `w_levr`, `w_levr_gml` – current and previous supplier number

These are used for record processing and accumulating totals.

---

## **4. Main Logic - Control Level**

### **Initialization**

- The main logic starts with a label/tag `dummy`.
- Calls initialization subroutine `*inzsr` (see later for details).

---

### **Reading Supplier Transaction Records**

- Sets and reads first record by key (`setll`/`reade`) from `rltrl1`. 
- Enters a loop:  
    `dow *in61 = *off` (do while record found, *in61 is off = last read successful).

---

#### **Supplier Break Tests & Subtotals**

- When supplier number (`rolevr`) changes (`if rolevr <> w_levr_gml`):
    - Calls `opdlev` subroutine to update previous supplier's aggregated data.
    - Resets current totals: `w_sald`, `w_saif`, `w_kj�p`, `w_kj�f`.
    - Sets `w_levr_gml` to new supplier number.

---

#### **Balance Updates**

- If record's `rpsald` is 'J' (yes, balance to be considered):
    - **Line 6.20** (see change history!): Adds field `robel�` (the amount) to `w_sald`.
        - Note: Previously used `rorest` (remaining amount), now uses `robel�`.
    - If transaction's year (`roraar`) is less than current year (`rpraar`): add to previous year's total (`w_saif`).

---

#### **Purchase Updates**

- Reads voucher code record using key (`chain`).
- If the code's `raakj�` = '1' (this code updates purchase):
    - If `rpkj�p` = 'J' and transaction year = current year: add amount to current year (`w_kj�p`).
    - If `rpkj�f` = 'J' and transaction year = last year: add to last year's purchases (`w_kj�f`).

- Reads next transaction record.

---

#### **End of Loop**

- After loop, one last supplier may need to be updated (calls `opdlev`).
- Sets LR (last record), which ends the program.

---

## **5. Subroutines**

### **A. `nullev` – Zero Out Supplier Totals**

- Reads through the supplier master (`rlevl1`) and zeros fields (`rlsald`, `rlsaif`, `rlkj�p`, `rlkj�f`) if the corresponding flags ('J') are set.

### **B. `opdlev` – Update Supplier**

- Using `rlevlu` for random access, finds the supplier by previous supplier number.
- If found (`*in62 = *off`):
    - Updates the supplier totals:
        - Current balance (`rlsald`), last year's balance (`rlsaif`)
        - Purchases this year (`rlkj�p`), last year (`rlkj�f`)
    - Also updates tracking fields: program name, timestamp, and user.

### **C. `*inzsr` – Initialization**

- Moves firm number into work variable.
- Sets previous supplier number to high value (`*hival`).
- Calculates previous year (`w_faar = rpraar - 1`).
- Calls `nullev` to zero out all supplier detail fields.
- Initializes all the key lists used by file I/O.

---

## **6. Constants, Keys, and Field Usage**

- KLIST and KFLD are used for defining compound keys for file operations matching the logical file structures.
- Many fields have the same format as database fields, ensuring consistency in data handling and calculations.

---

## **7. Change History Notes**

- Comments like `6.10`, `6.12`, `6.20` beside logic lines indicate change points, matching the documented changes in the header.
- Notably, balance field to use switched from `rorest` to `robel�` as per business rules.

---

## **Summary Logic Flow**

1. **Initialize:** Clear supplier balances/purchases for current and previous year.
2. **Process Transaction Records:** For each supplier transaction:
    - On supplier break, update supplier totals.
    - Accumulate totals per supplier for balances and purchases (by year).
    - Use voucher code file to determine if transaction should update purchases.
3. **At End:** Update last supplier.
4. **Update Files:** All updates are posted to the supplier master/update files.

---

## **Business Purpose**

- The program essentially **collects and posts summary balances and purchase totals per supplier**, segmented by current year and last year, resetting and then rebuilding the summary figures from individual transaction detail.

---

## **Tips for Onboarding Developers**

- Familiarize yourself with the database/file layouts; field names are critical.
- Understand how "supplier break" logic works (using `w_levr_gml`).
- Trace the subroutines for initialization, zeroing, and updating for full data life cycle.
- Pay attention to business rules around which transactions affect which totals (e.g., 'J' flags, voucher code attributes).
- Any changes to field usage (like the robel�/rorest switch) should be documented in both code and process documentation.
```