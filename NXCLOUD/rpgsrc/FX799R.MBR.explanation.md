# RPG Program FX799R: Explanation and Walkthrough

This RPG III/IV (ILE RPG) program is used for validating and managing account references ("kontohenvisning") in connection with inventory items (products). The code is in Norwegian, and many comments are documented in Norwegian as well.

Below is a detailed explanation meant for onboarding developers:

---

## 1. **Program Header and Configuration**

```rpg
h option(*nodebugio) datedit(*dmy)
```
- `option(*nodebugio)`: No debug data for file I/O in the object.
- `datedit(*dmy)`: Default date format is day/month/year.

### **Program Purpose**

- **System**: ASOFAK
- **Program**: FX799R
- **Description**: Control program for account references.
- **Change Log**: Noted with dates, initials, and descriptions.

---

## 2. **File Declarations**

```rpg
fvvarl1    if   e           k disk    rename(vvarpfr:vvarl1r)
ffx799d    cf   e             workstn
```
- `vvarl1`: Indexed file (probably VARE-REGISTER / product registry), externally described, keyed, renamed for use.
- `fx799d`: Display file for user screens and dialog.

---

## 3. **Local Data Area (LDA) Definitions**

```rpg
d                uds
d l_user                911    920
d l_firm                944    946  0
d l_fnav                951    980
```
- Defines fields in the LDA for user, firm, and full name according to fixed positions.

---

## 4. **Data Structures**

### **Account Information Structure**

```rpg
d                 ds
d d_hele                       128
d  d_kav1                        4  0 overlay(d_hele)
d  d_kko1                        6  0 overlay(d_hele:5)
...
d  d_khnv                        4    overlay(d_hele:99)
d  d_nivo                        1    overlay(d_hele:103)
```
- Packing multiple fields (account number parts, special values) into a single 128-byte buffer.
- `overlay()` allows referencing subfields at specific offsets.
- Used to transmit/receive account reference info in a single block.

---

## 5. **Working Variables**

Variables for key fields, status, buffers, item numbers, and error flags:

```rpg
d vvarl1_vare     s                   like(vvvare)
d w_stat          s              1
d w_hele          s            128
d w_ogrp          s              2  0
d w_hgrp          s              2  0
d w_ugrp          s              3  0
d w_vare          s             15
d w_firm          s              3  0
d b_feil          s              1    inz(*off)
```
- Several variables hold values for use as parameters to called programs or logic.

---

## 6. **Constant and Screen Definitions**

- Screens `C1BLD` and `C2BLD` used for input and detail display.
- Indicator use is defined (`LR`, `30`, `31-99` for different purposes).

---

## 7. **Main Program Flow**

The main logic is linear: handle initial screen, loop as needed, then exit.

```rpg
c                   exsr      xc1bld
c                   eval      *inlr = *on
c                   return
```
- Calls the first subroutine (`xc1bld`) to interact with the user.
- Sets LR (Last Record) indicator to end the RPG program.

---

## 8. **Subroutine: `xc1bld` (Screen C1BLD Handling)**

Handles the initial screen where the user enters the product number and other key info.

### **Initialization**

```rpg
c                   eval      c1vare = *zero
c                   eval      c1klty = *zero
c                   eval      c1koty = *blank
```
- Clears input fields.

### **Screen Loop**

```rpg
c     c1taga        tag
c                   exfmt     c1bld
```
- Shows the first screen (`c1bld`) and waits for user input.

### **Function Key Handling**

```rpg
c                   select
c                   when      *inkc or *inkl
c                   goto      end_c1bld
c                   endsl
```
- Exit if function keys F3 (cancel) or F12 (return) are pressed.

### **Field Validation**

```rpg
c                   if        c1vare = 0
c                   goto      end_c1bld
c                   endif
```
- If product number is zero, exit.

### **Forward Navigation**

```rpg
c                   exsr      xc2bld
```
- Calls the next screen routine to process and possibly display account info.

#### **Error Handling**

```rpg
6.10 c                   if        b_feil = *on
6.10 c                   eval      *in31  = *on
6.10 c                   goto      c1taga
6.10 c                   endif
```
- If `b_feil` (error indicator) is set, set a screen indicator and loop back for correction.

### **Clear Inputs and Loop**

```rpg
c                   eval      c1vare = *zero
...
c                   goto      c1taga
```
- Clears fields and redisplays screen for new entry.

---

## 9. **Subroutine: `xc2bld` (Screen C2BLD Handling)**

Handles the logic for looking up the product, checking account reference information, and preparing data for the detail screen.

### **Reset Error Flag**

```rpg
c                   eval      b_feil = *off
```

### **Product Lookup**

```rpg
c                   movel     c1vare        w_vare
c                   eval      vvarl1_vare = w_vare
c     vvarl1_key    chain     vvarl1r
```
- Moves the product number into a working variable.
- Does a keyed lookup (`chain`) into the `vvarl1` file.

#### **Error if Product Not Found**

```rpg
6.10 c                   if        not %found(vvarl1)
6.10 c                   eval      b_feil = *on
6.10 c                   leavesr
6.10 c                   else
c                   eval      w_ogrp = vvogrp
c                   eval      w_hgrp = vvhgrp
c                   eval      w_ugrp = vvugrp
c                   endif
```
- If product not found, sets error flag and exits subroutine.
- If found, copies grouping data for further use.

### **Call External Program for Account References**

```rpg
c                   call      'VA720R'
c                   parm                    w_stat
...
c                   parm                    w_hele
```
- Calls external program `VA720R` passing relevant info and buffer for account references.

### **Interpret Returned Data**

- If no error indicated (`w_stat = *blank`), copies account ref fields from structure to screen fields.
- If error, clears the screen fields.

### **Mark Source Level of Account Reference**

- Sets a field (`c2nivo`) to explain where the reference was found (status register, overgroup, etc.) based on returned level info.
- If error, sets to "Feil i innhenting" (error in retrieval).

### **Display Screen and Handle Function Keys**

```rpg
c                   exfmt     c2bld
c                   if        *inkc or *inkl
c                   goto      end_c2bld
c                   endif
```
- Displays the detail screen, allows exit.

---

## 10. **Subroutine: `*inzsr` (Initialization)**

- Sets up the key fields for file access.
- Loads the firm number from the LDA.

---

## 11. **Key List for File Access**

```rpg
c     vvarl1_key    klist
c                   kfld                    w_firm
c                   kfld                    vvarl1_vare
```
- Specifies the keys used to access the product file.

---

# **Summary**

- **Screen C1BLD** gathers user input for product/account key.
- Product is validated; if not found, error message is displayed.
- If valid, **Screen C2BLD** shows retrieved account/account reference information, after invoking an external program (`VA720R`) to get this info.
- Account reference source is indicated (register, group, etc.).
- Error handling and screen refresh allow multiple queries.
- Clean separation of initialization, input, lookup, retrieval/calling, and display.

---

## **Important Concepts for Developers**

- **File Operations:** Classic RPG file model with keyed `chain` and external description.
- **Subroutines:** Used for modular, reusable blocks (screen handling, initialization).
- **Error Handling:** Uses boolean flags and RPG indicators.
- **Screen Management:** Synchronous display/input using EXFMT.
- **Data Exchange:** Packing multiple fields into a structure for program-to-program communication.
- **Localization:** Variable names and comments in Norwegian relate to domain terms ("kontohenvisning" = account reference, etc.).

---

**This code is a good example of classic ILE RPG interacting with display files, using subroutines, error handling, and data structures to support operator-driven validation and reference data retrieval.**