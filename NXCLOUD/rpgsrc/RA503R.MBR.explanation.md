# RPG Program RA503R – Explanation

This RPG/400 (ILE RPG) program is intended to manage and query "Betalingsbetingelser" (Payment Terms), offering a subfile-based user interface on IBM i (AS/400, iSeries, IBM i).

Below is an organized and pedagogical explanation, section by section, including the main logic, data definitions, subfile management, and user interaction.

---

## 1. Program and File Definitions

**Header (`h`) statement:**
```rpg
h option(*nodebugio) datedit(*dmy)
```
- `*nodebugio`: Disables debug input/output for performance.
- `datedit(*dmy)`: Specifies date edit format as day-month-year.

---

**Files:**

- `fra03l1` and `fra03l2`: Physical or logical files (`if` = input, `e` = externally described, `k` = keyed), renamed to `ra03l1r` and `ra03l2r`.
- `fra503d`: Workstation file (display file) used for screen handling, with a subfile (`sfile(b1sfl:w_srrn)`).

---

## 2. Data Definitions

### Parameters

```rpg
d p_firm          s   like(racfir)
d p_ckod          s   like(rackod)
d p_ctxt          s   like(ractxt)
```
- Parameters passed into the program for company, payment code, and payment description.

### Work Variables

```rpg
d w_stel          s    4  0
d w_spge          s    4  0
d w_srrn          s    4  0
d w_sfrn          s    4  0
d w_ssrn          s    4  0
d w_seqe          s    1
d b_valg_ok       s    1    inz(*off)
d w_firm          s    like(racfir)
d c_sfil          s    2  0 inz(8)
```
- These are counters, pointers, and state flags for handling the subfile records, page sizes, and user selection.

### Field Roles

The comments explain the intent of fields, especially for subfile navigation:
- `w_stel`: Subfile counter
- `w_spge`: Subfile (page) size
- `w_srrn`: Current relative record number in subfile
- `w_sfrn`: First record number displayed in a page
- `w_ssrn`: Last record number displayed on page

### Indicators

The program uses RPG indicators (`*inxx`) for various UI and logic triggers, such as function keys (roll, rolldown, home, etc.), error signaling, and subfile control.

---

## 3. Screen Layouts

Screen formats mentioned:
- `B1SFL`: Subfile record
- `B2CTL`: Subfile control record
- `B2CMD`: Special command key screen

---

## 4. Main Program Flow

The program utilizes tags (`tag`) and `goto` statements to mimic a procedural UI loop typical in RPG/400 code.

### Main loop tags:

- `b2taga`: Display command key screen (`write b2cmd`)
- `b2tagb`: Display and manage the subfile (`exsr dsp_subfile`)
- Handles logic after displaying, including navigation, function key handling, and exiting (`goto avslutt`).

#### Function key handling (within `select`):
- Exit on specific function keys.
- Refresh or rebuild subfile on others.
- Navigate forward/backward in subfile.
- Cursor home handling.

### Positioning:

If search/positioning fields (`b2ckod`, `b2ctxt`) are set, the program seeks to a keyed position before continuing.

### Subfile Management:

1. **Subfile handling (`exsr subfile`):** Responds to user actions within subfile.
2. **End program (`goto avslutt`):** Sets Last Record (`*inlr = *on`) and returns.

---

## 5. Subroutines

### Subfile Manipulation

#### `forny` – Renew subfile
- Optionally chains to a subfile record to reposition.
- Based on the sequence (`w_seqe`), sets the read position using the proper key.
- Clears and recreates the subfile window for current positioning.

#### `posisjoner` – Positioning subfile
- If payment code (`b2ckod`), seeks that code in the file and sets sequence.
- If description (`b2ctxt`), seeks on description and sets sequence 'B'.
- Clears and refills the subfile.
- Blanks positioning fields after use.

#### `subfile` – Handles subfile input
- Toggles an indicator for cursor placement.
- Reads through visible subfile records via `readc`.
- Detects selection (`b1valg = 1`) and updates parameters, sets selection-ok flag to end the program.

#### `clr_subfile` – Clear subfile
- Turns on indicator to clear subfile and writes control record to display.
- Resets all subfile counters and positions.

#### `crt_subfile` – Create/fill subfile
- Fills the subfile up to the current page size.
- Reads from one of two files depending on sequence type.
- Stops if end-of-file or wrong company.
- Increments subfile counters.
- Writes record to the subfile display.
- Updates subfile page boundaries.

#### `bck_subfile` – Page backward in subfile
- Goes backwards from the current position by page size, reading records in reverse.
- Seeks back to the correct file and fills the subfile.

#### `dsp_subfile` – Display subfile page
- Sets indicators for display, writes or formats the control record depending on subfile state.

---

### Initialization (`*inzsr`)
- Reads parameters and initializes variables.
- Sets company key and positions to the beginning of the relevant file.
- Fills the initial subfile.

---

## 6. Notes on Subfile Technique and UI

- The code uses a standard IBM i subfile pattern: clear (`clr_subfile`), fill (`crt_subfile`), display (`dsp_subfile`), and handle user keys.
- The program supports forward and backward paging, record selection, and positioning either by code or by description.
- Indicators are heavily used for user interaction, navigation, and controlling screen state.

---

## 7. User Experience

1. **Start:** User sees a list of payment terms in a subfile.
2. **Navigation:** Use function keys to scroll pages, position by code or description, select a term, or exit.
3. **Selection:** When a record is selected (`b1valg=1`), result parameters are set and the program ends.

---

## 8. Summary

- **Purpose:** Query and select payment terms, supporting search and navigation.
- **UI:** Subfile with forward/backward paging, positioning, and selection.
- **Data:** Driven by files keyed on company, code, or description.
- **Structure:** Classic RPG with subroutines, indicators, and D-specs for clarity and modularity.

---

### **If you are onboarding to this code:**
- Understand the subfile structure in the display file (`fra503d`).
- Follow the subroutines for subfile manipulation and screen logic.
- Familiarize with the use of indicators for UI navigation.
- Recognize entry parameters, how search/positioning is performed, and how user selection is handled.

If you have more specific questions about any part, please ask!