# Overview

This program (ZI110R) calculates suggested or “marked up” prices for items, focusing on enhanced product price lookups, cost calculations, and storing the results for further processing. It appears to be part of a larger order registration or pricing system for a business domain that includes customer data, item data, multiple item units, and a variety of markup rules. It currently applies primarily to items belonging to a specific entity called “EVR.”

## Key Responsibilities

1. **Obtaining Base and Cost Prices:**  
   - Calls external programs (e.g., VP715R and VP701R) to retrieve three tiers of base selling prices (for up to three different item units) and corresponding cost prices.
   - Determines the correct “prisgruppe” (pricing group) by calling VL712R.

2. **Applying Markup Factors (“Påslagsfaktorer”):**  
   - If direct price records are not found, the program looks up markup factors from several files (zpfai2, zpfai3, zpfai4, zpfai5), each representing different levels of detail (supplier, module, hierarchies like overgruppe/hovedgruppe/undergruppe).
   - If no specific factors are found, the program defaults markup factors to 1, effectively meaning no markup adjustment beyond the base or cost price.

3. **Storing & Updating Calculated Prices:**  
   - Uses a “Zilliant” table (zkapiu) to store or update the final prices for each (customer + order + item + unit) combination.
   - Subroutines “lag_zilliant” and “lag_zilliant2” handle the creation or update of these records, timestamping them, and storing user identification data.

## Structure & Flow

### 1. Initialization  
The program begins by reading parameters such as customer number (`p_kund`), order number (`p_ordr`), warehouse (`p_lage`), division/department (`p_avde`), item ID (`p_vare`), and unit of measure (`p_enhe`). It then sets up keys for file lookups and prepares to retrieve data:

- “VVARL1” (item master) is read to ensure the item is valid.  
- If a customer number is passed in, “ZKUNI1” is read to confirm the customer’s existence.  
- Department group data is retrieved from “ZAGRI1.”

### 2. Determine Pricing Group  
The subroutine “finn_prisgr” calls program VL712R to find the pricing group (`w_prgr`) based on the firm, warehouse, and department.

### 3. Retrieve Base Selling Prices  
The subroutine “finn_priser” calls program VP715R to collect up to three sets of selling prices (w_sap1, w_sap2, w_sap3) corresponding to three possible units of measure (w_enh1, w_enh2, w_enh3). It then calls program VP701R for each unit to obtain cost prices (w_kop1, w_kop2, w_kop3).

### 4. Check Direct Price Records  
The subroutine “vare_pris” attempts to find an exact price record in file “ZVPRI1” for the current item, unit, and department group. It first tries the actual department group, then falls back to department group zero. If found, prices are retrieved; otherwise, the program defers to calculating markup factors.

### 5. Calculate Markup Factors  
The subroutine “hent_pasl” uses a multi-step search across zpfai2, zpfai3, zpfai4, and zpfai5 files to locate a matching set of factors (zcstfa, zctgfa, zcflfa). These files represent different combinations of supplier (“leverandør”), module (“modul”), and hierarchical groupings.  
The search sequence:
1. Supplier + module + department group  
2. Module + department group  
3. Overgruppe/hovedgruppe/undergruppe + supplier  
4. Overgruppe/hovedgruppe + supplier  
5. Overgruppe + supplier  
6. Only supplier  
7. Overgruppe/hovedgruppe/undergruppe  
8. Overgruppe/hovedgruppe  
9. Overgruppe  
If none are found, all factors default to 1.

### 6. Final Price Calculation & Storage  
After either finding a direct price or applying markup factors to the cost price, the program populates items in zkapiu (the “Zilliant” table), using subroutines “lag_zilliant” or “lag_zilliant2.” The difference between these subroutines is that “lag_zilliant” updates existing table rows or writes a new one, while “lag_zilliant2” seems to only write a new record if none exists (acting as a secondary check for missed combinations).

### 7. Cleanup  
The label “avslutt” sets on LR (*INLR) to end the program.

## Notable Design Choices

- **Multi-Unit Logic:**  
  The program explicitly handles up to three units of measure for a single item, which suggests a business need for flexibly pricing items sold in various pack sizes or packaging types.

- **Fallback Markup Structure:**  
  The tiered lookup of markup factors (zpfai2 to zpfai5) is indicative of a robust fallback system. The hierarchy implies that if a specific combination of supplier/module/group is not found, the program steps back to broader groupings before defaulting to a factor of 1.

- **Zilliant Table (zkapiu):**  
  The “Zilliant” references may be an external or third-party pricing analytics system, or simply an internal naming convention. The set of fields (like zxstpr, zxtgpr, zxflpr) record the final price calculations and markup-based pricing distinctions.

- **Separated External Calls:**  
  - “VL712R” is used to determine an item’s pricing group.  
  - “VP715R” retrieves selling prices.  
  - “VP701R” retrieves cost prices.  

  These external calls keep the code modular, offloading specific retrieval logic to dedicated programs.

### Business Use Case

Overall, ZI110R orchestrates the retrieval of base cost/sell prices from multiple sources, applies layered markup rules, and stores final price data for later use in order processing, reporting, or price analytics. This design is typical in systems handling complex pricing structures with multiple fallback strategies when exact matches are not found.