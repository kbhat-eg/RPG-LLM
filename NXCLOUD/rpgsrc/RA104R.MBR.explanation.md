# RPG Program RA104R — Onboarding Explanation

This program is a traditional IBM ILE RPG application designed for maintaining company-specific accounting codes (faste konti). It's designed with a set of screen/display files, database files, and several external calls to other programs in the application suite. Most comments are in Norwegian, but the logic is clear and systematic.

Below is a structured overview to help a developer onboard to this code.

---

## High-level Purpose

- **Goal**: The program is a maintenance application to update and validate fixed account settings related to VAT, customers, suppliers, bank, cash, and other accounting concepts for a company.
- **Workflow**: Presents a screen to the user for input/editing, allows "drill-down" or lookup via function keys, validates input, and then updates a master records file with the new/changed codes.

---

## Main Structures

### 1. **H Spec**

```rpg
h datedit(*dmy) option(*nodebugio)
```
- Sets the default date format to DMY (day/month/year).
- Disables debugger breakpoints for input/output operations.

---

### 2. **File Declarations**

```rpg
fra04l1    if   e           k disk    rename(ra04pfr:ra04l1r)
fra04lu    uf a e           k disk    rename(ra04pfr:ra04lur)
frkunlr    if   e           k disk    rename(rkunpfr:rkunlrr)
frlevlr    if   e           k disk    rename(rlevpfr:rlevlrr)
f**rprolr    if   e           k disk    rename(rpropfr:rprolrr)
fra104d    cf   e             workstn
```
- `fra04l1`/`fra04lu`: Master and update logical files for fixed account codes.
- `frkunlr`/`frlevlr`: Customer and supplier master files for validation/lookups.
- `rprolr` (commented): Project file.
- `fra104d`: Workstation display file (for presenting the maintenance screen/form).

---

### 3. **Data Definitions**

- Many `d` specifications for local variables, working fields, and transfer parameters.
- Examples: user id (`l_user`), firm number (`l_firm`), account keys, descriptions, screen field variables (e.g., `a2da01`, `a2dk01`, etc.), and variables for various functions (e.g., `wwtext`, `wwtex2`, etc.).

---

### 4. **Indicator Usage**

A long comment block defines indicator conventions, e.g.:
- 30 = protect fields on display
- 31–59, 62–69 = error/warning indicators
- 60–61 = file indicators
- 70–99 = working indicators (subroutines, etc.)

You will see many `*inNN` (indicator) variables used for screen control and error/warning handling.

---

### 5. **Main Processing Logic**

#### **Initialization** (`*inzsr`)

- Blanks out working text fields.
- Copies firm/user input parameters into local variables.
- Loads existing account setup from the master file into the corresponding working variables (`a2da01`, `a2dk01`, ...).

#### **Main Loop**

- Controlled via `exfmt a2bld` (exchange field format): Shows the maintenance screen, handles user input, and returns.
- Processing is organized as a perpetual loop, where navigation or update actions depend on user key or field selection.

#### **Field Drill-down and Lookup**

- For each key field (identified by `w_afld` = field id, such as `A2DK01`, `A2DA01`, etc.), the program checks for edit mode and calls:
    - **`RA107R`** for department/avdeling lookups
    - **`RH500R`** for account/konto lookups

- Parameters are transferred to the called program, and if the user selects a value, it’s transferred back to populate the relevant screen fields.

---

### 6. **Validation Logic**

After user editing, before update:

For each code set (as per field ids), validation is performed:

- Calls **`RS740R`** with the account, specification, and department.
- Receives `p_stat` indicating validation result:
    - `'A'` = department doesn't exist
    - `'N'` = account doesn't exist
    - `'S'` = account is blocked
    - `'M'` = department entered, but account required
    - `'K'` = specification entered, but account required
- Sets corresponding indicators for error display and returns to the screen if validation fails.

---

### 7. **Database Update**

- After passing all validations, the program updates (or inserts) the codes into the update file (`ra04lu`), copying all working variables to their respective database fields.
- Uses `chain` to find if the record exists; if yes, `update`, else `write`.

---

### 8. **Program Exit**

- Handles function key exit (`F3`, `F12`) with:
    ```rpg
    *inkc         cabeq     *on           xslutt
    *inkl         cabeq     *on           xslutt
    ```
- Turns on LR indicator (`*inlr`), causing program termination.

---

### 9. **Appendix: Key Lists for Files**

- `klist` blocks define composite keys for lookup files (used for `chain` operations).

---

## Typical Program Flow

1. **Initialize fields and load any existing data for the current firm**
2. **Present the screen to the user**
3. **If a lookup is requested (function key/field activation), call the appropriate program for selection/validation**
4. **Validate all fields before saving**
5. **Show messages if validation fails and return to the screen**
6. **If validation passes, update/insert the record**
7. **If exit key pressed, end the program**

---

## Summary Table for Field-Purpose Mapping

| Field             | Description / Purpose               | Related Programs Called        |
|-------------------|------------------------------------|-------------------------------|
| a2da01/dk01/ds01  | Outgoing VAT account details        | RH500R, RS740R                |
| a2da02/dk02/ds02  | Incoming VAT account details        | RH500R, RS740R                |
| a2da04/dk04/ds04  | Tax chief                          | RH500R, RS740R                |
| a2da05/dk05/ds05  | Customer accounts                   | RH500R, RS740R                |
| ...               | ...                                | ...                           |
| a2da20/dk20/ds20  | Payment fees                        | RH500R, RS740R                |
| a2da21/dk21/ds21  | Interim account                     | RH500R, RS740R                |

---

## Subroutine Initialization (*inzsr)

- Prepares the program, loads parameters, and sets up file keys for subsequent `chain` operations.

---

## Key Points for New Developers

- **Screen/field navigation is handled by checking `w_afld` and calling appropriate subprograms.**
- **Validation is centralized through calls to `RS740R`, and the outcome controls error messaging and flow.**
- **Indicators (`*inNN`) are crucial for screen field control and message display.**
- **The code pattern for all fields (accounts/departments/specs) is very similar, facilitating extensions or modifications.**
- **All actual updates occur only after a successful validation pass.**
- **All comments and messages use Norwegian accounting/business terminology.**

---

## Final Words

This program follows classic, readable, and highly structured RPG logic. While the code is lengthy due to its repetitive nature, the overall pattern is straightforward. You can easily extend it for more code-sets or adapt validation to new business rules by replicating/copying existing code blocks.

If maintaining or enhancing this code, focus on:
- Keeping the indicator use consistent
- Reusing the validation pattern
- Keeping new fields in sync across initialization, validation, screen, and update sections

---

**Tip:** Refactoring opportunities exist (especially with subprocedures or data structures) if you want to move to a more modern RPG IV style, but as written, the structure is solid and clear.