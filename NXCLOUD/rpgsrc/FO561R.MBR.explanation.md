```markdown
# Program fo561R – “Liste/hull i nummerserie”

## 1. Overview
This RPGLE program scans a range of document numbers (`p_fnum` through `p_tnum`) for a given financial year (`p_aarr`) and prints out any “holes” – numbers with no corresponding invoice record in the history file, active orders file or deleted-orders file.

– Input parameters:
  - `p_aarr`: Accounting year  
  - `p_fnum`: From document number  
  - `p_tnum`: To document number  

– Output: Printer file (`ffo561p`) with header (“skriv_hdr”) and detail lines (“skriv_mangel”).

---

## 2. File Declarations

- **sohel1r** (alias for `sohepf`): Historical invoice header file  
- **fohel1r** (alias for `fohepf`): Active order header file  
- **fdell3r** (alias for `fdelpfr`): Deleted-order file  
- **ffo561p**: Printer file for report output  

Each input file is declared as keyed-disk (`K Disk`) and externally described.

---

## 3. Data Definitions

### 3.1 Parameters (Prototype)
```rpg
D p_aarr      S   like(soaarr)   ← Accounting year
D p_fnum      S   like(sonumm)   ← From document number
D p_tnum      S   like(sonumm)   ← To   document number
```

### 3.2 Working Variables
```rpg
D w_firm      S   like(sofirm)   ← Company code (from LDA)
D w_aarr      S   like(soaarr)   ← Working accounting year
D w_fnum      S   like(sonumm)   ← Working current number
D w_tnum      S   like(sonumm)   ← Working last number
D w_tell      S   like(sonumm)   ← Loop counter
D b_funn      S   1 inz(*off)    ← Found-flag (*on if record exists)
```

### 3.3 Local Data Area (LDA)
```rpg
D l_firm      944 946 0         ← Company code from LDA
D l_fnav      951 980           ← User name field from LDA
```

### 3.4 Key Variables for File Access
```rpg
D fohel1_numm  S   like(fonumm)  ← Key for active orders
D fdell3_numm  S   like(fynumm)  ← Key for deleted orders
```

---

## 4. SQL Date Format Setting

```rpg
/EXEC SQL
  Set Option DatFmt=*ISO
/END-EXEC
```
Sets the embedded SQL date format to ISO.

---

## 5. Main Procedure Flow

1. **skriv_hdr**  
   – Write initial report header (page heading).  
2. **les**  
   – Enter the main loop that checks each document number.  
3. **avslutt**  
   – Set *INLR = *ON and return (end-of-program).

---

## 6. Subroutine: les (Loop Through Numbers)

```rpg
begsr les;
  exsr skriv_hdr;                ← Print header on first call
  eval w_tell = w_fnum;          ← Initialize loop counter

  dow w_tell < w_tnum;
    exsr les_hist;               ← Check history file
    if b_funn = *off;
      exsr les_ordre;            ← Check active orders file
      if b_funn = *off;
        exsr les_slet;           ← Check deleted orders file
      endif;
    endif;

    if b_funn = *off;
      exsr skriv_mangel;         ← If still not found, print detail line
    endif;

    eval w_tell += 1;             ← Next number
  enddo;
endsr;
```

- Resets `b_funn` before each lookup chain.
- If **none** of the three lookups finds a record, the number is missing → `skriv_mangel`.

---

## 7. Subroutine: les_hist (Historical Invoices via SQL)

```rpg
begsr les_hist;
  exec sql
    declare sok_h cursor for
    select sofirm, sonumm, soaarr
      from sohepf
      where sobinr = :w_tell
        and sofirm = :w_firm
        and soaarr > :w_aarr
      for read only;

  exec sql close sok_h;
  exec sql open sok_h;
  exec sql fetch next from sok_h
    into :sofirm, :sonumm, :soaarr;

  if sqlcod = 100;              ← No data found
    leavesr;
  endif;

  if sofirm <> w_firm;          ← Safety check
    leavesr;
  endif;

  eval b_funn = *on;            ← Record exists
endsr;
```

- Uses **embedded SQL** to find any invoice with `sobinr = w_tell`.
- If fetch returns no rows (`sqlcod = 100`), leave → not found.
- Otherwise set `b_funn = *on`.

---

## 8. Subroutine: les_ordre (Active Orders via CHAIN)

```rpg
begsr les_ordre;
  eval fohel1_numm = w_tell;
  chain fohel1;                 ← Keyed read on fohel1r
  if %found(fohel1);
    eval b_funn = *on;
  endif;
endsr;
```

- `CHAIN` on the composite key (`w_firm`, `fohel1_numm`).
- If found, mark `b_funn = *on`.

---

## 9. Subroutine: les_slet (Deleted Orders via SETLL/READE)

```rpg
begsr les_slet;
  eval fdell3_numm = w_tell;
  setll fdell3;                 ← Position at key
  reade fdell3;                 ← Read first equal
  dow not %eof(fdell3);
    if fyaarr >= w_aarr;        ← Year check
      eval b_funn = *on;
      leavesr;
    endif;
    reade fdell3;
  enddo;
endsr;
```

- Scans all deleted lines with number = `w_tell`.
- If any record’s year ≥ `w_aarr`, it’s considered found.

---

## 10. Subroutine: skriv_mangel (Write Missing Number)

```rpg
begsr skriv_mangel;
  eval(h) d1numm = w_tell;      ← Assign detail format field
  write d1det 30;               ← Write detail line, check overflow
  if *in30 = *on;
    exsr skriv_hdr;             ← New page header if overflow
  endif;
endsr;
```

- Prints a detail line (`d1det`) with the missing number.
- If page overflow indicator `*IN30` is on, call `skriv_hdr` again.

---

## 11. Subroutine: skriv_hdr (Report Header)

```rpg
begsr skriv_hdr;
  write a1hdr 30;               ← Print header record
endsr;
```

- Simple one-record header format (`a1hdr`) with page breaks at indicator 30.

---

## 12. Subroutine: *inzsr (Initialization)

```rpg
begsr *inzsr;
  *entry plist;
    parm p_aarr;
    parm p_fnum;
    parm p_tnum;

  // Prepare keyed access lists
  fdell3_key klist;
    kfld w_firm;
    kfld fdell3_numm;
  fohel1_key klist;
    kfld w_firm;
    kfld fohel1_numm;

  // Initialize working variables
  eval w_aarr = p_aarr;
  eval w_fnum = p_fnum;
  eval w_tnum = p_tnum;
  eval w_firm = l_firm;

  // Copy for header printing
  eval a1aarr = p_aarr;
  eval a1fnum = p_fnum;
  eval a1tnum = p_tnum;
endsr;
```

- Sets up file access keys and moves incoming parameters into working fields.
- LDA field `l_firm` provides the company code.
```