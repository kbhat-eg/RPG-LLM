# RPG Code Explanation: SP126R – "Utvalg Selger kasse" (Selection Seller Cash Register)

This RPG program is designed for ASSTAT (possibly a statistics/reporting system), specifically for selecting or maintaining entries (likely sellers, as "Selger" is Norwegian for "seller") in a cash register scenario, using subfiles in a display file.

## Structure Overview

- **Data Definitions**: Variables, constants, and file definitions.
- **Mainline logic**: Loop managing screen flow, subfile operations, command key handling, and selection.
- **Subroutines**: For all core actions (opening, positioning, subfile handling, record creation, editing, deletion, and validation).

---

## File Definitions

```rpg
fsp126d    cf   e             workstn sfile(b1sfl:w_srrn)
fskpml1    if   e           k disk    rename(skpmpfr:skpml1r)
fskpmlr    if   e           k disk    rename(skpmpfr:skpmlrr)
fskpmlu    uf a e           k disk    rename(skpmpfr:skpmlur)
fra09l1    if   e           k disk    rename(ra09pfr:ra09l1r)
```

- `fsp126d`: Display device file, with subfile support.
- `fskpml1`, `fskpmlr`, `fskpmlu`: Disk files, all referencing the same physical file with different record formats (likely for different access purposes: list, read, update).
- `fra09l1`: Another database file used for code validation.

---

## Key Variables

- Many variables relate to keys for database access (`skpml1_type`, `skpml1_kode`, etc.), mirroring the keys used on the files.
- Subfile management variables:  
  - `w_srrn`: subfile relative record number (RRN, tracks current position)
  - `w_sfrn`, `w_ssrn`: for subfile first and last record numbers
  - `w_spge`, `c_sfil`: for subfile page handling (page size)
  - `b_forn`, `b_anul`, `b_feil`: boolean flags

---

## Local Data Area (LDA) Usage

The program accesses user, company, and company name from the LDA (positions 911–980).  
- `dsuser`, `dsfirm`, `dsnavn`: User/firm context for restricting/filtering data.

---

## Mainline Logic

The mainline is essentially an event loop driving application flow, awaiting user actions on the display:

1. **Initial Display**:  
   - Tag `b2taga` writes the main command screen.
2. **Display Subfile**:  
   - Tag `b2tagb` calls `dsp_subfile` subroutine to display the subfile of records.

3. **Function Key Handling**:  
   Depending on the pressed key (`*INKC`, `*INKL`, etc.):
   - Exit (`goto avslutt`)
   - Refresh (`exsr forny`)
   - Create new record (`exsr xc1bld`)
   - Display more (`exsr crt_subfile`)
   - Page up/down logic

4. **Positioning Logic**:  
   If a position field is used (e.g., jumping to a record using a key), the `posisjoner` subroutine is called.

5. **Subfile Record Action**:  
   If a subfile record is selected for action, `control` determines what to do (add, delete, validate).

6. **Subfile Processing**:  
   Calls `subfile` to process row-level actions (such as deleting a single row), then loops back to main display.

---

## Key Subroutines

### forny (Refresh Subfile)

- Clears and rebuilds the subfile from file(s) after moving the internal pointer (`setll`).

---

### posisjoner (Position to Record)

- Sets up subfile for positioning to a specific entry (reads user-entered key, positions database, clears and rebuilds the subfile, blanks positional fields).

---

### control (Handle Subfile Control Actions)

- Determines if user wants to add (`'1'`) or delete (`'4'`) a record, or just validate, and dispatches accordingly.

---

### subfile (Handle Subfile Row Actions)

- Loops over current subfile display (`readc` to read changed records).
- Processes actions (e.g., delete a selected row), flags for refresh if changes occurred.

---

### xc1bld (Handle Adding or Editing a Record)

- Displays the add/edit screen.
- Handles validation:  
  - Checks for duplicate keys (if found: shows a message via `xc1msg`, can abort).
  - Validates against code tables (`ra09l1`).
  - Calls `xc2bld` to actually update/write the record.

---

### xc1msg (Message if Record Exists)

- Displays an info message if user tries to add an existing record, lets user cancel.

---

### xc2bld (Add/Change/View Record)

- Presents the edit/add screen.
- Handles three scenarios:  
  - If record exists, prepares for update.
  - If not, prepares for addition.
- Updates or writes record as appropriate.
- Refreshes subfile if needed.

---

### xd1win (Handle Delete Confirmation)

- Displays delete confirmation window.
- If confirmed, deletes the corresponding record from the database, flags for a subfile refresh.

---

### clr_subfile (Clear Subfile)

- Clears out the subfile and resets paging variables.

---

### crt_subfile (Build/Fill Subfile)

- Reads from main data file, filling the subfile buffer (page-sized).
- Stops if end of data or filtering rules break.

---

### dsp_subfile (Display Subfile)

- Displays the subfile screen, setting indicators for page/scrolling options, writing to display as needed.

---

### *INZSR (Initialization Subroutine)

- Defines all needed keys for file operations.
- Reads program parameters (from calling program) into working variables.
- Initializes display fields.
- Sets up subfile with the first page of records.

---

## Indicator Usage

- `*INxx` are standard RPG indicators (booleans affecting flow and display logic).
- `*INLR` is the "last record" indicator (turns on program end/return).
- Used for function key handling, screen field hiding/showing, error messages, etc.

---

## Business Flow

1. **Startup:**  
   - Program initializes, loads company/user context and builds subfile of sellers for current company/type.

2. **User Interacts with Subfile:**  
   - Can scroll, select, add, edit, or delete sellers based on commands.

3. **Validation and Confirmation:**  
   - System checks for duplicates, validates codes, confirms deletes.

4. **Data Integrity:**  
   - Ensures only valid and unique records are added; deleted records are confirmed by the user.

5. **Exit:**  
   - User can exit via function keys, program cleans up.

---

## Key Takeaways for New Developers

- **Subfile Logic**: The heart of the program revolves around subfiles for displaying and editing lists of entries in a page-at-a-time fashion.
- **Separation of Concerns**: Each user action/command is handled in its own subroutine, keeping logic modular.
- **Record Locking/Chaining**: Uses RPG file operations such as CHAIN, SETLL, READ, DELETE, UPDATE, and WRITE for manipulating records.
- **Validation**: Both internal (existing records) and external (code tables) validation is present.
- **Norwegian Language**: Field names and comments are mostly Norwegian; "valg" means "choice", "kode" is "code", "forny" is "refresh", etc.
- **Indicators**: Many display and logic fields depend on setting/resetting indicators.

---

## Typical Modifications

- **Adding new selection/filtering**: Add logic where records are read into the subfile.
- **Changing subfile layout**: Would involve updating display file and corresponding record field mapping.
- **Adding new commands**: Extend the function key handling `SELECT` blocks and add supporting subroutines.

---

## Additional Notes

- This is a classic RPG/400 (fixed-format C-spec) program, not RPG IV/free-format.
- The approach is typical for legacy IBM i applications with subfile-based maintenance programs.
- For onboarding, focus on understanding the subfile record flow and the subroutine dispatch pattern.
- If you need to debug or extend, be very careful with indicators and record formats—they control both file access and front-end display logic.

---

**In short, this program implements an interactive subfile-driven maintenance screen for seller records, handles all the CRUD (Create, Read, Update, Delete) operations, and ensures data is always consistent and validated.**