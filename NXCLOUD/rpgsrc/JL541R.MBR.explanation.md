# RPG Program JL541R – Overview and Explanation

This RPG/400 (ILE RPG) code is for an IBM i (AS/400) system application, specifically a maintenance and reporting program for suppliers (“leverandør”) and their product data, with a focus on integration to something called “EVR” (likely an internal inventory or product system).

## Purpose

**JL541R** provides a screen-based (workstation) interface with subfiles to browse, query, and operate on suppliers and their product history. It supports various advanced features such as showing suppliers with products in EVR, showing price changes, new & deleted products, and linking to other programs for further actions.

---

## 1. **Header and Revision History**

- **h option(*nodebugio) datedit(*dmy):**
  - Disables I/O debugging.
  - Uses DD/MM/YY format for date editing.

- **Revision comments**: The commented section details a change log, listing enhancements and bug fixes, such as expanded price group, improved supplier/product filtering, and SQL adaptations for OS/400 upgrades.

---

## 2. **Physical & Logical File Definitions**

- Files (`fjlevl1`, `fjlevl2`, etc.) are declared, mostly as keyed disk files (logical files), often renamed from physicals (e.g., `jlevpfr:jlevl1r`).
- Display file (`fjl541d`) is declared as a WORKSTN (workstation) file, using a subfile (SFILE) for interactive lists.

---

## 3. **Key Data Areas, Structures, and Variables**

### Parameters

- `p_firm`: Company number.
- `p_dato`: Work date.
- `p_kevr`: Filter – only suppliers with products in EVR.
- `p_kpri`: Filter – only suppliers with price changes.

### Local Data Area / Information Data Structures

- Standard system fields for LDA, feedback info (used for display positioning, error handling, etc.).

### Key Variables

- Used to build file keys for setll/read/chain operations on the various files, e.g., `jlevl1_ldor`, `jlevl2_navn`.

### Working Variables

- Subfile state (`w_fcrn`, `w_stel`, etc.).
- Loop and filter controls.
- Counters for price changes, products added/deleted, etc.

### Constants

- e.g., `c_sfil` = 11, defines page size for subfile.

---

## 4. **Indicator Usage**

Extensive use of RPG indicators (`*INnn`) for UI logic:
- `*InLR`: End of program.
- `*In10`: Rollup, etc. (see comments for full meaning).

---

## 5. **SQL Compatibility**

- Conditional SQL options for date formatting, language, etc. used for some versions/upgrades (`C/Exec SQL`).

---

## 6. **Main Program Logic**

### Main Loop (`b2taga` / `b2tagb`)

- Handles main screen display and user input via WRITE/EXFMT to main subfile control screens (`b2ctl`, `b2cmd`).
- Calls subroutines based on function keys (e.g., for “next page”, “previous page”, “refresh”, etc.).
- Handles positioning in subfile (by supplier name or number).
- Options for various actions through subfile "valg" fields, which trigger calls to other programs or open detailed screens.

### Subfile Operations

#### `forny` – Refresh Subfile

- Repositions to the correct record.
- Calls routines to clear and refill subfile.

#### `posisjoner` – Position by Name/Number

- Allows the user to enter a name or number to position the list.
- Updates subfile accordingly.

#### `subfile` – Main Subfile Loop

- Reads and processes subfile lines for user actions (selected by input field `b1valg`). 
- Handles direct calls to other programs for actions like:
  - Update prices (`JV125R`)
  - Create new products (`JV120R`)
  - Show price changes (`JV541R`)
  - Show new products (`JV540R`)
  - Show deleted products (`JV180R`)
  - and others.

- For special 'valg' options, updates relevant counters, refreshes dates, updates the record as needed.

### Subfile Page Handling

#### `clr_subfile` – Clear Subfile

- Sets indicator for subfile clear.
- Resets page counters.

#### `crt_subfile` – Create/Refill Subfile

- Pages through supplier list, reads relevant files.
- Applies filters (EVR, price changes, assortment code).
- Builds counters for price changes, new, deleted products by looping through linked files.
- Writes each passing supplier to the subfile.

#### `bck_subfile` – Page Back

- Similar to `crt_subfile` but reads backward for previous subfile page.

### Display Handling

#### `dsp_subfile` – Display Subfile

- If there are entries, shows subfile; otherwise, writes a command screen.
- Updates current record pointer for feedback.

---

## 7. **Supporting Subroutines**

#### `hent_prisdato` – Get Oldest/Newest Price Date

- Loops through relevant product price records in EVR for the current supplier to find the earliest/latest price date.

#### `hent_slettet` – Get Count of Deleted Products

- Loops through relevant deletion records (using logical and physical files) to count deleted products for current supplier, checking additional filtering (e.g., assortment code).

#### `sjekk_evr` – Check Price Changes in EVR

- Looks for price change records matching search criteria, increments counters, and flags main-supplier when relevant.

#### `sjekk_sort` – Check Assortment Filter

- Checks if assortment filter is applied and if current item matches filter. Uses chain on product master file to verify.

#### `vare_sort` – Go To Product With Assortment Query

- Calls another program for querying all products for a given assortment code.

#### `spørring` – Assortment Query Helper

- If the field for assortment code is active, calls a program to assist in picking a value.

---

## 8. **Initialization**

#### `*inzsr` – Initialization Subroutine

- Parameter list, key list initialization, etc.
- Reads starting positions and fills up the subfile with the first page of suppliers.

---

# Key Concepts & Onboarding Takeaways

- **Subfile-Driven UI**: The program is a display-file driven application, where the subfile is the centerpiece for listing and selecting suppliers, and all actions are channelled via subfile options or function keys.
  
- **Indicator-Based Flow**: Uses many RPG indicators for logic branching — ensure you understand/read the indicator map in the comments.

- **File Architecture**: Know your logical and physical files. Many actions rely on correctly navigating keyed accesses across files like JLEVL1 (supplier master?), JVARL1 (product master?), and the price/deletion transaction logs.

- **External Program Calls**: Several actions spawn other programs for specialized functions, passing parameters as needed.

- **Dynamic Filtering**: Filters can be set for suppliers with EVR items, only those with price changes, and by assortment codes.

- **Counters**: Counts for price changes, new, deleted, released products are calculated dynamically as subfiles are built.

- **Version-Sensitive SQL**: Some SQL code is present but commented out, suggesting that, depending on the system version/deployment, either native I/O or SQL is (or was) used for certain operations.

---

# Focus Areas for New Developers

- **Understand the Subfile Pattern**: This is classic RPG for subfile-driven lists and option selection.
- **Learn the Data Model**: Study how supplier and product data interrelate, especially how the various files serve different roles (master, price, deletion, EVR).
- **Indicator Usage**: Master how `*inxx` indicators are used for both display and logic flow.
- **Be Mindful of Filters**: The set of filters on supplier lists and products is complex; test any changes carefully.
- **Program Integration**: This program is part of a suite – know which called programs handle which parts so you can troubleshoot or enhance end-to-end flows.
- **Legacy vs. Modern**: Some parts (SQL vs. native) may need modernization or might need to be adapted for new backends.

---

## Useful for: 

- Training new developers on traditional RPG, especially subfile applications.
- Maintenance/bugfixes in enterprise supplier/product systems.
- Extending logic for new subfile actions or reporting columns.

---

**Tip:** To make changes or debug, start with understanding the subfile page handling (`crt_subfile`, `clr_subfile`), and follow the `b1valg` values through the main subfile loop as this triggers the main business logic and integration points.