# Explanation of RPG Source Code: Slette poster i fra rtrapf

This RPG/400 (also known as RPG III or RPG/ILE in fixed format) program is designed to **delete records from the database file `RTRXL2`** based on input selection criteria. The program uses standard RPG cycle and fixed format coding style, and some debug output is commented out.

Below is a breakdown of the code's logic and structure:

---

## 1. Heading and Comments

```rpg
/TITLE         Slette poster i fra rtrapf
* 6.11      211111  Slett av poster i RTRXL2                        NHO *
```
- Program title and some auditing/versioning comments.
- "Slette poster" means "Delete records" (Norwegian).

---

## 2. File Declarations

```rpg
frtrxl2    uf   e           k disk
f**sfdebug   o    f  128        disk
```
- `frtrxl2` is declared as an update-capable, externally-described, keyed disk file.
- (Commented out) `sfdebug` is an output file for debugging purposes.

---

## 3. Data and Field Declarations

```rpg
d rtrxl2_firm     s                   like(rx1fir)
d rtrxl2_memb     s             10
d rtrxl2_bunt     s              5  0
d w_bunt          s              5  0
d w_memb          s             10
d                uds
d l_firm                944    946  0
```
- `rtrxl2_firm`, `rtrxl2_memb`, `rtrxl2_bunt`: Key fields for file `RTRXL2`. 
- These may be mapped to the file's key structure.
- `w_bunt`, `w_memb`: Work variables, probably hold input key values.
- `l_firm`: "Local" firm variable; storage overlap at positions 944-946 (from data structure), possibly from a larger structure header.

---

## 4. Key List Declaration

```rpg
c     rtrxl2_key    klist
c                   kfld                    rtrxl2_memb
c                   kfld                    rtrxl2_firm
c                   kfld                    rtrxl2_bunt
```
- Defines a **key list** (`rtrxl2_key`) used for SETLL (Set Lower Limit) and file positioning.
- The key fields are `memb`, `firm`, and `bunt`.

---

## 5. Main Logic

### Position File and Start Loop

```rpg
c     rtrxl2_key    setll     rtrxl2
c     start         tag
c                   read      rtrxl2                                 15
```
- Positions file at the start key.
- Reads the record; if EOF, indicator 15 is set.

---

### End-of-File and Firm Check

```rpg
c                   if        *in15 = *on
c                   goto      slutt
c                   end

c                   if        rx1fir <> l_firm
c                   goto      slutt
c                   endif
```
- If EOF (`*IN15` is *on), jump to end (`slutt`).
- If the firm's field of the current record does **not** match the local firm variable, jump to end as well.

---

### Record Filter and Deletion

```rpg
c                   if        rx1unt <> w_bunt
c                   goto      start
c                   end

c                   if        rx1emb <> w_memb
c                   goto      start
c                   end
```
- If the current record's `bunt` or `memb` field does **not** match the desired value, skip to next record.

```rpg
c                   delete    rtrxl2
c                   goto      start
```
- **If all the above checks pass, delete the current record**, then continue the loop to process the next record.

---

### End Routine

```rpg
c     slutt         tag
c                   eval      *inlr = *on
```
- Marks program complete by setting LR (Last Record indicator) on.

---

## 6. Initialization Subroutine `*INZSR`

```rpg
c     *inzsr        begsr
c     *entry        plist
c                   parm                    w_memb
c                   parm                    w_bunt
c                   eval      rtrxl2_firm = l_firm
c                   eval      rtrxl2_memb = w_memb
c                   eval      rtrxl2_bunt = w_bunt
c                   endsr
```
- At program start:
    - Expects parameters: member ID (`w_memb`), batch (`w_bunt`).
    - Sets up the key fields for file positioning and filtering.

---

## 7. (Commented) Debug Output

```rpg
o**sfdebug   e            debug
o**                                           10 'Lest:'
o**                       rtrxl2_firm         15
o**                       rtrxl2_memb         26
o**                       rtrxl2_bunt         33
o**                       rx1fir              40
o**                       rx1emb              51
o**                       rx1unt              58
o**sfdebug   e            debugd
o**                                           10 'Delete'
```
- Output specifications for debugging are present but commented. These would print out details as records are read and deleted.

---

## 8. Program Flow Summary

1. **Initialize**: Get the desired member and batch from input parameters.
2. **Position file** at the supplied key.
3. **Read each record** in file, for as long as the firm matches.
    - If the record matches both `memb` and `bunt`, **delete it**.
    - Otherwise, skip to the next record.
4. **Exit** when end of file or firm mismatch is detected.

---

## 9. Key Variables

- `l_firm`: Local variable storing the "firm" or company identifier.
- `w_memb`, `w_bunt`: Parameters used for selection; only records matching these will be deleted.
- `rx1fir`, `rx1emb`, `rx1unt`: Record fields containing firm, member, and batch values (from the file's record format).

---

## 10. Usage

- **Purpose**: This program is used to remove records from `RTRXL2` DB2 file that match a given member and batch for a given firm.
- **Parameterization**: Member (`w_memb`) and batch (`w_bunt`) are provided as parameters.
- **Safeguards**: Will only delete records for the specified firm (`l_firm`), member, and batch.

---

## 11. Onboarding Notes

- To modify deletion criteria, update the `if` checks inside the main loop.
- To enable debugging, uncomment the output (`sfdebug`) lines.
- To run the program, pass in the correct member and batch as parameters.
- This code style is RPG/400 fixed format; if you are used to free format (RPG IV), syntax will differ.

---

**Summary:**  
This program loops through the `RTRXL2` file and deletes only those records that match all provided criteria: firm, member, and batch, ensuring no accidental deletion outside the specified scope. The subroutine at the start reads the parameters and sets up initial variables, while the main loop reads and processes records, performing deletion as needed.