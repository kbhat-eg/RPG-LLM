# NK100R RPG Program Explanation

This code is an RPG/400 (ILE RPG) program for IBM i (AS/400) that manages external order codes (ekstern order-kode), with maintenance and subfile display for a GUI interface. It is fairly typical for traditional interactive maintenance programs on IBM i, making use of the subfile paradigm for listing and editing records.

Below is a structured explanation, with focus on the major components and logic.

---

## 1. **Header and Documentation**

- `H OPTION(*NODEBUGIO) DATEDIT(*DMY)`:  
  Compile options. Disables debug IO and sets default date format to DMY (day-month-year).
- The header contains program info, version changes, and indicator usage. Many comments are in Norwegian.

---

## 2. **File Definitions**

- `FNKEOL1`, `FNKEOLR`, and `FNKEOLU`:  
  Physical files (database tables) opened with external (E), keyed (K), disk access.  
  - All use the same base file (`NKEOPFR`), but are renamed for different logical views (`NKEOL1R`, `NKEOLRR`, etc.).
- `FNK100D`:  
  Workstation (display) file for user interaction, using a subfile (B1SFL) with relative record number (`W_SRRN`).  
  - Includes an INFDS (display feedback structure).

---

## 3. **Data Structures and Variable Declarations**

- **Local Data Area (LDA):**  
  Maps user, firm, and additional info from the LDA. Used for pre-loading user context.
- **Display Feedback Structure (`DSPFBK`):**  
  Provides cursor position feedback from the display file.
- **Key Variables** for file access (e.g., `NKEOL1_KODE`, `NKEOLR_KODE`, `NKEOLU_KODE`).
- **Work Variables:**  
  For subfile paging, sequencing, flags, etc. (e.g., `W_FCRN = first record on page`, `W_SRRN = subfile relative record number`).
- **Constants:**  
  E.g., `C_SFIL` subfile page size = 13.

---

## 4. **Indicator Usage**

- Indicators (01-99) are used for specific UI and functional states, e.g.,
  - `*IN10`: Roll
  - `*IN11`: Rolldown
  - `*IN12`, `*IN13`, etc.: Subfile control

---

## 5. **Main Program Control Flow**

The program uses tags and `GOTO` for control flow, with main logic split over several blocks.

- **Startup (`*INZSR` subroutine):**  
  - Loads the firm from LDA, initializes the page, and fills up the subfile (window).
- **Main Display/Processing Loop:**  
  - Begins at `B2TAGA` and `B2TAGB` tags.
  - Calls display subfile handling (`DSP_SUBFILE`).
  - Handles function keys via a `SELECT` block—branches to subroutines or other tags depending on user function key presses.
  - If positioning code (`B2KODE`) is entered, subfile is positioned accordingly.
  - Calls the `SUBFILE` subroutine for row-wise processing.
  - Loops until the program is exited.

---

## 6. **Subroutines**

The bulk of the business logic is implemented in subroutines:

### a. **FORNY** — Refresh Subfile
- If not on the first record, chains to correct subfile record.
- Sets up positioning on the main file, clears and re-fills the subfile.
- Resets flags.

### b. **POSISJONER** — Position Subfile
- Positions the subfile view based on user-entered code.
- Clears and refills the subfile.
- Clears the positioning variable for the next operation.

### c. **SUBFILE** — Main Subfile Processing
- Loops through all visible subfile records (using `READC`).
- Handles edit, delete, and display actions based on a selection field (`B1VALG`):
  - **2:** Edit code (calls `XC2BLD`)
  - **4:** Delete code (calls `XD1WIN`)
  - **5:** Display code (view only)
- After each subfile operation, updates the record and continues.

### d. **XC1BLD** — Create New Code
- Loops, displaying the create form until a not-blank and not-existing code is entered.
- Calls `XC2BLD` to go to edit mode for the new code.
- Refreshes the subfile if necessary.

### e. **XC2BLD** — Edit/Display Code (Form Handler)
- Loads relevant data into the form if the code exists.
- If the code does not exist, initializes fields for new entry.
- Handles viewing (protects fields) or edit mode.
- Validates mandatory fields.
- Updates or adds new records to the code file, handles timestamps and user info.
- Updates the subfile view accordingly.

### f. **XD1WIN** — Delete Code Handler
- Chains to the code in the file.
- Displays a confirmation window.
- If confirmed, deletes the record and sets refresh flag.

### g. **CLR_SUBFILE** — Clear Subfile Window
- Sets indicators to blank and writes the subfile control record to clear display.
- Resets subfile counters.

### h. **CRT_SUBFILE** — Fill Subfile With Data
- Adds subfile entries up to the page size.
- Reads records from the main file, only for the current firm, and writes them to the subfile.
- Handles end-of-data and keeps track of page boundaries for navigation.

### i. **BCK_SUBFILE** — Page Backwards in Subfile
- Handles backward paging by reading previous records.
- Rebuilds the subfile display after moving back a page.

### j. **DSP_SUBFILE** — Subfile Display Control
- Handles the showing of the subfile by writing the appropriate display/control record and handling indicators and cursor positioning.

---

## 7. **Key Lists for File Access**

- Key lists are used for keyed operations (e.g., `SETLL`, `CHAIN`):
  - Typically by firm (`W_FIRM`) and code.

---

## 8. **Program Termination**

- Sets `*INLR = *ON` (last record indicator), which signals RPG to close files on exit.

---

## 9. **User Interface (Display File) Structure**

- Multiple screens/panels are referenced:
  - **Subfile list screen**: Lists codes and allows selection.
  - **Control records**: Handles navigation/buttons.
  - **Edit/Create/Display screen**: For editing or viewing single record details.
  - **Delete window**: Confirmation before deleting a code.

---

## 10. **Typical User Workflow**

1. **Startup**: Loads and displays a list of codes for the current firm.
2. **Navigation**: User pages through codes, positions the cursor, or searches by code.
3. **Edit/Create/Delete**: User selects a record to edit, view, or delete, or enters a new code.
4. **Validation**: Program enforces required fields.
5. **Database Update**: On save or delete, appropriate file operations are performed.
6. **Subfile Refresh**: Any data change triggers a refresh of the subfile window.
7. **Exit**: User exits, program performs cleanup and closes files.

---

## 11. **Notable RPG Practices**

- Use of indicators for UI and logic control.
- Extensive use of subroutines for modularity.
- Key lists for keyed file operations.
- Subfile technique for list processing—load only a page at a time for performance.

---

## 12. **Special Comments**

- Comments and some variable names are in Norwegian, e.g.:
  - "Beskrivelse" = description
  - "Vedlikehold" = maintenance
  - "Forny" = renew/refresh
  - "Slette" = delete

---

## 13. **Possible Areas for Onboarding Focus**

- **Subfile Programming**: Understanding list processing and screen update interactions.
- **File Operations**: RPG’s `CHAIN`, `SETLL`, `READC`, `UPDATE`, `WRITE`, `DELETE`.
- **Indicator Usage**: Both for display logic and for branching in code.
- **Field and Data Structure Naming**: Familiarize with Norwegian terminology.
- **Screen File (DDS) Coordination**: Need to understand the related display file (`FNK100D`), which determines actual screen layout.

---

## 14. **Conclusion**

This is a classic subfile-driven RPG application for maintaining a code table, with robust support for paging, positioning, editing, adding, and deleting records. It combines interactive user interface (via DDS display file) with underlying DB2/400 database manipulation, following the typical workflow for "green screen" IBM i applications.

**For onboarding**, focus first on:
- Learning how subfiles work in RPG,
- The interaction between display file and program logic,
- How indicators and key lists drive program flow,
- The meaning of key data fields and the user journey through the program.

---

**If you have the display file (`FNK100D`) source, reviewing it will clarify the fields and screens referenced above.**