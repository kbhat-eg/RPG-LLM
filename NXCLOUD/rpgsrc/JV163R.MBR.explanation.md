# RPG Program JV163R Explanation

This RPG program is designed to read prioritized supplier information from a semicolon-separated file and update or insert records into a prioritized supplier file (`vprllu`). The code is structured in classic fixed-format RPG, using subroutines. The program ensures proper data handling and validity checks for supplier numbers, warehouse, group, module, and item information.

---

## 1. **File Declarations**

```rpg
flwexpf    if   e           k disk    rename(lexcpfr:lwexpfr)
fvprllu    uf a e           k disk    rename(vprlpfr:vprllur)
frlevl1    if   e           k disk    rename(rlevpfr:rlevl1r)
```

- **lwexpf**: Input file with data (likely the export from a spreadsheet).
- **vprllu**: Prioritized supplier file to update/insert into.
- **rlevl1**: Supplier master file (for validation of supplier numbers).

---

## 2. **Data Structures and Fields**

### 2.1. Input Record Parsing

A data structure overlays a 256-char field, breaking it into various elements parsed from the input file, e.g., warehouse, groups, module, item, prioritized suppliers. Each has overlays for extracting substring elements.

Example:
```rpg
d d_inpu                       256
d  d_lagen                       2  0 overlay(d_inpu:1)    // Warehouse number (2 chars, numbers)
d   d_lage                       2    overlay(d_lagen:1)   // Char (for parsing/trim)
...
d  d_varen                       8    overlay(d_inpu:16)   // Item number (max 8 chars)
...
d  d_pr1ln                       6  0 overlay(d_inpu:24)   // Prioritized supplier 1 (as number)
```

### 2.2. Work Fields

- `b_ok`: Flag if record is valid and ready for update/write.
- `w_posi`: Position for parsing semicolons.
- `digits`: Digit string, used in `%check` for numeric validation.
- `w_date`, `w_time`: Date/time stamps for updating records.
- Many local variables for parsed fields and processed values.

---

## 3. **Program Flow**

### 3.1. Main Loop

```rpg
c     read      lwexpf
c     dow       not %eof
   ...
   exsr      utled_ds     // Parse and validate the input record
   if        b_ok = *on   // Only process if ok
      ...
      // Set up key fields
      chain     vprllur   // Check if record exists
      if not found
         // Create new record
         clear ...
         set fields...
      endif
      // Update record fields (prioritized suppliers)
      update or write record
   endif
   read      lwexpf
enddo
```

#### **What’s happening?**
- Each record is read from the input file.
- It’s parsed and validated in subroutine `utled_ds`.
- If valid (`b_ok`), the program attempts to update the corresponding record in the output file, or insert a new one if it does not exist.

---

### 3.2. **Subroutine: utled_ds (Parsing and Validation)**

This subroutine is critical for splitting the semicolon-separated record and validating each field:

- **Parsing**: Uses `%scan` to find semicolons, `%subst` to extract the field, `%trim` to remove spaces.
- **Warehouse/Groups/Module/Item/Suppliers**: Each field is parsed in order, with logic to pad/truncate/convert as needed (length checks, moving characters, etc).
- **Suppliers**: After parsing supplier numbers, checks for numeric value and existence in the supplier master file (`rlevl1`). If not valid, set to 0.
- **If all suppliers are invalid, the record is skipped.**

Example field parsing:
```rpg
eval      w_posi = %scan(';':exclin)
eval      d_lage = %trim(%subst(exclin:1:w_posi-1))
```

**Supplier validation (simplified):**
```rpg
if        %check(digits:w_pr1l) <> 0
   d_pr1ln = 0
else
   move      w_pr1l        d_pr1ln
endif
...
rlevl1_levr = d_pr1ln
chain     rlevl1
if not found
   d_pr1ln = 0
endif
```

---

### 3.3. **Subroutine: *inzsr (Initialization)**

- Receives parameters (counts, etc.).
- Sets up key lists for file I/O.
- Initializes firm number and timestamps.

---

## 4. **Key Concepts and Techniques**

- **Semicolon-separated parsing**: Each field is located by searching for the next `;`, then extracted using substringing logic.
- **Overlaying fields**: Used for flexible field extraction for different field lengths.
- **Validation**: Numeric fields are checked, supplier numbers are validated via a lookup in the master supplier file.
- **Insert or Update**: Uses `chain` to check for existing records, then either `update` or `write`.

---

## 5. **Summary of Operation**

**In English:**

1. The program imports records from a semicolon-separated file, with each record holding information about warehouse, group, module, item, and up to three prioritized suppliers.
2. Each record is parsed, values are cleaned and validated.
3. Supplier numbers are checked to ensure they are numeric and exist in the supplier master file.
4. If the record is valid (at least one valid supplier), it will attempt to update an existing prioritized supplier record or create a new one.
5. Timestamps and user info are set for each change.
6. The process repeats until the input file is fully read.

---

## 6. **Common Use Cases for Modifications**

- **Input format changes:** Update the parsing logic in `utled_ds`.
- **Supplier validation rules:** Adjust the check or add more criteria.
- **Output fields:** Modify which fields are written to the output file.

---

## 7. **Key Points for New Developers**

- **Classic fixed-format RPG:** This code isn't free-form RPGLE; field columns matter.
- **Field overlays:** Enable flexible parsing, but can be hard to read.
- **Subroutine-based structure:** Main processing and parsing are separated.
- **Careful field validation:** Many fields are validated both for format and for “existence” by lookup.

---

If you are onboarding to this code, start by carefully examining the `utled_ds` subroutine, as it encapsulates the parsing/validation logic, then review the main loop for the update/write logic. Understanding how overlays and positional reads work is essential due to the field extraction approach.