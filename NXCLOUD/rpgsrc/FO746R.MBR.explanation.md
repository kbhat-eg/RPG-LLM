# Explanation of RPG Program FO746R

## Overview

This RPG (Report Program Generator) program, named **FO746R**, is responsible for the **automatic generation of purchase orders ("bestillinger") from sales orders ("ordre")** within a business system running on IBM i (AS/400) platform. 

The program reads order headers and order lines, evaluates each line for inclusion in a new purchase order, and writes the appropriate records to the purchase order header and detail files. It also interacts with inventory and number assignment subsystems and maintains several file relationships.

Comments and variable names are in Norwegian, and many referenced files and fields are domain-specific.

---

## Structure and Flow

### Header and Files

- `h datedit(*dmy) option(*nodebugio)` — Specifies default date format and debugging options.
- **Files (F-specs):** The program interacts with multiple physical/logical files, mainly:
  - `fodtl2` (order line file)
  - `fohel1` (order header file)
  - `lodtl1`, `lodtlu`, `lodtlr` (purchase order lines)
  - `lohel1`, `lohelu` (purchase order headers)
  - `rlevl1` (supplier master)
  - `rkunl1` (customer master)
  - ...and several other auxiliary files.

Records are often renamed for local use.

---

### Data Structures and Variables

- **LDA Fields:** For session/user identification (`l_wsid`, `l_user`, etc).
- **Data Structures:** For inventory update (`hlrec` and overlays for its fields).
- **Parameters:** Used for passing data into the program and between subroutines.
- **Work Variables:** For tracking status, dates, numerics, text fields, and file keys.

---

### Main Program Flow

1. **Initialization (`*inzsr`):**
   - Receives parameters (firm, order number, suffix, supplier, etc).
   - Sets up work variables and key structures.
   - Looks up status codes and sets the date/time.

2. **Main Routine:**
   - `exsr hent_basis` — Fetches base information (order header, customer, supplier).
   - On error, sets status and ends.
   - `exsr lag_best` — Creates a purchase order for the supplier.

3. **Exit:**
   - Sets LR indicator (`*inlr = *on`), ending the program.

---

### Key Subroutines

#### `hent_basis` (Get Base Information)

- Reads the order header using provided keys.
- Reads the customer record using the customer number from the order.
- Reads the supplier record using the supplier parameter.
- If any read fails, sets a failure flag and exits the subroutine.

#### `lag_best` (Create Purchase Order)

- Looks up order type details.
- Calls `hntnum` to get the next available purchase order number from a number file.
- Sets up keys for purchase order header and lines.
- Calls `bes_lin` to process and create purchase order lines.
- If any lines were written, calls `bes_hode` to write the purchase order header.

#### `bes_lin` (Write Order Lines to Purchase Order)

- Reads all lines for the source order.
- For each line, checks several inclusion/exclusion criteria:
  - *Should this line be ordered?* (checking item type, price group, quantity, etc)
  - Skips if not required.
  - If the item is not already on order, creates a new purchase order line record.
  - Copies relevant data, applies cost and price logic, and calculates line amounts.
  - Calls `opplag` to update inventory via another program if needed.
  - Updates the originating order line to reflect the new purchase order number and quantities ordered.

#### `bes_hode` (Write Purchase Order Header)

- Calls `hent_total` to sum up the purchase order totals.
- Loads supplier and address data into the purchase order header.
- Depending on the order type (`folety`), may fetch logistics point data or customer address.
- Writes the purchase order header record.

#### `hntltx` (Get Logistics Text)

- Calls another program (`FØ720R`) to retrieve names and addresses for the warehouse/logistics point.
- Updates the address fields in the purchase order header with this data.

#### `hent_logp` (Get Logistics Point Data)

- Calls another program (`MJ500R`) to retrieve more detailed logistics point data (address, place, etc).

#### `opplag` (Update Inventory)

- Moves relevant fields into the inventory update structure (`hlrec`).
- Calls another program (`VL001R`) to update the inventory register.

#### `hntnum` (Get Next Purchase Order Number)

- Calls another program (`AS100R`) to retrieve and assign the next available number for the new purchase order.

#### `hent_total` (Calculate Purchase Order Totals)

- Loops through the purchase order lines, summing the costs and prices for the header totals.

---

### Key Lists (KLISTs)

Multiple *KLISTs* define the composite keys used for file access (chained reads, updates, etc), such as keys for order header/line files and customer/supplier files.

---

### Parameters/Entry Point

The program receives its parameters via a `*entry` `plist` (parameter list). These typically include:

- `p_firm` - Firm number
- `p_numm` - Order number
- `p_suff` - Order suffix
- `p_ldor` - Supplier
- `p_stat` - Status (output)

These are then distributed into the various key variables for file access.

---

## Noteworthy Logic

- **Line Inclusion:** Only lines matching specific criteria (type, not already on order, with quantity, etc) are included in the purchase order.
- **External Program Calls:** Several subprograms are called for specialized tasks (pricing, inventory update, number assignment, logistics data retrieval).
- **Overlay and Data Structure Usage:** Extensive use of overlays, in the old RPG style, to map parts of larger structures for record-level manipulation.

---

## Comments and Modifications

- The program has a long change history, with several enhancements and bug fixes over time, like logic changes for price/cost, new fields, and handling more complex keys or address data.
- Many comments and some variable names are in Norwegian (e.g., "bestilling" = "purchase order", "ordre" = "order", "kunde" = "customer", "leverandør" = "supplier", "lager" = "inventory/warehouse").

---

## Summary Table

| Section            | Purpose                                                        |
|--------------------|----------------------------------------------------------------|
| File Specs         | Declares all databases/files used                              |
| Data Structures    | Defines overlays and work structures for processing            |
| Parameters         | Manages input (from calling program) and internal flow control |
| Mainline           | Orchestrates the subroutine calls and handles high-level flow  |
| Subroutines        | Handles all business logic: fetching, creating, updating       |
| Key Lists (KLISTs) | Define composite keys for chained reads/writes                 |

---

## Onboarding Tips

- **Understand the Data:** Review physical and logical files referenced (e.g., FODTL2, LOHELU, RLEVL1) to understand the data model.
- **Subprograms:** Familiarize yourself with called programs (`VL001R`, `VL710R`, `AS100R`, etc) -- documentation/stubs may be needed.
- **Business Logic:** The line and header creation logic is driven by several business rules (especially for inclusion/exclusion), all tightly bound to the sales and purchase order process.
- **Old RPG Syntax:** The program uses fixed-format, column-sensitive syntax (pre-Free RPG), overlays, and several dated constructs.

---

## Typical Flow (Step-by-Step)

1. **Init:** Get firm/order/supplier from parameters.
2. **Fetch Order/Header/Customer/Supplier:** If any not found, exit with error.
3. **Fetch Order Type/Register:** Determine if special handling is needed.
4. **Assign new Purchase Order Number.**
5. **For each Order Line:**
    - Check eligibility.
    - If eligible and not already purchased:
      - Write to purchase order line file.
      - Update inventory (if configured).
      - Update originating order line.
6. **If any line created:**
    - Calculate purchase order totals.
    - Write purchase order header.
7. **Exit and return.**

---

## Conclusion

This program is a robust, business-critical component automating the translation of sales orders into purchase orders, ensuring supplier-side ordering is triggered from customer-side demand. It's a classic example of RPG data processing and integration in an IBM i environment.