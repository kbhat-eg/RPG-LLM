# RPG Program Explanation

This RPG (Report Program Generator) source code is written in "traditional" (fixed format) RPG IV (ILE RPG) style. The program's main function is to process records from a disk file, perform character replacements (especially for Scandinavian and German letters that may not exist in standard ASCII), and output the modified results. Below is a detailed explanation to help you onboard:

---

## 1. **Header and Metadata**

- **`h datedit(*dmy) option(*nodebugio)`**  
  Specifies date editing format (day-month-year) and disables debug I/O.

- **Comments:**  
  Extensive comments document version history, program purpose, and modification notes; some are in Norwegian, describing the addition of support for various accented characters.

---

## 2. **File Declarations**

- **Input/Update/Output Files:**
    - `faxmlut up e disk`  
      File for updating output (UP=update, E=Externally described, DISK=file).
    - `frxmml1 if e k disk rename(rxmmpfr:rxmml1r)`  
      Input file, externally described, keyed access; renames field structure for clarity.
    - `fliste o f 132 printer`  
      Output file for printing, line length 132.

---

## 3. **Variable Declarations**

- **Working fields**
    - `w_alfa`   - 3 chars; controls which subroutine is invoked.
    - `w_xmlr`   - 120 chars; holds the output XML record.
    - `teller`   - 6 digit zoned decimal; counts processed records.
    - `text`     - 121 chars; working buffer for input line.
    - `i`        - 9 digit signed; used for scan position.
    - `w_posi`, `w_posu` - Positional indexes (not actively used in shown logic).
    - `w_str_i`, `w_str_u` - Strings sized at 512 chars (not actively used in shown logic).
    - `w_str_x`  - 1 char.
    - `c_apos`   - Constant with hex `x'7D'`.
    - `rxmml1_firm` - Like field `xmfirm` from input structure.

- **UDS (User Defined Structure):**  
  Used for referencing fields at specific record positions (not used in logic but declared).

---

## 4. **Main Logic**

### **Selection of Subroutine**

- **Set indicator and increment counter:**
    ```rpg
    c                   move      *off          *in90
    c                   add       1             teller
    ```
    `*in90` is an indicator variable (a flag), set *off* at the start of each record; `teller` increments as a count.

- **Determine subroutine to run based on `w_alfa`:**
    ```rpg
    c     w_alfa        ifeq      '1X1'
    c                   exsr      SUB1X1
    c                   endif

    c     w_alfa        ifeq      'SPS'
    c                   exsr      SUBSPS
    c                   endif
    ```
    - If `w_alfa` equals '1X1', call subroutine `SUB1X1`.
    - If `w_alfa` equals 'SPS', call subroutine `SUBSPS`.

- **Update if changes occurred:**
    ```rpg
    c     *in90         ifeq      *on
    c                   movel     text          xmlrec
    c                   update    axmlutr
    c                   endif
    ```
    - If changes were made (`*in90` is on), copy `text` to `xmlrec` and update the output file.

---

## 5. **Subroutines**

### **SUB1X1 - Letter-by-letter Replacement**

This subroutine replaces specific accented or special letters with their non-accented equivalents for ease of processing (e.g., for XML export).

**The process:**
- For each special character (mostly Norwegian, Swedish, German, and special characters), scan through the `text` buffer.
- When found, replace it with an ASCII equivalent.
- For example:
    - 'Æ' → 'E'
    - 'Ø' → 'O'
    - 'Å' → 'A'
    - Lowercase equivalents are also replaced accordingly.
    - '&' → ' ' (space).
    - Swedish: 'ä'/'Ä'/'å'/'Å'/'ö'/'Ö'/'é'/'É', etc., mapped to 'a'/'A'/'o'/'O'/'e'/'E'.
    - German: 'ü'/'Ü'/'ö'/'Ö'/'ä'/'Ä' variants mapped similarly.

**Implementation:**
- For each character, uses:
    ```rpg
    c     'special'      scan      text          i
    c                   dow       i > 0
    c                   eval      text   = %subst(text:1:i-1) +
    c                             'replacement' +
    c                             %subst(text:i+1:120-i)
    c     'special'      scan      text          i
    c                   enddo
    ```
- After all replacements, if `text` has changed, set `*in90` on.

---

### **SUBSPS - Special Character Replacement**

- Instead of ASCII equivalents, replaces special letters with double-byte codes for output (e.g., for a particular output device or code page).
    - Example: 'Æ' → X'6606'
    - The process is the same scan-and-replace loop as `SUB1X1`, just with double-byte hex codes.

- As before, if any changes are made, it sets `*in90` to indicate that the record needs to be updated.

---

### **Initialization Subroutine (`*inzsr`)**

- Sets up required work variables before processing begins.
- Builds a key (`rxmml1_key`), chains into the RXMML1 file, sets `w_alfa` from the result; if record not found, defaults to '1X1'.

---

## 6. **Output Section**

- **Printer Output Format**
    - Outputs the record number (`teller`) and the processed XML line (`w_xmlr`) on each printed line.

---

## 7. **Summary**

**Function:**  
This program reads records from a file, processes their character content to convert special/foreign letters into a suitable form (for XML or print output), and writes the modified lines back to disk and/or to a print file.

**Key Points:**
- Handles various European accented characters for multi-lingual support.
- Supports two modes of output: ASCII conversion (default) or device-specific double-byte encoding (`w_alfa` controls this).
- All processing is done line-by-line and character-by-character for maximum compatibility.

---

## 8. **Potential Use-Cases**

- Data cleansing for export to systems that cannot handle special characters.
- Preparing text for XML or print output where only standard ASCII is permitted.
- Ensuring that output is compliant with partner systems or regulatory specifications (e.g., for the Norwegian SAFT standard).

---

**If you are onboarding:**
- Focus first on understanding the scan/replace pattern for text handling.
- Review how external files are set up and matched by key.
- Note that the logic is tightly coupled to Scandinavian and Central European alphabets but can be extended as needed.
- Consider modernizing this logic with built-in string replacements or moving to free-form RPG for easier maintenance.