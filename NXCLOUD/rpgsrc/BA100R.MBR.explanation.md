# RPG Program BA100R - Butikk-status, vedlikehold  
This RPG program is a classic OPM-style (fixed-format) ILE RPG program, used for maintaining shop (butikk) status data. The code is commented in Norwegian, so some key comments are translated and explained for understanding.

---

## 1. **Header and Metadata**

```rpg
h option(*nodebugio) datedit(*dmy)
```
- Compiler options:  
  - `*NODEBUGIO`: Disables debug I/O for performance.
  - `*DMY`: Date fields handled as day-month-year.

The initial block contains program and change history, with developers' initials and short notes about updates.

---

## 2. **File Definitions**

```rpg
fbstsl1    if   e           k disk    rename(bstspfr:bstsl1r)
fbstslu    uf a e           k disk    rename(bstspfr:bstslur)
fba100d    cf   e             workstn
```
- **bstsl1**: Input keyed file, renamed record format as `bstsl1r`.
- **bstslu**: Update/output keyed file, renamed as `bstslur`.
- **ba100d**: Display file for user interaction.

---

## 3. **Data Area and Variable Definitions**

```rpg
d                uds
6.10 d l_user                911    920
d l_firm                944    946  0
d l_fnav                951    980
d w_firm          s                   like(baafir)
```
- **LDA (Local Data Area):**  
  - `l_user` (911–920): User info.
  - `l_firm` (944–946): Firm/company code.
  - `l_fnav` (951–980): Presumably, firm name.
- **Variables:** 
  - `w_firm`: Local copy of company code, same type as `baafir`.

---

## 4. **Main Program (Hovedprogram)**

#### **Initialization**

- The program starts at the `start` tag.

#### **Data Retrieval — Read (CHAIN) from bstsl1**

```rpg
c     key01         chain     bstsl1
```
- Tries to read (`CHAIN`) a record in `bstsl1` file using key list `key01` (see INIT subroutine).
- If found, moves a large number of fields from file record to display/input buffer (`c1aavs`, etc.).

#### **Record Not Found Path**

- If the record is not found, fields are initialized to blanks or zeroes (default values).

#### **Present Data to User**

```rpg
c                   exfmt     c1bld
```
- Displays and allows editing of the record on the screen via the display file format `c1bld`.

#### **Function Key Handling**

```rpg
c                   if        *inkc or *inkl
c                   goto      avslutt
c                   endif
```
- If function key C or L is pressed, the program ends (`goto avslutt`).

#### **Special Handling — Payment Card Update (Betalingskort info)**

```rpg
c                   if        *inkh
c                   call      'BA105R'
c                   goto      start
c                   endif
```
- If function key H is pressed, calls program `BA105R` for card info update, then restarts the main loop.

#### **Data Update — Read (CHAIN) from Update File (bstslu)**

- Similar `CHAIN` using the key, but on the update file.
- Moves fields from screen/input buffer back to file buffer (`baaavs`, etc.).

#### **Timestamping and Updating**
- Sets updated timestamps and user from LDA.
- `UPDATE` if found, otherwise `WRITE` a new record.

---

## 5. **End of Program**

```rpg
c     avslutt       tag
c                   eval      *inlr = *on
c                   return
```
- Standard RPG end-of-program sequence; sets last record indicator and returns.

---

## 6. **Initialization Subroutine (*INZSR)**
 
- Sets up the key list (`key01`) for record lookups and updates.
- Key is filled from LDA:
    - Reads `l_firm` and sets `w_firm`.

---

## 7. **Summary of Program Flow**

1. **Initialization:** Pulls company code from LDA.
2. **Main Loop:**
    - Reads a record for a key (company).
    - If found, populates display buffer for editing.
    - If not found, clears buffer.
    - Presents data to user.
    - Handles function keys for exit or special action (card info).
    - Updates or inserts data back to the "status" file, with audit data.
3. **Repeat or exit on user command.**

---

## 8. **Key Learnings and RPG Concepts Demonstrated**

- Use of disk files and display files in classic RPG.
- Use of LDA for session/user-related data.
- Two-file technique: One for read (history/source), one for update (target).
- Repeated transfer of fields between screen fields and database record fields.
- Special handling based on user function keys.
- Record locking/handling via CHAIN and conditional UPDATE/WRITE.
- Audit fields (user, timestamp) maintained programmatically.

---

## 9. **Typical Usage Scenario**
A user enters a company code, and the program retrieves the status record for that shop/company. The user can view or update shop status data, and optionally maintain payment card information. All updates are timestamped and tracked by user for audit.

---

## 10. **Areas for Modernization**
If onboarding to a new team, consider:
- Refactoring to free-format RPG.
- Modularizing field moves to subprocedures.
- Using data structures for record/screen buffer mapping.
- Employing SQL for file access.
- Modernizing display file handling and key handling.

---

## 11. **Conclusion**
The program is a classic RPG shop-status maintenance tool. It is structured to ensure field-by-field data consistency, provides user feedback and validation via display file, and relies on LDA for default context (user and company). It demonstrates standard OPM/ILE RPG file-processing and screen design patterns.