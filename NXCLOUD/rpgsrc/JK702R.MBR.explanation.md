# RPG Program JK702R – Explanation

## Overview

This program is designed to **update a "logistic product" (`logistikkvare`) with data from all its related sub-items (`undervarer`)** in an IBM i (AS/400) database system. The program reads a "logistic product" identifier as input, loops through its sub-items (from table `JVKLPF`), and **copies associated information** from the sub-items to the main product in the tables `JVLEPF`, `JVPKPF`, and `JVPRPF`. After copying, it **removes old records** in those tables that are no longer relevant (i.e., not updated in this run).

There are routines for detailed copying (including handling primary keys and avoiding data duplication), ensuring data integrity, and error processing.

---

## File Declarations

```rpg
fjvkhpf    if   e           k disk
fjvklpf    if   e           k disk
fjvarpf    if   e           k disk
```
- **Declares physical files** (`JVKHPF`, `JVKLPF`, `JVARPF`) for input/output operations.

---

## Parameters and Local Data Area

- **Parameters:**
  - `p_vare` : Product number (like `jvvare`).
  - `p_vldo` : Logistic code.
  - `p_dumm`: Dummy parameter (not used).

- **Local Data Area (LDA):**
  - `l_user` : User who runs the job.
  - `l_firm` : Firm number.
  - `l_fnav` : Company name, etc.

- **Work Fields:**
  - Variables for holding temporary values, counters, dates, keys, etc.

- **Data Structures:**
  - `ds_jvarpf`, `ds_jvprpf`, `ds_jvlepf` are based on the file layouts and used for working with record images from those files.

---

## Main Program Flow

```rpg
exsr fornyvare
exsr rydd
```
- **Refresh product data** (copying from sub-items).
- **Clean up records** that were not updated in this run.

```rpg
call 'JV790R'
parm w_firm
parm w_vare_p
parm b_inlr
```
- **Calls another program** to update search texts for the product.

---

## Subroutine: `fornyvare`

This is the **core routine** that:

1. **Builds and prepares an SQL query** to select all sub-items (`JVKLPF`) for the logistic product.
2. **Opens a cursor** and fetches sub-items one by one (with a safety limit of 9999).
3. For each sub-item:
    - Calls:
        - `nobbkopivare`: Copies/updates the product info from the sub-item to the main product.
        - `nobbkopipris`: Copies/updates price information.
4. **Closes the cursor** at the end.

### Inside `nobbkopivare`

- Skips copying if the logistic product **is itself a NOBB (Norwegian product database) item**.
- **Copy or update product master data** in `JVARPF`:
    - If the destination record doesn't exist, **insert** it.
    - If it does exist, **update** relevant fields.
- **Copy or update supplier link** in `JVLEPF`:
    - For both supplier and NOBB supplier if applicable.
    - Insert or update according to existence.
- **Copy packaging information** from the sub-item (`JVPKPF`) to the logistic product.
    - For both supplier and possibly NOBB supplier.

### Inside `nobbkopipris`

- **Copy or update price records** in `JVPRPF`:
    - For each price record belonging to the sub-item and logistic code, insert/update into the main product.
    - Price values are adjusted by a factor (`jvqofa`).

---

## Subroutine: `rydd` (Cleanup)

- After all copying, **delete records from JVLEPF, JVPKPF, and JVPRPF that are not "current"** for this logistic product (i.e., were not just updated for any of the sub-item logistic codes).
- Uses SQL `DELETE ... WHERE ... NOT IN (SELECT ...)` to ensure only relevant records remain.

---

## Subroutine: `sjekk_sql` (SQL Error Handling)

- Checks the SQL code (`sqlcod`).
- On error:
    - Logs the error using predefined programs (`AB700R`, `AB705R`).
    - Sets program to end.

---

## Subroutine: `*inzsr` (Initialization)

- Gets input parameters.
- Sets work variables from LDA and parameters.
- Gets the current time for timestamping operations.

---

## Notes and Comments

- **NOBB product logic**: The code ensures that if the logistic product is itself registered as a NOBB product, special rules apply (do not overwrite certain info).
- **Extensive use of embedded SQL**: Most copying and updates are SQL-based, which allows for bulk operations and conditional existence checks.
- **Error handling**: Ensures that any SQL error stops further processing and logs details.
- **Data consistency**: After copying, the cleanup ensures no orphaned or obsolete records remain.
- **Commented-out code**: The code includes alternate (older?) cleanup logic, replaced in version 7.01 (April 2021), which is kept for reference but commented out.

---

## Summary Table – Key Tables

| Table   | Description                        | Handled By         |
|---------|------------------------------------|--------------------|
| JVARPF  | Product master data                | nobbkopivare       |
| JVLEPF  | Product-supplier relationships     | nobbkopivare/rydd  |
| JVPKPF  | Product packaging information      | nobbkopivare/rydd  |
| JVPRPF  | Product price information          | nobbkopipris/rydd  |
| JVKLPF  | Sub-item cross-reference           | fornyvare          |
| JVKHPF  | Header info for NOBB link          | fornyvare          |

---

## Typical Execution Flow

1. **Initialization** (`*inzsr`): Receives parameters, sets up variables.
2. **fornyvare**: Loops through sub-items, copies/updates master, supplier, packaging, and price data.
3. **rydd**: Cleans up outdated records.
4. **Call to JV790R**: Updates search text for the product.
5. **End**: Program returns.

---

## Onboarding Tips

- Focus on the **main subroutines** (`fornyvare`, `nobbkopivare`, `nobbkopipris`, `rydd`).
- **Table relationships** are central—understand how they link main products to sub-items.
- The program is **SQL-heavy**—embedded SQL skills help.
- Business rules about **NOBB products** are important for logic flow.
- Always review error handling in `sjekk_sql` after making changes to SQL statements.

---

Feel free to ask for deep-dives into any subroutine or for a graphical flow chart!