## Overview

This RPG IV (ILE RPG) program implements a **Modulus-10 check** algorithm, often used to validate identification numbers (like account numbers, organization numbers, etc.) by verifying a control digit. The program is documented in Norwegian and works with a 25-digit input string, returning a code indicating whether the control digit is valid.

---

### Header and Metadata

- `h option(*nodebugio) datedit(*dmy)`
  - Sets program options: no debug I/O, date edit in day/month/year format.

There are detailed comments explaining the program origin, purpose, and changes.

---

## Data Definitions

### Arrays
- `a_siff  s 1 dim(24)`
  - Holds individual digits of the input number (except the last digit/control digit).
- `a_vekt  s 1 dim(24)`
  - Holds weighting digits for the Modulus-10 calculation (a repeating sequence of 1 and 2).

### Parameters
- `p_tall s 25`
  - The 25-character numeric string to validate.
- `p_rkod s 1`
  - Return code: set to *ON (`1`) if the control digit is invalid.

### Variables (Working Storage)
- `w_leng s 2 0`: Length of the trimmed input.
- `w_ta24 s 24`: First 24 digits of the input (excluding control digit).
- `w_siff s 1 0`: Single digit for calculation.
- `w_vekt s 1 0`: Corresponding weight.
- `w_sifs s 3 0`: Accumulates the digit sums for Modulus-10.
- `w_enta s 1 0`: Last digit of `w_sifs` (sum modulo 10).
- `w_prod s 2 0`: Intermediate product of digit and weight.
- `w_pro1 s 1 0`, `w_pro2 s 1 0`: Used to split `w_prod` into individual digits.
- `w_kntr s 1 0`: Calculated control digit.
- `w_knta s 1`: Final control digit (for comparison).
- `x s 2 0`: Loop index.

### Constants
- `c_null s 25 inz('0000000000000000000000000')`: String of 25 zeroes, for zero-padding.
- `c_vekt s 24 inz('121212121212121212121212')`: Weight sequence for modulus check.

---

## Main Logic

### 1. Trim and Zero-Pad Input

```rpg
eval p_tall = %trim(p_tall)
eval w_leng = %len(%trim(p_tall))
if w_leng < 25
  eval p_tall = %subst(c_null:1:25-w_leng) + %subst(p_tall:1:w_leng)
endif
```
- The input string is right-justified and zero-padded to a length of 25.

### 2. Prepare for Modulus-10 Check

```rpg
movel p_tall w_ta24
movea w_ta24 a_siff
movea c_vekt a_vekt
eval w_sifs = 0
eval x = 25
```
- `w_ta24` gets the first 24 digits (control digit not included).
- Characters in `w_ta24` are moved to `a_siff` (one digit per array element).
- The weighting sequence is moved to `a_vekt`.
- Initialize digit sum and index.

### 3. Modulus-10 Calculation Loop

```rpg
do 24
  eval x = x - 1
  move a_siff(x) w_siff
  move a_vekt(x) w_vekt
  eval w_prod = w_siff * w_vekt
  move w_prod w_pro1
  movel w_prod w_pro2
  eval w_sifs = w_sifs + w_pro1 + w_pro2
enddo
```
- For each digit (right to left), multiply by its weight (1 or 2).
- If the product is two digits, add both digits (i.e., for 14: 1 + 4 = 5).
- Accumulate this sum in `w_sifs`.

### 4. Validate Control Digit

```rpg
move w_sifs w_enta
if w_enta > 0
  eval w_kntr = 10 - w_enta
else
  eval w_kntr = 0
endif
move w_kntr w_knta
if w_knta <> %subst(p_tall:25:1)
  eval p_rkod = *on
endif
```
- Control digit is `10 - (sum mod 10)` unless sum is zero, then control digit is 0.
- Compare the calculated control digit (`w_knta`) to the last digit of the input (`%subst(p_tall:25:1)`).
- If mismatch, set `p_rkod` (return code) to ON (meaning invalid).

### 5. Program End

```rpg
eval *inlr = *on
return
```
- Set last record indicator on, end program.

---

## Initialization Subroutine `*inzsr`

- Declares the entry parameters `p_tall` and `p_rkod`.
- Initializes the return code (`p_rkod`) to OFF (valid, unless set otherwise).

---

## Summary

**This program receives a 25-digit number as input and validates its last digit as a Modulus-10 control.**  
- The first 24 digits are multiplied by alternating weights (1, 2, 1, 2, ...), digit sums are accumulated, and then the check digit is calculated.
- The program sets a return code if the last digit of the input does NOT match the calculated control digit.
- It is a utility routine, designed to be called by other programs.

---

### Key Concepts
- Modulus-10 validation, also known as the Luhn algorithm.
- Use of arrays and working variables.
- Zero-padding and trimming strings.
- Return code logic for control digit validation.
- RPG/400 style with some ILE RPG enhancements.

---

**This is a straightforward, well-documented Modulus-10 checker in classic ILE RPG.**