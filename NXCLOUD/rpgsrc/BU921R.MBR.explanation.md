# RPG Program BU921R: Explanation and Orientation

## Overview

This RPG/400 ILE program, named `BU921R`, is a specialized utility for retail stores (Butikk) to retrieve detailed information about an item (vare) including units of sale (salgsenhet), calculated price, and discounts for the first sale unit. It includes significant logic for identifying products from various types of scanned codes, handling their properties, retrieving pricing, and outputting structured data for further processing.

The program is heavily documented with comments in Norwegian, reflecting both the application domain and the development history. It utilizes several database physical files and calls external programs for price calculation and type lookups.

---

## High-Level Flow

1. **Parameter Initialization & Input Checks**
    - Receives several parameters such as firm, customer number, scanned value, etc.
    - Checks if a scanned value is provided; if not, terminates early.
    - Sets up local variables and structures for the business logic.

2. **Item Identification**
    - Uses a subroutine (`scanning`) to interpret the scanned value, determining the item number (`p_vare`) based on the type and length of input (e.g., alpha string, EAN-128, vendor number).
    - If the product cannot be identified, the program exits.

3. **Special Item Handling**
    - If the item number matches special values (like placeholder special item numbers), it blanks out the product and exits.

4. **Querying Sale Units and Item Properties**
    - Looks up all valid sales units for the item from the database and populates a data structure with unit codes and their corresponding logical info.
    - Retrieves additional item type properties by calling the external program `VL710R`.

5. **Price Calculation**
    - Fills a complex structure (`hirec`) with parameters required for price calculation (item number, customer, store, unit, etc.).
    - Calls external program `VP900R` for actual price and discount computation, receiving values in `horec`.

6. **Output**
    - Fills out output parameters: product info structure (`d_vinf`), units, EAN info, and all calculated price and discount results.
    - Handles some special business rules, such as blanking out EAN units if the sales price is zero.

---

## Key Data Structures

### Parameter Fields

- **Input:** firm, customer, product, scanned value, store, department, etc.
- **Output:** item number, item info, unit info, EAN number, quantity, several prices and discounts.

### Data Structures

- **Item Info (`d_vinf`)**: Overlay structure containing textual descriptions, groupings, unit codes, and various item properties.
- **Unit Info (`d_einf`)**: Overlay structure with up to 5 sales units, each with unit code, logic number, and auxiliary info.
- **EAN-128 Info (`d_e128`)**: For handling EAN-128 barcodes, breaking down the code into its constituent parts.
- **Pricing Structures (`hirec`/`horec`)**: For passing data to/from the external price calculation program.

---

## File Definitions

Multiple database files are accessed, with logical file renames:

- **`vvarl1`, `vvarl4`**: Item master files (by item number, by vendor number)
- **`vvenl2`, `vvenlr`**: Item-to-unit cross-reference files
- **`bstsl1`**: Store status file
- **`rkunl1`**: Customer master file
- **`vvlel1`**: Item extension for lumber assortment

---

## Main Algorithm Steps

### 1. Parameter Verification

```rpg
if p_scan = *blank
    goto avslutt
endif
```
- If no scanned input, program exits.

### 2. Parameter Preparation

- Set up local and working variables from input.
- Zero and blank out key values in the item/unit info structures.

### 3. Scanning Subroutine: Interpreting the Scanned Code

#### a. Alpha Codes

- Tries to match the input to a known vendor item (logistics item).

#### b. Numerics

- **Length = 26**: Treated as EAN-128 barcode—decode and extract item/EAN info by calling `VE710R`.
- **Length <= 8**: Treated as item number—left pad to 8 digits and try lookup.
- **Length <= 14**: Treated as EAN code—left pad to 14 digits and try lookup.

#### c. Vendor Item (if above not found)

- Try to find the item using the vendor number logic.

### 4. Special Item Check

```rpg
if p_vare = baavar or p_vare = baagva or p_vare = baadva
    p_vare = *blank
    goto avslutt
endif
```
- Bails out if the item is a special system/item.

### 5. Populate Unit Data

- For the item found, read all sales units and fill the unit structure.

### 6. Call Out to Item Type and Price Programs

- Populates parameters for `VL710R` (get item type) and `VP900R` (get price/discount).
- Sets date/time values for price calculation.
- Retrieves item text and group codes from master files.

### 7. Output Assignment

- Maps all retrieved product, unit, and pricing info back to output parameters and structures.

---

## Special Business Logic

- If the sales price is zero and an EAN unit is set, blank out EAN unit.
- If inventory is zero in parameter, tries to fetch it from the customer file.
- For certain types of input, if the scanned unit doesn’t exist for the product, signals an error with a message and resets the unit.

---

## Subroutine: `scanning`

This central routine interprets the scanned input to determine the item number using multiple strategies in a defined order:

1. **Alpha scanned values** are matched to the vendor/item table.
2. **Numeric, length=26**: Treated as EAN-128, decoded for item/EAN/unit.
3. **Numeric, length<=8**: Interpreted as item number, left-padded, and looked up.
4. **Numeric, length<=14**: Interpreted as EAN, left-padded, and looked up.
5. **Fallback**: Try vendor item number as a last resort.

If an item is found at any step, the subroutine exits early.

---

## Subroutine: `*inzsr` (Initialization)

- Moves and initializes parameters and keys.
- If inventory/store (`w_lage`) is zero, retrieves the value from the customer file if available.
- Retrieves the price group with a call to `VL712R`.

---

## Key External Program Calls

- **`VL710R`**: Retrieve product type codes and related data.
- **`VP900R`**: Pricing and discount calculation.
- **`VL712R`**: Fetch price group from warehouse and department.
- **`VE710R`/`VE711R`**: EAN code resolution—finds item/unit by EAN.

---

## Error and Special Handling

- Extensively checks for the existence and validity of units linked to the item, especially EAN units.
- Some error messaging and logging is commented out or temporarily disabled.
- Special flags and overlay data structures are used to map flat file records to logical field layouts.

---

## RPG-Specific Notes

- Usage of **overlay** data structures for working with flat record layouts within a single buffer.
- Usage of **named KLISTs** and field lists for indexed DB access.
- Use of **external program calls** with parameter lists for business logic not implemented in this module.

---

## Summary Table: Key Variables and Their Roles

| Variable        | Type/Structure          | Purpose                       |
|-----------------|------------------------|-------------------------------|
| `p_scan`        | char(50)               | Scanned value (input)         |
| `p_vare`        | char(15)               | Item number (output)          |
| `d_vinf`        | DS (245 bytes)         | Item information (output)     |
| `d_einf`        | DS (96 bytes)          | Unit information (output)     |
| `d_eane`        | char(3)                | EAN sales unit code           |
| `hirec`/`horec` | DS (120/80 bytes)      | Price calculation parameters  |
| `w_lage`        | int(2,0)               | Store/warehouse code          |
| `w_prgr`        | char(2)                | Price group                   |

---

## Conclusion

`BU921R` is a central item lookup and pricing module in a retail back-office or point-of-sale (POS) context, with robust business logic to support multiple kinds of scanned product identification, rigorous mapping to product/unit/price structures, and error handling for edge cases.

If you are onboarding to maintain, extend, or interface with this program:
- Pay attention to the subroutine `scanning` for code interpretation.
- The interface to price (`VP900R`, etc.) and external master file calls is critical.
- Many fields are overlaid, so mapping fields to database layouts and understanding business rules is essential.
- The code is well-commented in Norwegian, and version control is maintained in the header for tracking changes.