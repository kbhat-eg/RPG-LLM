# Overview

This RPG program processes incoming EDI orders (Type: Order) for a Norwegian system. It parses and processes EDI message records, mapping them to internal order header and line structures. The program reads records from an input file, interprets their type, and calls the appropriate subroutine to handle each record. At the end, it writes order headers and lines to output files and can send notifications.

---

## File Definitions

- **nwebpf**: Input file (containing EDI lines to process).
- **frlevl1, frkunl5, fvvarl3, fvvarl4, nohelu, nodtlu, fusrl1**: Various database files used for lookups, output, or reference (with some renamed record formats).

---

## Variable and Data Structure Declarations

- **LDA variables (l_user, l_firm)**: Loaded from the user data area, typically for audit information.
- **Key Variables**: Variables used to access database records by key.
- **Working Variables**: For firm number, item number, descriptions, etc., including types and initialization.
- **Constants**: Like 'EDI' to indicate EDI orders, digit and character sets.

### EDI Data Structures

For each type of EDI record (ED00–ED13), there's an 80-character buffer with overlays mapping pieces of the buffer to specific fields. For example:
- **d_ed00**: Message Initialization (ID, sender, receiver, date, etc.)
- **d_ed01**: Message Header (type, version, reference, etc.)
- ...
- **d_ed13**: Free text for order lines

---

## Main Program Loop

1. **Initialization**: Some flags reset (`b_oskr = *off`).
2. **Input Loop**:
   - `read nwebpf` — Reads a record from the EDI input file.
   - Loops until EOF.
   - For each record, extracts first 4 characters as the record type (`w_rect = %subst(ordlin:1:4)`).
   - Uses a `select-when` block to call the appropriate subroutine for each EDxx record type.

3. **Exit/Wrap-up**:
   - If there is a pending order line (`b_blin = *on`), writes it.
   - If there is a pending order header (`b_oskr = *on`), sends notification to order handlers.
   - Sets LR indicator on to end the program.

---

## Record Type Subroutines

Each `EDxx` (e.g., `ed00`, `ed01`, etc.) has a dedicated subroutine that processes the contents of that EDI record:

### Header/Order Level
- **ed00**: Initialize message, get message number, reset header data
- **ed01**: Read header, extract reference, set header flag
- **ed02**: Header free-text, concatenate to variable
- **ed03**: Reference, extract customer reference if present
- **ed04**: Party info, lookup customer by EAN, fill customer/address fields
- **ed05/ed06**: Receiver name/address details, update shipment fields
- **ed07**: Company registration, contact info, etc.

### Item/Line Level
- **ed08/ed09**: Communication/transport info (not much processing shown)
- **ed10**: Item record. Checks if any previous line or header needs to be written, then parses and prepares new line. Calls `finn_vare` to find item number by various methods.
- **ed11/ed12/ed13**: Item text, quantity/info, or free text.

---

## Key Helper Subroutines

### `finn_vare` (Find item)

Tries to determine internal item number for a line, in this order:
1. **Logistics item number**: SQL lookup in `vvlepf` using the alternate number.
2. **NOBB number lookup**: Chain with vvarl3 key.
3. **EAN lookup**: Calls an external program `VE710R` to get internal number from EAN.
4. **Supplier's item number**: Repeats logistics check using alternate supplier number, then chains with vvarl4 key.

Returns as soon as a valid item number is found.

### `skriv_hbest`, `skriv_lbest`

Write (or update) order headers (`nohelur`) and lines (`nodtlur`). If they don't exist, create with current datetime, user, etc. Flags are managed (`b_bhod`, `b_blin`, `b_oskr`) to track what needs to be written.

### `null_hbest`, `null_lbest`

Clear all working variables for new order header or line.

### `hent_mnum`

Gets the next EDI order message number by calling program `AS100R` and updates relevant fields.

### `send_melding`

Iterates through users in `fusrl1` file, and for those with `fbko10 = 1`, calls program `NN821C` to notify them.

---

## Initialization Subroutine (*INZSR)

- Defines key lists for accessing files.
- Sets the company number and current date/time for use during processing.

---

## Indicator Usage

From comments:
- `LR`: End of program
- `80-89`: Work indicators
- `90-99`: File indicators

---

# High-Level Process Flow

1. **Input Loop**: Read each line of EDI data (`nwebpf`).
2. **For Each Record**:
    - Parse type (ED00..ED13)
    - Call handler subroutine, update buffers/fields as needed
    - When a logical point is reached (new order, new item line), write out prior header/line.
3. **Finalization**: Write any pending data, send notifications.
4. **End**.

---

# Onboarding Key Points

- **Message types**: Each EDxx record type corresponds to a fragment of an order.
- **Data extraction**: Uses overlays and string manipulation to parse fixed-length EDI records.
- **Lookups**: Item and customer references are mapped by keys or external calls.
- **File structure**: Separation of header (`nohelu`) and line (`nodtlu`) data.
- **Error handling**: Minimal in this code; relies on found checks and flags.
- **Extensions**: Several notes show the program was extended and maintained over time (item number length, new data sources, etc.).
- **Norwegian comments**: Variable naming and comments follow Norwegian conventions; be aware of terminology.

---

# Summary Table

| Section                  | Purpose                                                                |
|--------------------------|------------------------------------------------------------------------|
| File Definitions         | Input, output, and lookup databases                                    |
| Variable/DS Declarations | Working variables, EDI data overlays                                   |
| Main Loop                | Reads EDI input, dispatches by record type                             |
| `edxx` Subroutines       | Parse/process each EDI record type, updating buffers/fields            |
| `finn_vare`              | Resolves item numbers from various possible references                 |
| Write Subroutines        | Write headers/lines to output files if needed                          |
| Nulling Subroutines      | Reset working variables for new header or line                         |
| Message Number Subr      | Fetches/assigns new message number for each EDI order                  |
| Send Message Subr        | Notifies users for new incoming order, if applicable                   |
| Initialization           | Sets up key lists and general values for processing                    |

---

# Conclusion

This program is a typical RPG batch parser/mapper for EDI orders, mapping standardized input records to internal data structures, doing database lookups, and writing output. It is organized around the sequential processing of EDI messages and flexible enough to support extensions for new data fields and cross-references. The logic is clear, and once variable naming conventions are understood, onboarding should proceed smoothly.