# Explanation of RPG Program: NO124R

## Overview

This RPG program, named **NO124R**, is designed for an IBM i (AS/400) environment, using ILE RPG IV. Its purpose is to transfer external order header information from a "bestilling" (purchase request/order) to an "ordre" (sales order). This involves copying header and line-level data, handling number assignments, updating cross-references, and checking credit and other customer constraints.

The program is highly integrated with the file system (DB2 physical and logical files), and includes handling for various customer-specific and type-specific rules. It has detailed revision history comments at the top for traceability.

---

## Program Controls and Files

### Header Specifications

```rpg
h option(*nodebugio) datedit(*dmy)
```
- **option(*nodebugio):** No debug IO generated (for performance).
- **datedit(*dmy):** Date edit format is day-month-year.

### Files

There are many files declared, some as input (`if`), some as update (`uf`), and some as display (`cf`). Many files are logical files over physical files, using the `rename` keyword to define short record formats.

Examples:
```rpg
flohel1    if   e           k disk    rename(lohepfr:lohel1r)
flohelu    uf   e           k disk    rename(lohepfr:lohelur)
fno120d    cf   e             workstn
```
- `workstn` file for workstation (display) access
- Files for order header, order details, customer master, cross-reference, etc.

---

## Data Structures, Variables, and Parameters

- Program uses many standalone fields for keys, amounts, states, etc.
- Parameter fields for entry (order number, suffix, customer number, etc.).
- Local Data Area (LDA) access for user and workstation info.

Example parameter setup:
```rpg
d p_firm          s                   like(ldfirm)
d p_numm          s                   like(ldnumm)
d p_suff          s                   like(ldsuff)
d p_kund          s             20
d p_avde          s                   like(ldavde)
d p_lage          s                   like(ldlage)
```

---

## Main Processing Flow

### 1. Program Start (*inzsr Subroutine)

- Receives parameters from the caller and initializes key lists for file access.
- Retrieves company info, and loads some properties/settings (like VAT % and memo days) from the database or properties file.

### 2. Fetch and Validate Source Order

- Fetches the purchase order header (bestilling), using `chain`.
- If not found, ends.

### 3. Determine Order Type

- Sets default order type from purchase header.
- If project or warehouse info exists, attempts to override order type by reading property files or value tables.

### 4. Initialize Customer and Credit Information

- Transfers customer from parameter/purchase header to internal variables.
- Fetches customer info, including credit limit and status, using a `chain`.
- Calls external programs to fetch credit balance (memosaldo) and possibly extended memo info for the customer (if switched on).
- Checks credit limit, possibly modifies it based on group/company rules.

### 5. Check Allmenning Limits

- Retrieves and checks "allmenning" (common pool/grant) credit information, possibly by calling an external program if not available directly.

### 6. Display Input Screen

- Presents a screen to the user (exfmt) for further validation or information (not detailed here).
- If user presses F3 or customer is credit blocked, program ends.

### 7. Order Header and Line Generation

#### a. Create Order Header (exsr ordre_hode)

- Calls subroutine to find the next available order number (exsr hent_nummer).
- Initializes the new order header, copying fields from the purchase (bestilling) header and customer master.
- Writes new order header to the output file.

#### b. Create Order Lines (exsr ordre_linje)

- Reads all line items from the purchase order.
- For each line:
  - Checks and possibly adjusts unit of measure (if sales unit differs from purchase unit).
  - Calls programs to build order lines (either item lines or text lines).
  - Updates cross-references between purchase and sales order lines (bidirectionally).
- Each line is assigned a new line number (increments by 10).

#### c. Update Totals (exsr oppdat_ordre)

- Reads all order lines just created to sum up order totals.
- Calculates discounts and brackets (various rebate fields).
- Calls program to adjust memo balance with the new order.
- Updates order header with the calculated totals.

### 8. Final Updates

- Updates the source purchase header with the new sales order number, if none is set.
- Calls external program to trigger post-processing (order workflow).
- Ends processing by setting *inlr = *on (last record indicator, ends the program).

---

## Special Subroutines

- **hent_nummer:** Gets the next available order number, considering order type and possible overrides.
- **hent_linjenr:** Determines the highest existing order line number, so new lines continue numbering correctly.
- **sjekk_enhet:** Checks if the unit of measure is valid for sales; if not, adjusts the quantity and unit.
- **oppdat_ordre:** Sums and updates order totals, discounts, and posts these to the memo system.

---

## Key Business Rules & Features

- Handles **order type overrides** via property tables or configuration.
- Credit and memo (temporary) balances are **strictly controlled**, with possible group (Mestergruppen) extensions.
- Strict **cross-referencing between purchase and sales order lines** for full traceability.
- Various customer and item fields are **propagated from source to target** with fallbacks if blank.
- Modularizes business logic via external program calls, for number assignment, credit checks, etc.
- **Extensively commented with revisions**, which is important for maintenance.

---

## Special Switches and Extensions

- Large parts are **switch-controlled**: e.g., whether to use memosaldo extensions, or how to handle discounts.
- Program supports **future-proofing for number fields** (e.g., when order numbers might become longer), as seen in comments.
- Handles **unit conversions** for items if unit is not directly valid for sales.

---

## Error and End Handling

- Program ends gracefully if any major lookup or constraint fails (e.g., purchase order not found, credit block).
- Updates source with generated order numbers for traceability.

---

## Conclusion

This program is a classic example of an order conversion/migration utility commonly found in ERP systems, responsible for automating the transfer and synchronization of transactional data between purchasing and sales modules, with heavy validation and integration.

### New Developers Should Pay Attention To:

- The **structure of file access** (CHAIN, READE, SETLL etc.).
- The **way parameters and keys are used** and passed around.
- The **modularization via subroutines and external calls** for business logic separation.
- The **many data integrity checks** performed at each step (credit, reference cross-links, units).
- The **historical comments**â€”they provide valuable information on why code may look convoluted in some areas.

**Tip:** Walk through the code in debug with a simple order to see the flow in action. Remember, much of the actual business logic sits in the called external programs (e.g., FA922R, FO763R, VA752R), so review those as needed!