# Overview  
This RPG ILE program (JR789R) reads a grossist-file with record format **KWB**, matches each line by EAN-number against existing items in the `LVR` file, and then either:  
  • Updates the price for an existing item (if found)  
  • Creates a new price entry under the supplier if it’s a newly discovered item  

Finally, if a price was changed or created, it calls a secondary program (`JV790R`) to update search text for that item.

---

## 1. File and Data Definitions  

### 1.1 Files  
• **KWB** (external input file `jrvapf`) – Source data from grossist  
• **JRAP L1** (`jrapl1`) – Report user definitions  
• **JLEV L1** (`jlevl1`) – Supplier definitions  
• **JVAR LD** (`jvarld`) – Item master, keyed by EAN  
• **JVPR L2** (`jvprl2`) – Price lookup file, keyed by (supplier, item)  
• **JVPR LU** (`jvprlu`) – Price update file (read/for update)  

### 1.2 Parameter List  
Incoming parameter `p_list` (32 bytes) is overlaid by a data-structure containing:  
- `d_firm`  (3,0) — Company  
- `d_rapp`  (2,0) — Reporter  
- `d_dato`  (date) — Extract date  

### 1.3 Input Record Layout (KWB)  
Overlayed on a 101-byte input buffer `d_inpu`:  
- `d_vare`   (chars 1–8)  – Item code from supplier  
- `d_eann`   (10–22)       – EAN number  
- `d_tek1`   (24–63)       – Main group text  
- `d_pe`     (64–68)       – Sub-group  
- `d_enhe`   (69–73)       – Article group  
- `d_ve`     (74–78)       – Description  
- `d_san`    (79–83)       – Size  
- `d_pris`   (84–93)       – Unit price as packed decimal  
  • `d_pris_kr` (1–7)  
  • `d_pris_ore`(9–10)  
- `d_side`   (94–98)       – Units per package  
- `d_xx`     (99–100)      – Discount code  

---

## 2. Program Initialization (`*INZSR`)  
1. **Parameter unpack**:  
   • `d_list = p_list`  
   • `w_firm = d_firm`  
2. **Define key lists** for lookups:  
   - `jrapl1_key` → (`w_firm`, `jrapl1_rapp`)  
   - `jvprl2_key` → (`ldor`, `lvar`)  
   - `jvprlu_key` → (`vare`, `ldor`)  
   - `jvarld_key` → (`ean1`)  
   - `jlevl1_key` → (`ldor`)  

---

## 3. Main Logic  

1. **Load reporter info**  
   • `jrapl1_key chain jrapl1` by `(w_firm, d_rapp)`  
   • If not found → exit  

2. **Load supplier info**  
   • `jlevl1_key chain jlevl1` by supplier number from `jrapl1`  
   • Normalize supplier name to uppercase  

3. **Call subroutine `BEHANDLING`**  

4. **Clean up and return**  
   • Set `*INLR = *ON`  

---

## 4. Subroutine BEHANDLING  

This loop reads each record from the KWB file and processes:  
```  
READ jrvapf; DOW not %EOF; … READ jrvapf; ENDDO  
```  
Steps per record:  
1. **Move raw input** → `d_inpu`  
2. **Skip bad item codes**: if any non-digit in `d_vare`, goto next  
3. **Normalize spaces** → zeros in `d_eann` and `d_pris`  
4. **Trim** `d_vare` and copy `d_eann` → work fields  
5. **Lookup price** in `JVPRL2` by `(supplier, d_vare)`:  
   – If found → call subroutine `ENDR_PRIS`  
   – Else       → call subroutine `OPPR_PRIS`  
6. **If price was changed or created** (`jxvare <> *BLANK`):  
   – Call program `JV790R(w_firm, jxvare, b_inlr)` to update search text  

---

## 5. Subroutine OPPR_PRIS (Create New Price)  

1. **Skip if no EAN**  
2. **Find item master by EAN** in `JVARLD`  
3. **Delete any existing price entries** for this `(item, supplier)` in `JVPRLU`  
4. **Prepare new `JVPRLU` record**:  
   • `vjvare` ← item  
   • `jxldor` ← supplier  
   • `jxlvar` ← supplier’s item code  
   • `jxpris` ← price packed (kr + øre)  
   • `jxgdat` ← invoice date  
   • `jxtdat` ← low‐value  
   • `jxrsts` ← 1 (new status)  
   • `jxeusr` ← user ID  
   • `jxodat`, `jxedat`, `jxetim` ← current time  
5. **WRITE jvprlur**  

---

## 6. Subroutine ENDR_PRIS (Update Existing Price)  

1. Compute new price → `w_pris`  
2. If identical to existing `jxpris` → exit  
3. **CHAIN jvprlur** by `(item, supplier)`  
4. Update fields:  
   • `jxlvar` ← new supplier item code  
   • `jxpris` ← new price  
   • `jxgdat` ← invoice date  
   • `jxtdat` ← low‐value  
   • `jxeusr` ← user ID  
   • `jxedat`, `jxetim` ← current time  
5. **UPDATE jvprlur**  

---

# Key Takeaways for Developers  
- The program uses parameter passing via a 32-byte list and loads company, reporter, and date.  
- All file lookups use keyed `CHAIN` or `SETLL/READE` logic to find or delete existing records.  
- There are two main data‐handling branches:  
  • **OPPR_PRIS** – When no existing price entry, but item master exists  
  • **ENDR_PRIS** – When price entry already exists but amount changed  
- After any change, a secondary program (`JV790R`) is invoked to recalculate or rebuild item search text.