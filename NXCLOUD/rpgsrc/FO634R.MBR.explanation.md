# RPG Program Explanation: FO634R

This program is a classic IBM i (AS/400) ILE RPG program designed for processing and generating a control list and picking orders for distribution/logistics (the comments and field names are in Norwegian; "kontroll-liste" = control list, "plukker" = picking). The program is responsible for extracting and sorting relevant order records based on a series of selection criteria, then writing records to a sort/pick register file for further processing or reporting.

Below, the RPG code's architecture and intent are explained, focusing on the main program flow, file usage, data structures, logic, and subroutines that new developers should be aware of.

---

## 1. **Header and Program Metadata (`H`-spec and Comments)**

- `H datedit(*dmy) option(*nodebugio)`
  - Date fields use the day/month/year format.
  - Disables RPG's debug IO, which can impact how files are traced in debug.

- The comments document the system, program, version history, and enhancements. They trace significant function changes over many years.

---

## 2. **File Declarations (`F`-specs)**

The program uses several files, all renamed to program-unique record formats:

- **Customer file**: `RKUNPFR` → `rkunl1r`
- **Order header file**: `FOHEPFR` → `FOHEL1R`
- **Order detail file**: `FODTPFR` → `FODTL1R`
- **Order text file**: `FOTXPFR` → `FOTXL1R`
- **Pick parameter file**: `FPLOPFR` → `FPLOL1R`
- **Pick/sort file**: `FPSOPFR` → `FPSOLUR`
- **Short-term control file**: `fntrpfr` → `fntrl1r` (`5.31`)
- **Customer project file**: `fkprpfr` → `fkprl1r` (`6.30`)
- All files are keyed disk files, some updated/written to.

---

## 3. **Data Structures (`D`-specs)**

- **Sorting key structure** (`sorter`, `sor001`-`sor007`): Used to build complex sorting keys for flexible output order.
- **Parameter input structure** (`LDPREC`): Overlay of input parameters containing order number range, customer range, dates, selection codes, etc.
- **Pricing structures** (`hirec`, `horec`): Used for interfacing with price lookup subprograms (`VP900R`); contain product, customer, and price information.
- **Working variables**: For order numbers, firms, suffixes, price groups, etc.

---

## 4. **Local Data Area (LDA) Usage**

- Some fields are mapped to the LDA (positions 901+, such as workstation ID or user), reflecting IBM i's tradition of passing control/environment info via LDA.

---

## 5. **Main Program Logic**

### **Initialization (`*INZSR` subroutine)**

- Clears working variables and prepares field equivalence mappings ("*LIKE DEFINE").
- Maps LDA firm number (`DSSFIR`) into all necessary key fields for subsequent database operations.
- Builds key lists (`KLIST`) for efficient chained reads/writes.

### **Entry Parameters**

- Accepts an input parameter structure (`WWPARM`, 84 bytes) that is moved to various working fields used throughout the logic.

### **Order Header Processing Loop**

The main order processing uses a loop structure to step through the order header file, applying multiple filters:

#### **Selection/Filtering Logic**

For each order header record:

1. **Order Number Range**: Skips orders outside the desired range.
2. **Order Type**: Skips records of an unwanted order type.
3. **Customer Number Range**: Excludes records where customer is outside specified range.
4. **Order Date Range**: Selects only orders within a specified date range.
5. **Packing Slip Date**: (3.31) Excludes records where this date is outside the desired range.
6. **Department and Route**: (V3.20) Checks if the record matches the chosen department and delivery route, if specified.
7. **Info Code**: (5.01) Filters by info code if required.
8. **Alternative Invoicing**: (5.31) If alternative invoicing is used, checks validity in the short-term control file.
9. **Customer Project Sequence**: (6.30) Compares order or project sequence to parameter.
10. **Pick Register / Control Code Filtering**: Additional logic checks depending on parameter values (e.g., whether record is "picked" or "controlled").

#### **Price Group Retrieval**

- Calls a subroutine to retrieve the price group for the current order/customer context via program `VL712R`.

#### **Extracting and Sorting**

If an order passes all filters:

- **Sort Key Construction**: The program assembles a sort key from order number, suffix, dates, customer, etc., depending on sort mode.
- **Pick/Sort Record Writing**:
  - Order heading and possibly text lines are written to the sort register (`FPSOLUR`).
  - Detail lines are processed, validated, and conditionally written out.
  - Uses subroutines (`LINJE`, `OHEAD`, `FORAN`, `ETTER`) for detail lines, heading, text-before, text-after.
- **Post-processing**:
  - Optionally, if specified, calls a subprogram (`FO412R`) to clear the "picked" flag and handling codes in the header after output.

---

## 6. **Subroutines**

Several named subroutines handle modular tasks:

- **OHEAD**: Writes/updates order heading records in the sort register.
- **LINJE**: Reads order detail lines, checks their validity (calls `SJEKK`), and writes valid lines to the sort register.
- **SJEKK**: Applies business rules to detail lines (e.g., compares actual vs. standard prices/discounts, calculates margin).
- **FORAN/ETTER**: Extracts and writes text lines before ("foran") and after ("etter") the order to the sort register.
- **HNTVAR**: Retrieves product information and invokes the pricing subprogram (`VP900R`).
- **hent_prisgr**: Calls an external program (`VL712R`) to fetch the customer price group.
- **\*INZSR**: One-time program initialization, described above.

---

## 7. **External Program Calls**

- **VP900R**: For price calculation/lookup based on a set of input fields.
- **VL712R**: To determine customer price group.
- **FO412R**: To clear pick flags in the order header after printing.

---

## 8. **Sorting Logic**

The sort key is flexibly constructed using the "sorter" structure, allowing for sorting by date/time, customer/address, or other criteria as driven by input parameters.

---

## 9. **Business Rules**

- Only output orders/lines that meet a complex matrix of business filters (dates, types, customer, project, route, department, pick/controlled status).
- Supports different modes for what to pick/control and what part of the order to output.
- Ensures that output respects user-specified selection and sorting criteria.

---

## 10. **Notes on Style and Modernization**

- Code uses classic OPM (Original Program Model) C-specs and D-specs, not free RPG.
- Overlay and field-mapping data structures are heavily used (a common technique in legacy RPG).
- Calls to external programs for business logic separation (price, price group, and pick clearing).
- Extensive use of conditionals to direct the processing flow.
- Comments are a mix of Norwegian and version/maintenance history.

---

## 11. **Summary of Flow**

1. **Initialize**: Set up fields, equates, keys.
2. **Accept Parameters**: Move entry parameter data into fields.
3. **Iterate Orders**: For each order header, perform a multi-stage selection and filtering process.
4. **For Passing Orders**:
   - Determine sorting key.
   - Write out header, texts, and detail records to the sort register.
   - Optionally, clear pick flags.
5. **Repeat Until All Orders Processed**.
6. **End Program**.

---

## 12. **Onboarding Advice for Developers**

- **Understand the Database Model**: Familiarize yourself with the files (`FOHEPFR`, `FODTPFR`, etc.) and their key structures.
- **Parameter Mapping**: Know how parameter fields in `LDPREC` (input structure) control selection and sorting.
- **Subroutines**: Each subroutine (`LINJE`, `SJEKK`, `HNTVAR`, etc.) encapsulates a distinct business rule or functional step.
- **Sorting and Output**: The mechanism for generating output involves assembling a "sorting string" that drives both the order of output and the structure of the pick/sort register.
- **Integration Points**: Calls to external programs handle specific responsibilities (especially pricing and customer group logic).
- **Legacy Syntax**: The program uses fixed-form RPG IV (ILE RPG), but is structured in a modular, subroutine-based style that supports maintainability.

---

By understanding the above structure and flow, developers can effectively navigate and maintain the application, extending or modifying its logic to accommodate new business requirements as needed.