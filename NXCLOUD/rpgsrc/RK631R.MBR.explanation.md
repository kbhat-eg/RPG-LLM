# RPG Program Explanation: RK631R "Hjelperegister for saldoliste"

This RPG (Report Program Generator) program, used on IBM i (AS/400), is a utility for building a helper register for a "saldoliste" (balance/aging list). Its purpose is to aggregate and sort customer balances and transactions by various categories such as customer, department, or salesperson, including special handling for aging buckets and collections.

Below you'll find a structured and detailed explanation, suitable for onboarding new developers.

---

## 1. **Header and Documentation**

- **Program**: RK631R
- **Description**: Helper file building for balance lists; aggregates aging information for customers.
- **System**: ASOKON
- **History Log**: The header describes various changes across versions. Notable changes include bug fixes, addition of department/salesman selection, use of date fields, improvements to aging, and logic for collection handling.

---

## 2. **File Definitions**

```rpg
frkunl1    if   e           k disk    rename(rkunpfr:rkunl1r)
frktrl1    if   e           k disk    rename(rktrpfr:rktrl1r)
...
frkw1pf    o  a e           k disk
```

- **Input Files**:
    - `frkunl1`: Customer master, used for looping customers.
    - `frktrl1` ~ `frktrl9`: Customer transaction files, for various selection criteria.
    - `fra01l1`, `fraa3pf`: Code/parameter files.
- **Output File**:
    - `frkw1pf`: The helper file created/updated (probably the "helper register").

File member names are sometimes renamed for clarity in the program.

---

## 3. **Variable and Data Structure Definitions**

### Arrays

- `sub`, `bko`, `per`: Used for summarizing values for reporting/aging (e.g., periods).

### Data Structure `wkwrec`

Represents the output record to be written, with overlays for logical fields:
- `wkfirm`, `wkkund`: Company and customer numbers.
- `wknavn`, `wkkper`, `wktlfn`: Name, contact, telephone number.
- `wksald`: Balance
- `wkbel0` ... `wkbel4`: Aging buckets (Not due, 0-A, A-B, ...)
- `wkinka`: Amount sent to collections.
- `wkkjop`: Purchases
- `wkotid`: Average credit days

### Work Variables

Many variables are defined using `like()` to match field types from external files. These include working balances (`w_belo`, etc.), counters, accumulators, and key structures.

---

## 4. **File Parameter/Codes Import**

```rpg
d/COPY QCPYLESRC,RPARRKDS
```
- Brings in a copybook with parameter structures, likely shared with other related programs.

---

## 5. **Input Specifications (`I` specs)**

These lines relate to pulling aging parameters from the code table (e.g., each `ra3p0X` is put into the `per(X)` array for monthly periods).

---

## 6. **Main Logic (`C` specs)**

### a. **Main Loop - Over Customers**

```rpg
c     rkunl1_key    setll     rkunl1
c     rkunl1_key    reade     rkunl1                                 98
...
c                   enddo
```

- Loops through all customers (`rkunl1`). Reads with a key, processes while not end-of-file (`*in98`).

#### **Customer Selection**

- Skips customers outside specified category/number range.
- Initializes variables for each customer (contact, phone, etc.).

#### **Populate Work Variables**

- Uses data from master record; resets accumulation variables.

#### **Transaction Reading and Aggregation**

- Calls subroutine `les_trans` (read transactions for the customer).
- Calls subroutine `brd_kunde` (write output and reset accumulators).

### b. **Subroutine: `les_trans` (Read Transactions)**

- Sets up keys for each transaction file based on the current customer.
- Selects and reads the relevant transaction file based on selection parameters (`pavds`, `psels`, `prdagx`, `pkjop`).
- For each transaction for that customer:
    - Looks up department and salesman if missing.
    - Skips records outside selected department/salesman.
    - Handles "break" logic if department or salesman changes during loop (calls `brd_kunde` each time).
    - Skips records outside selected fiscal year/period.
    - Calls either `beregn_dagens` (calculate current period) or `beregn_tidlig` (past period), based on flags.
- Iterates until all relevant transactions are processed for the customer.

### c. **Subroutines for Transaction Processing**

#### **`beregn_dagens` (Calculate for Current Period)**

- Calculates due days (`w_fodag`).
- If balance > 0, calculates average credit days.
- Calculates current-year purchases if criteria match.
- Updates balance and aging buckets (`w_bel0`...`w_bel4`) based on how overdue the transaction is.
- If collections code (`rninko`) is set to 'I' or 'J', adds to `w_inka`.

#### **`beregn_tidlig` (Calculate for Past Period)**

- Similar to `beregn_dagens`, but uses the period date rather than today's date for due calculation.
- Fetches reference document date if cleared by reference.
- Handles purchases, balance, aging, and collections as above.

#### **`brd_kunde` (Write Customer Totals / Output)**

- Outputs accumulated fields to the output file (`frkw1pf`).
- Handles negative values in aging (moves negatives up to oldest bucket).
- Calculates average credit time if applicable.
- Sets sorting/group-by variables based on selection (category, department, salesman, or balance).
- Resets accumulators for the next customer or group.

### d. **Initialization Subroutine (`*inzsr`)**

- Sets up work fields, keys, and initial values.
- Prepares parameter tables for period aging, code arrays, etc.

---

## 7. **Additional Details**

- **Aging Logic**: The program handles aging buckets (current, overdue by various intervals) and dynamically places amounts into buckets depending on how overdue they are.
- **Collections**: Special logic to sum up what has been sent to collections (inkasso).
- **Break Logic**: When breaking on department or salesman, writes out totals and resets accumulation for sub-totals.
- **Sorting and Grouping**: The output can be sorted/grouped by various criteria set via parameters.
- **Modularity**: Uses subroutines to encapsulate logic for reuse and maintenance.

---

## 8. **Key Parameters and Flags**

- Most selection/control is done via input parameters (`p*` variables), not shown directly but implied.
- These influence file reads, grouping/sorting, and aging calculation types.

---

## 9. **Summary Table Structure**

Each output record contains:
- Customer identification and contact info
- Balance, purchases
- Amounts in each aging bucket
- Amount sent to collections
- Average credit days

---

## 10. **Typical Flow**

1. **Init**
    - Prepare key structures, parameter arrays, and code tables.
2. **Loop over customers**
    - For each customer, select if in range.
    - Process transactions according to rules/parameters.
    - Aggregate balances into buckets.
    - Write output and reset for next customer or group.
3. **End**
    - Trigger program end and cleanup.

---

## 11. **Onboarding Tips for Developers**

- **Parameterization**: The program's behavior is highly parameterized via input fields and code/reference tables. Look for these in the calling CL or setup.
- **File Layouts**: Understanding of the external files is key (customer master, transactions, code files). Use `like(field)` definitions to find corresponding fields.
- **Debugging**: Note that `option(*nodebugio)` means you won't be able to debug IO operations.
- **Extensions**: For enhancement or troubleshooting, focus on the subroutinesâ€”each encapsulates a distinct business rule.

---

## 12. **References**

- Check the included copybook (`/COPY QCPYLESRC,RPARRKDS`) for parameter and data structure definitions.
- Review the historical comments in the header for past bugs or changed logic.

---

### **In Short**

This program processes customers and their transactions to produce a detailed aging and balance file for downstream reporting or analysis, with flexible grouping, selection, and aging logic. The code is well-structured into subroutines for clarity, and each section maps directly to a business requirement.