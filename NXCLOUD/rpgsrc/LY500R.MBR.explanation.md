# RPG Program Explanation: LY500R - Query/Search for Deleted Orders

This RPG source code is for the ILE RPG program `LY500R`, which provides a green-screen UI to query or search for deleted orders in an IBM i (AS/400) environment. The program uses subfiles for list display and allows a variety of search and navigation methods.

Below is a structured walk-through and explanation for developers:

---

## 1. General Overview

- **Purpose:** The program enables users to search for and inspect deleted orders using various criteria such as year, order number, date, type, etc.
- **User Interface:** Employs display files (workstation files with subfiles) to present and navigate the data.
- **Customization:** Several enhancements and bug fixes are noted in comments with different change signatures.

---

## 2. File Definitions

```rpg
fldellr ... fldell7   : Logical files (likely over LDELPFR) for different access paths to deleted orders.
fvotyl1                : Logical file over VOTYPFR (order type).
frlevl1                : Logical file over RLEVPFR (order handler/related entity).

fly500d                : Workstation file defining the display, with `b1sfl` as the subfile, and INDS for feedback.
```

**Purpose:** These files support various ways to read, search, and position in the database of deleted orders.

---

## 3. Data Structures and Variables

### Local Data Area (LDA) fields

- `l_wsid`, `l_user`, `l_firm`, `l_fnav`: Retrieved from the LDA for firm, user info, etc.

### Display Feedback Structure

- `dspfbk`: Used to get the cursor position from the display file.

### Key Variables for File Access

- Variables like `ldell1_aarr`, `ldell1_numm`, etc., are used to build keys for accessing logical files.

### Work Variables

- `w_fcrn`, `w_spge`, `w_srrn`, etc.: Used for subfile paging - tracking page size, first/last record numbers, etc.
- `w_kjop`, `w_seqe`, `b_forn`, `b_feil`: Various working variables for formatting, logic control, etc.

---

## 4. Indicator Usage

Indicators control function key handling, subfile management, display attributes, error signaling, etc.

- Example:
    - `*IN10` = Roll (page-down)
    - `*IN14` = Sflclr (Clear subfile)
    - `*IN15` = Sflend (End of subfile)
    - `*IN21` = Home-key
    - `*IN22` = Cursor positioning

---

## 5. Main Program Logic

The main control flow is organized around display/send/receive cycles and function key handling, using tags like `b2taga` and `b2tagb`.

### Event Handling

- **Function Keys:** Use `select` and `when` to branch on function key indicators, e.g., F1 for alternatives, F3/F12 for exit, F5 for refresh, F23 to toggle display.
- **Subfile Paging:** Handles roll and cursor movement, page up/down, and positioning within the subfile.

### Input Field Checking

- Input validation via subroutine `xsjekk_inp`, especially for date fields.

### Positioning

- Calls `posisjoner` subroutine to set file position based on user input (year, order number, type, etc.), followed by subfile load.

### Subfile Handling

- Subroutine `crt_subfile` populates the subfile based on current positioning and selection logic.
- `clr_subfile` clears the subfile.
- `dsp_subfile` displays the subfile and handles EXFMT.

### Record Selection

- Handles selection of an entry (typically by setting `b1valg`), then invokes a detail program (e.g., `LY510R` for order details).

---

## 6. Subroutines

### a. forny

Refreshes the subfile based on the current position (could be used after search criteria change).

### b. posisjoner

Positions the logical file pointer based on input fields. Contains detailed logic to handle combinations of search fields.

### c. subfile

Reads user selection from the subfile, processes actions (like viewing details), and manages 'refresh required' signals.

### d. xsjekk_inp

Input checking, especially for date validation (`test(d)` opcode).

### e. xh1win

Handles the display and logic for the F1 "alternatives" pop-up window.

### f. clr_subfile

Clears the subfile and associated tracking variables.

### g. crt_subfile

Populates the subfile. This section demonstrates:
   - Reading appropriate logical file based on current search mode.
   - Filtering records for firm, order type, user, and handler.
   - Formatting and writing subfile records.

### h. dsp_subfile

Handles rendering the control screen of the subfile, sets indicators for display.

### i. spørring

Invokes external query programs for specific fields (e.g., for order type or handler).

### j. *inzsr (initialization)

Sets up keys, loads firm number from LDA, initializes screen headings, gets the current date, and loads the first page of the subfile.

---

## 7. Key Lists

Defines several key lists for different access paths in logical files, e.g., to position or chain to records efficiently.

---

## 8. Comments and Norwegian Terms

- The code is well-commented, mostly in Norwegian.
    - "lylle" = load/fill (a subfile), "slettede bestillinger" = deleted orders, etc.
    - "Bruk av indikatorer" = Use of indicators
    - "Subrutine for ..." = Subroutine for ...

---

## 9. Codes for Subfiles and Screens

- `B1SFL` = subfile for main list
- `B2CTL`, `B2CMD`, `C1BLD`, etc. = control/command/input screens

---

## 10. Program Flow Summary

1. **Initialization**: Prepare keys, set headings, get firm number, today's date, and load the first page of data.
2. **Main Loop**: Display screens, wait for user actions, handle function keys, and process input.
3. **Input Processing**: Validate inputs; if valid, update position and reload subfile.
4. **Subfile Paging/Display**: Handles paging, rolling, and selection within the subfile.
5. **Detail View/Actions**: If an entry is selected, invoke subprogram for details.
6. **Exit**: Set LR, return.

---

## 11. Common RPG OpCodes Seen

- `eval`   : Assignment
- `chain`  : Random access by key
- `setll`  : Set lower limit by key (for sequential read)
- `read`, `readc` : Sequential read, read with lock (for display files)
- `write`, `update` : Write/update subfile or screen records
- `exfmt`  : Write then read a display format
- `select/when` : Multi-branch, similar to switch/case
- `goto`, `tag`, `begsr`, `endsr`: Flow control and subroutine structures

---

## 12. Extension Points and Maintenance

- The program is modular with clear places to add further search criteria, new function key actions, or other processing via subroutines or called programs.
- Easily extended to handle more logical files or search modes, given the selection logic pattern.

---

## 13. Key Takeaways for Onboarding

- **Understand subfile mechanics**: RPG subfile handling is central—loading, clearing, displaying, and reading user input.
- **Indicators**: Indicators drive most display and logic flow—know what each one does.
- **Logical files and keys**: Knowing the data model (how deleted orders are stored and indexed) will help extend or troubleshoot.
- **External program calls**: Details are surfaced in other programs (`LY510R`, `RK500R`, etc.) as needed.
- **Error handling and input validation**: Carefully managed via subroutines and indicators, especially for date inputs.

---

### **Summary Table**

| Area            | Functionality                                              |
|-----------------|-----------------------------------------------------------|
| File Handling   | Multiple logical files for flexible search/positioning     |
| UI              | Subfiles for lists, pop-up windows for alternatives       |
| User Actions    | Function keys for navigation/search/refinement             |
| Data Validation | Dates, keys, and types checked before action              |
| Modularity      | Uses subroutines for all major logic sections             |
| Localization    | Comments and headings are in Norwegian                    |

---

**If you are new to this code or to RPG:**
- Start by tracing program entry, initialization, and display logic.
- Pay particular attention to subfile setup and navigation.
- Familiarize yourself with the indicator usage—it's key to both UI and logic.
- Use the comments as a guide, but be aware of the Norwegian language.

This program is a solid example of classic green-screen, subfile-driven, database-interactive RPG application design.