# Explanation of RPG IV Source Code JR808R

This program is written in IBM ILE RPG (also known as RPG IV). The purpose of the program is to read a file with the record format `LUNA_AVT` (Luna agreement), and then create or update prices for existing items in the LVR system. The comments and variable names are in Norwegian.

Below is an explanation for each significant part of the code:

---

## Header

```rpg
 h option(*nodebugio) datedit(*dmy)
```
- `option(*nodebugio)`: Disables debugging for input/output operations.
- `datedit(*dmy)`: Sets default date format to day/month/year.

---

## File Declarations

```rpg
fjrvapf    if   e           k disk
fjrapl1    if   e           k disk    rename(jrappfr:jrapl1r)
fjlevl1    if   e           k disk    rename(jlevpfr:jlevl1r)
fjvarl3    if   e           k disk    rename(jvarpfr:jvarl3r)
fjvprl1    if   e           k disk    rename(jvprpfr:jvprl1r)
fjvprlu    uf a e           k disk    rename(jvprpfr:jvprlur)
```
- Several physical files are declared for input and update access. Some are being renamed for use in the program to avoid conflicts with record format names.

---

## Data Definitions

### Parameters

```rpg
d p_list          s             32
```
- `p_list`: 32-character variable, receives input parameter.

### Local Data Area

```rpg
d                uds
d l_user                911    920
```
- User space definition; `l_user` is user ID from the user space.

### Parameter List Structure

```rpg
d                 ds
d d_list                        32
d  d_firm                        3  0 overlay(d_list)
d  d_rapp                        2  0 overlay(d_list:4)
d  d_dato                         d   overlay(d_list:6) datfmt(*iso)
```
- Data structure overlays to parse `p_list` into subfields:
  - `d_firm`: Firm code.
  - `d_rapp`: Reporter code.
  - `d_dato`: Date, ISO format.

### Luna Record Structure

```rpg
d                 ds
d d_inpu                       262
d  d_type                        3  0 overlay(d_inpu:1)
d  d_vare                       24    overlay(d_inpu:4)
...
d  d_nobb                        8    overlay(d_inpu:255)
```
- Unpacks a 262-character input record into relevant fields, like type, item number, EAN, description, price parts, discounts, and NOBB number.

### Key Variables

```rpg
d jrapl1_rapp     s                   like(jrrapp)
d jlevl1_ldor     s                   like(jlldor)
d jvarl3_nobb     s                   like(jvnobb)
d jvprlu_vare     s                   like(jxvare)
d jvprlu_ldor     s                   like(jxldor)
d jvprl1_vare     s                   like(jxvare)
d jvprl1_ldor     s                   like(jxldor)
```
- Declares key fields for database access and record lookups, based on the record formats.

### Other Variables

```rpg
d w_firm          s              3  0
d w_pris          s                   like(jxpris)
d b_inlr          s              3    inz(*off)
```
- `w_firm`: Working variable for firm code.
- `w_pris`: Working variable for price.
- `b_inlr`: Used as an "in-use" or flag variable, initialized to off.

---

## Main Program Logic

### Get Reporter Information

```rpg
c                   eval      jrapl1_rapp = d_rapp
c     jrapl1_key    chain     jrapl1
c                   if        not %found
c                   goto      avslutt
c                   endif
```
- Sets up the key for reporter and looks it up in the reporter file. If not found, go to end.

### Get Supplier Information

```rpg
c                   eval      jlevl1_ldor = jrldor
c     jlevl1_key    chain     jlevl1
```
- Sets up the supplier key and attempts a lookup.

### Main Processing (behandling)

```rpg
c                   exsr      behandling
```
- Calls the "behandling" (processing) subroutine.

### Program End

```rpg
c     avslutt       tag
c                   eval      *inlr = *on
c                   return
```
- End of program, sets *INLR (last record indicator) and returns.

---

## Subroutine: behandling (Main Processing)

```rpg
c     behandling    begsr
c                   read      jrvapf
c                   dow       not %eof
    ...
c                   read      jrvapf
c                   enddo
c                   endsr
```
- Reads through all records in `jrvapf`.
- For each record:
    - Loads record into the `d_inpu` data structure.
    - Skips processing unless `d_type` is 300.
    - Skips if `d_nobb` (NOBB item number) is blank.
    - Chains to item master by NOBB number; skips if not found.
    - Cleans up price and EAN fields.
    - Chains to price file. 
        - If price for item/supplier exists: `exsr endr_pris` (update price)
        - Else: `exsr oppr_pris` (create price)
    - Calls another program (`JV790R`) to update search text if item is not blank.
    - Reads next record.

---

## Subroutine: oppr_pris (Create Price)

```rpg
c     oppr_pris     begsr
    ...
c                   write     jvprlur
c                   endsr
```
- Deletes any existing prices for this item and supplier.
- Initializes a new price record:
    - Sets item number, supplier, descriptive text, price values, date, EAN, user, and timestamps.
- Writes the new price record.

---

## Subroutine: endr_pris (Update Price)

```rpg
c     endr_pris     begsr
    ...
c                   update    jvprlur
c                   endsr
```
- Compares existing price (`jxpris`) to new calculated price (`w_pris`).
    - If unchanged, skips update.
- Loads new values from the input data.
- Updates the existing price record.

---

## Initialization (*INZSR)

```rpg
c     *inzsr        begsr
c     *entry        plist
c                   parm                    p_list
    ...
c                   eval      d_list = p_list
c                   eval      w_firm = d_firm
c                   endsr
```
- Initializes program:
    - Receives input parameter (`p_list`), copies it into the data structure.
    - Extracts firm code.
    - Builds all needed key lists for record access.

---

## Keylists

Throughout the code are keylists (`klist` and `kfld`) for each file to facilitate keyed database access. These group together the relevant fields for lookups.

---

# Summary

- The program processes a batch of records describing item prices from input file `jrvapf`.
- For each record of the correct type and with a non-blank item number, it checks if the item exists.
- If so, it either creates a new price or updates the existing one, depending on whether an entry already exists.
- After processing, it may call an external program to update search text for the item.
- All keys, record structures, and parameters are carefully defined and overlaid for efficient parsing and database access.

## Common Norwegian Terms
- **Vare** = Item/Product
- **Pris** = Price
- **Leverandør** = Supplier
- **Rapportør** = Reporter
- **NOBB-nummer** = National product number (for construction/building materials in Norway)

---

## Onboarding Notes

- The program is modular, relying on subroutines for main processing, price creation, and price updating.
- Database access is via keyed operations (CHAIN, SETLL, READE, DELETE, UPDATE, WRITE).
- Input and output file names/record formats may be specific to your environment; check the physical files and formats.
- Main logic flow: Initialization → Lookup keys → Process records → Update/Create prices → Exit.
- Pay special attention to data structure overlays when passing parameters and unpacking records.