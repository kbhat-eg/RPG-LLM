# RPG ILE Program VG810R – Explanation

## General Purpose

This RPG program (`VG810R`) is designed to **update a factor value** (`vgffak`) for average cost prices in a database, using input records from a **semicolon-separated file** (typical spreadsheet export). The logic is intended for batch updates, performing validation and referential checks before updating or inserting records.

The code is mostly written in traditional, fixed-format RPG IV (ILE), with heavy use of data structures and overlays for parsing input lines.

---

## High-Level Workflow

1. **Initialization**: Establishes file definitions, data structures, and parameters.
2. **Input Processing Loop**:
   - Skips the first record (assumed to be a header).
   - Reads each record from the input file.
   - Splits and parses the input line into fields.
   - Performs a series of validations through cross-file lookups.
   - Updates or inserts into the main update file, depending on whether a record exists.
3. **Program End**: Cleans up and exits.

---

## Key Sections Explained

### 1. File Definitions

```rpg
fgjkipf   if   e             disk
fvgkfiu   uf a e           k disk    rename(vgkfst:vgkfiur)
...
```
- **Input File:** `gjkipf` (likely contains the semicolon-separated records)
- **Update File:** `vgkfiu` (renamed as `vgkfiur` in program)
- **Lookup/Reference Files:** Several (`vgkti1`, `rlevl1`, etc.) for validation and cross-referencing fields.

---

### 2. Data Structures

#### a. Input Line Parsing

```rpg
d                 ds
d d_inpu                       256
d  d_firmnr                      3  0 overlay(d_inpu:1)
...
```
- **d_inpu:** 256-character buffer for the input line.
- Overlays allow easy extraction of fields at fixed positions after parsing.

#### b. LDA Structure

```rpg
d                uds
d l_user                911    920
d l_firm                944    946  0
```
- Extracts values from the LDA (Local Data Area), like user and firm.

---

### 3. Variable and Key Field Definitions

Temporary variables to hold parsed or calculated field values, many defined `like()` reference fields from the files for consistency.

---

### 4. Main Program Loop

#### a. Skip Header

```rpg
c                   read      gjkipf                                 15
```
- Skips the first input record (assumed to be the header row).

#### b. Loop Over Input

```rpg
c                   dow       not %eof
   c                   read      gjkipf
   c                   movel     rec1          exclin
   c                   eval      b_ok = *off
   c                   eval      d_inpu = *blank
   c                   exsr      utled_ds
   ...
c                   enddo
```
- Reads each record, copies it to `exclin`, clears flags, and calls the subroutine (`utled_ds`) to parse and validate the record.

#### c. Updating or Inserting Records

If validation (`b_ok = *on`) passes:

- Fills out key fields from parsed data.
- Searches (`chain`) for the matching record.
  - If found, updates with new value and timestamp.
  - Otherwise, creates a new record.

---

### 5. Subroutine: `utled_ds` (Parse and Validate Input Record)

#### a. Field Parsing

- Replaces special characters, handles Norwegian letters (`ø`, `å`, `æ`) as needed.
- Stepwise extraction of each field from the semicolon-separated line:
    1. Company number (`d_firmnr`)
    2. Factor type/text (`d_text`)
    3. Supplier number (`d_levnnr`)
    4. Group numbers: over-group, main group, under group.
    5. Item number (`d_varenr`)
    6. Factor value (`d_faktor`)

#### b. Lookup Validations

- For each parsed code (factor type, supplier, group, item), performs a `chain` lookup in the respective reference file.
- If any referenced value is missing, the subroutine exits early (`leavesr`), and the main loop skips the record.

#### c. Factor Validation

- Ensures the factor field is NOT zero before proceeding.

#### d. Flag for Valid Record

```rpg
c                   eval      b_ok = *on
```
- Only if all validations pass, sets a flag to allow update/insert.

---

### 6. Subroutine: `*inzsr` (Program Initialization)

- Reads the firm number from LDA and sets up key lists (`klist`) for all relevant files.
- Accepts warehouse/location code via parameter (`p_lagr`).

---

### 7. Key Lists

Defines composite keys for all major files to streamline chained lookups and file updates.

---

## Notable Technical Aspects

- **Data Parsing:** The program parses a semicolon-delimited text line without using modern string split functions, relying on `%scan` and `%subst`.
- **Input Validation:** Cross-references each parsed input against “master” files before any update/insert to enforce referential integrity.
- **Use of Overlays:** Makes field extraction from the parsed buffer extremely efficient and idiomatic in RPG.
- **Classic RPG Syntax:** Uses fixed-form RPG, making it less readable for newcomers but very familiar for those with experience in legacy IBM i systems.

---

## Practical Examples

Let’s say an input record looks like:

`001;FACTYPE1;123456;10;20;300;12345678;0.500000`

- **Company:** `001`
- **Factor Type:** `FACTYPE1`
- **Supplier:** `123456`
- **Groups:** Over=10, Main=20, Under=300
- **Item:** `12345678`
- **Factor:** `0.5`
- The program would parse, validate all reference files for existence of each code, and then update or insert the record in `vgkfiu` with the new factor value.

---

## Summary

- **Purpose:** Batch update or insert of factor values for company average cost records, based on spreadsheet input.
- **Validations:** Extensive cross-file validation before any update/insert.
- **Parsing:** Handles semi-colon delimited input using substring operations.
- **Record Handling:** Updates existing records or inserts new ones as needed.
- **Legacy Style:** Written in classic RPG IV fixed-format.

---

This program is robust for its time, providing rigorous input validation and database integrity in a batch processing context, typical of IBM i midrange systems.