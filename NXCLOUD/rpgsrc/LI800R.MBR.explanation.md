# RPG Program Explanation: LI800R ("Hent godkjente pakksedler")

This program is written in legacy IBM ILE RPG IV (RPGLE), and is designed to fetch ("hente") approved ("godkjente") packing slips ("pakksedler"). It reads data from certain "integration" (XP) files, assigns new EDI message numbers, copies data into local (LP) files, then deletes the source records. There are database operations using embedded SQL, as well as native file I/O.

---

## Header and Metadata

- **Option(*nodebugio : *srcstmt):** Controls the debug options.
- **datedit(*dmy):** Sets default date format to day-month-year.

The header contains the program name (LI800R), description, history, and indicator usage.

---

## File Declarations

Six files are declared, with record-level access, and with `rename` to use alternative record names in the program:

```rpg
fxphost    uf   e           k disk    rename(xphost:xphoiur)
fxpkost    if   e           k disk    rename(xpkost:xpkoiur)
flphoiu    uf a e           k disk    rename(lphost:lphoiur)
flpkoi1    if   e           k disk    rename(lpkost:lpkoi1r)
flpkli1    if   e           k disk    rename(lpklst:lpkli1r)
flppai1    if   e           k disk    rename(lppast:lppai1r)
```

- **XP-prefixed** files are integration/incoming tables.
- **LP-prefixed** files are local/accepted tables.

---

## Data Structure and Field Declarations

### Parameters and Local Data Area

- `p_dflldor`: Used as a parameter (unused in the main code, might be legacy/remnant).
- Data area fields (`l_user`, `l_filg`, `l_firm`, `l_fnav`): These are overlays from the user data space (UDS), for current user, company, etc.

### Indicator/Flag Variables

Single-character flags like `b_oppr`, `b_forn`, etc., initialized to *off.

### Working Variables

Variables for company, message numbers, keys, data to pass to SQL inserts, and counters.

- `w_mnum`, `w_aarr`, etc.: Working variables used for message number, year, status, etc.
- `w_lock`: For line-level locking code (version 7.02).

---

## Initialization (`*inzsr` Subroutine)

- Sets up initial values for key fields:
  - `w_firm` = current company,
  - `w_dtyp` = blank,
  - `w_aarr` = current year,
  - `w_stat` = blank,
  - `w_lock` = 0 (if present).

---

## Main Program Flow

### Set SQL Environment

```rpg
C/Exec SQL
C+  Set Option DatFmt=*ISO , commit=*none
C/End-Exec
```
- Ensures SQL operations use ISO date format and no commit.

### Main Loop

```rpg
c     read      xphoiur
c     dow       not %eof
```
- Reads one record at a time from the "XP" host/integration file (`xphoiur`), processes until end-of-file.

**For each XP record:**

#### 1. Assign New EDI Message Number

```rpg
c     if        xhstat = 1
c     exsr      hnt_nummer
```
- If status is '1' (approved?), call subroutine to get the next EDI message number (via external program 'AS100R').

#### 2. Copy Host Record to Local File

- Fields in the working record are mapped from the XP record to the local LP record (`lphoiur`), including EDI number, firm, type, user/date/time stamps, etc.
- Fields are cleared (`clear lphoiur`), written (`write lphoiur`).

#### 3. Copy Associated Data from Other Tables

##### 3A. Copy Parties/Recipients

- Insert into LPPAST from XPPAST (WHERE by GUID and company) using embedded SQL.

##### 3B. Copy Packages ("kolli")

- Insert into LPKOST from XPKOST for the same GUID/company.

##### 3C. Copy Package Lines ("kollilinjer")

- Uses a cursor (`sok_l`) over XPKOST for the GUID/company, fetches package keys.
- For each package, inserts corresponding lines from XPKLST into LPKLST, transferring relevant values and adding fields such as status/user/timestamp.
- New lock code (`w_lock`) is also included from version 7.02.

##### 3D. Close Cursor

- Closes cursor to release resources so the cursor can be re-used with new values.

#### 4. Delete Source Integration Records

- Deletes XPPAST, XPKOST, and XPKLST records for this GUID/company, to avoid double-processing.

#### 5. Delete Main Integration Record

- Deletes the current `xphost` record (host integration record), completing the transfer.

---

### End-of-Program

- After end-of-file, program sets LR indicator (`*inlr = *on`) and returns (ends).

---

## Subroutines

### `hnt_nummer` (Get Message Number)

- Prepares fields, then calls program 'AS100R' to retrieve the next message number from a register, passing in/out parameters by reference.

---

## Revision History / Version Notes

- Version 7.01: Explicitly closes the SQL cursor after use so it can be reopened for new values.
- Version 7.02: Introduces line-level locking (`w_lock`, `phlock`, `polock`, `pllock`) in the various file inserts.

---

## Key Points for New Developers

- **Purpose:** Copies approved packing slip data from integration tables to local operational tables, assigns EDI message numbers, and cleans up source data.
- **Integration/Local Table Separation:** Clear distinction between XP* (integration/source) and LP* (local/target) files.
- **Batch Processing:** Processes all available records one at a time (`read`/`dow not %eof`).
- **Message Number Allocation:** Message numbers are assigned via an external program and passed between subroutines.
- **SQL Usage:** Embedded SQL for inserts and deletes, with cursors for complex joins/fetches.
- **Lock Handling:** Line-level lock codes are handled (from v7.02).
- **Clean-up:** Processed records are removed from source tables to prevent reprocessing.
- **Indicators and Data Area:** Uses RPG indicators and data area overlays for runtime context (user/company).

---

## Best Practices / Potential Areas to Modernize

- Refactor to RPG IV / Free-Format for readability and maintainability.
- Consider SQL-based set processing rather than RPG-native read/write for scalability.
- Review error handlingâ€”currently relies on SQLCOD, but lacks structured error management.
- Modularize code into procedures or service programs for testability.

---

**Summary**:  
This program is a typical RPG batch ETL job, transferring data from staging/integration tables to application tables, ensuring all necessary references (parties, packages, lines) are migrated, and then cleaning up the source. It uses a combination of native record operations, subroutines, and embedded SQL to accomplish this in a stepwise, reliable fashion.