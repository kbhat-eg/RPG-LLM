# RF020R: Maintenance of Note Sheets (Notatark)

## Overview

**Program:** RF020R  
**System:** ASOKON  
**Purpose:**  
This program manages "notatark" (note sheets), which are free-text notes associated with various financial master data (accounts, customers, suppliers, projects, etc.). The solution supports both note entry and maintenance, as well as the use of standard texts/templates that can be copied into note sheets.

The program is interactive, using subfiles for display and editing, and supports different grouping levels (account, customer, supplier, project, etc.). It handles both the maintenance of individual notes and the management of standard texts.

## Key Concepts and Business Logic

### 1. **Note Sheets and Standard Texts**
- **Note Sheets (Notatark):** Free-text notes attached to master data records.
- **Standard Texts:** Predefined templates or sample texts that can be inserted into note sheets.

### 2. **Grouping/Context**
- Notes can be linked to accounts, customers, suppliers, or projects. The grouping is determined by the context in which the program is called and user selection.
- The program distinguishes between account-level and transaction/post-level notes.

### 3. **Subfile Usage**
- The program uses a subfile (`b1sfl`) to display and edit multiple lines of notes.
- Several supporting variables (`srrn01`, `spge01`, `sfrn01`, etc.) manage subfile paging and state.

### 4. **User Interaction and Function Keys**
- The program defines a set of function keys (F3, F5, F9, F10, F12, etc.) for actions such as exit, refresh, copy standard text, switch between note/standard text modes, and cancel.
- Indicators (`*INKC`, `*INKE`, `*INKI`, `*INKJ`, `*INKL`, etc.) are mapped to these keys.

### 5. **Record Maintenance Logic**
- Supports insert, update, and delete of note lines.
- Handles renumbering of lines after insert or delete to maintain logical order (increments of 10).
- When inserting new lines, special logic ensures that the content is preserved and the subfile/disk file is updated accordingly.

### 6. **Standard Text Integration**
- Users can switch between editing a note sheet and standard texts.
- Standard texts can be copied into note sheets, either in full or filtered by grouping code.

### 7. **Business Rules**
- Notes can be locked for editing for certain customers (see "Sperr_Notat_Kunde" logic).
- The program enforces context-sensitive behavior (e.g., different behavior depending on whether the user is in standard text or note sheet mode).

### 8. **Audit/Tracking**
- The program records timestamps and user IDs for both creation and updates of note lines.

## File and Data Relationships

### Physical and Logical Files

- **aklaL2 / aklaL3 / aklalu:** Main note sheet data, at different grouping levels.
- **raa1l1:** Status records (company-level).
- **rhovl1:** General ledger (account master).
- **rkunlr:** Customer master.
- **rlevlr:** Supplier master.
- **rp1pl1:** Project master.

### Relationships

- The program chains into these files to retrieve descriptive information (names, numbers) to display alongside notes.
- The correct note file (aklaL2 or aklaL3) is selected based on context (account vs. post level).
- Standard texts are handled as special cases of note sheets, with separate keys.

### External Program

- **CO402R:** Called to determine whether notes for a customer should be locked for editing.

## Structure and Flow

### Initialization

- The program initializes state, loads the appropriate context (account, customer, supplier, etc.), and determines whether to use aklaL2 (account level) or aklaL3 (post level).
- Retrieves descriptive information for the context (name, account number, etc.).
- Checks if the note sheet should be locked for editing via CO402R.

### Main Loop

- Displays the main subfile screen, allowing the user to view and edit notes.
- Handles function key events for navigation, switching modes, inserting standard text, etc.
- After each user action, the subfile and underlying files are updated as needed.

### Subfile Handling

- Reads and writes subfile records for display and editing.
- Handles paging and state management for multi-page subfiles.

### Record Editing

- On edit, updates or deletes records in the disk file.
- If lines are inserted or deleted, triggers renumbering to maintain order.
- Ensures that changes in the subfile are reflected in the disk file.

### Standard Text Mode

- Users can switch to standard text maintenance mode.
- Standard texts can be edited or copied into note sheets.
- Switching modes preserves/restores the current context and state.

### Renumbering

- When lines are inserted or deleted, the program renumbers all lines to maintain increments of 10 (10, 20, 30, ...).
- This is necessary for maintaining order and for insert operations.

### Audit Fields

- On every update or insert, the program records the current date, time, and user in both "created" and "updated" fields.

### Special Customer Lock Logic

- The program calls CO402R to check if notes should be locked for a customer.
- If locked, the editing fields are protected.

## Design Patterns and Conventions

- **Indicator Usage:** The program uses a well-documented indicator convention for function keys, file status, and internal state.
- **Subfile Paging:** Implements paging logic for subfiles, with variables tracking current, first, last, and page size.
- **Separation of Concerns:** Business logic for different actions (insert, delete, copy, renumber, etc.) is organized into subroutines.
- **Context Preservation:** When switching between note and standard text modes, the program saves and restores context-specific variables.
- **Extensive Use of `like()` and `rename()`:** For consistent field definitions and file layouts across different files and levels.

## Module and API Interactions

- **CO402R (EXTPGM):**  
  Used to determine if notes on a customer should be locked for editing. This external program is called at initialization and its result controls whether editing is allowed.

- **Other Files:**  
  Various master files are used for lookups to display contextual information (account name, customer name, etc.) on the note sheet screen.

## Notable Non-Obvious Logic

- **Dynamic File Selection:**  
  The program dynamically selects between aklaL2 and aklaL3 based on the grouping level (account vs. post).
- **Renumbering Algorithm:**  
  Renumbering is triggered by changes in the subfile, and involves deleting all current records, then rewriting them with new line numbers.
- **Insert Logic:**  
  Insertion of new lines uses special codes in the first positions of the text field, which are recognized and handled to insert the correct number of blank lines.
- **Contextual Field Population:**  
  Depending on the grouping (account, customer, supplier, project), the display fields and lookup logic adapt to show the correct descriptive data.

## Extensibility and Maintenance

- **Versioned Enhancements:**  
  The code is annotated with version and ticket references (e.g., T5.20, T5.40, 6.10, 8.00), which indicate incremental improvements and bug fixes.
- **Business Rule Isolation:**  
  Key business rules (like customer note locking) are isolated and invoked via external programs, facilitating maintenance and changes.

## Key Variables and Their Roles

- **wppros, wpakti, wpkont, wpspes, wpavde, wptist:**  
  Hold current context keys for the note being edited.
- **b1text, b1sfl:**  
  The actual note text and subfile record.
- **f10std:**  
  Indicates whether the user is in standard text or note sheet mode.
- **wprenu:**  
  Indicates if renumbering is needed after changes.
- **slod01:**  
  Status flag for whether the subfile needs to be reloaded.
- **srrn01, sfrn01, ssrn01, spge01:**  
  Manage subfile paging and current record numbers.

## Summary Table: Function Key Mapping

| Function Key | Indicator | Action                         |
|--------------|-----------|--------------------------------|
| F3           | KC        | Exit                           |
| F5           | KE        | Refresh (Forny)                |
| F9           | KI        | Copy in standard text          |
| F10          | KJ        | Switch to standard text/notatark|
| F12          | KL        | Cancel                         |

## Summary Table: Files Accessed

| File      | Purpose                                  |
|-----------|------------------------------------------|
| aklaL2    | Note sheet, account/grouping level       |
| aklaL3    | Note sheet, post/transaction level       |
| aklalu    | Note sheet, update access                |
| raa1l1    | Status record, company-level             |
| rhovl1    | General ledger account master            |
| rkunlr    | Customer master                          |
| rlevlr    | Supplier master                          |
| rp1pl1    | Project master                           |

## Integration Points

- **CO402R**: Controls write access for customer notes.
- **Master Files**: Used for context display and validation.
- **Subfile (b1sfl)**: Main user interface for note editing.

## Special Considerations

- **Character Set:**  
  Some comments and field names use Norwegian characters (e.g., "notatark", "kunde", "leverand√∏r").
- **Extensive Use of Indicators:**  
  Understanding the indicator mapping is critical for following the flow of user interaction.
- **Audit Trail:**  
  All edits and inserts are timestamped and user-tracked.
- **Multi-level Notes:**  
  The program supports both account-level and transaction-level notes, with logic to select the correct file and keys.

---

**In summary:**  
RF020R is a robust, interactive note management program for financial master data. It supports dynamic context switching, standard text templates, multi-level grouping, full audit trail, and enforces business rules via external APIs. Understanding its subfile logic, key management, and mode switching is essential for effective maintenance and extension.