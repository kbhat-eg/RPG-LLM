# RPG Program for EDI Invoice Processing (LI703R)

This program is designed for batch processing of EDI (Electronic Data Interchange) messages of type "Invoice" on IBM i (AS/400). The RPG source demonstrates how to read, interpret, validate, and store structured EDI invoice data, mapping it to an internal database.

Below is a detailed explanation of the structure, main logic, and key features of the program. This guide is targeted at developers onboarding to maintain or extend this code.

---

## High-Level Structure

1. **File Declarations (`F-Specs`)**  
   The program uses several files (physical and logical), declared with `F`-specs. These include:
   - Input EDI file (`lwefpf`)
   - Order and invoice master/detail (e.g., `lohel1`, `lodtl1`)
   - Reference, lookup, and logging tables
   - Some files are renamed for record format clarity.

2. **Data Areas, Constants, and Working Variables (`D-Specs`)**
   - **LDA**: Fields from the user data area for company/user context.
   - **Key and Working Variables**: Per-file keys, fields for holding parsed EDI values, and work variables for EDI processing.
   - **Arrays**: Used, for example, to track linked line numbers.
   - **Data Structures**: For mapping EDI segments (ED01, ED02, etc.) and internal layouts for writing records.

3. **Indicator Usage**
   - Indicators (`LR`, `80-99`) are used for program control, file I/O, and flow.

4. **Main Loop**
   - Reads EDI file line-by-line. For each line, identifies the segment type (ED01, ED02, ...) via the first four characters and dispatches processing to a subroutine for that segment.
   - Handles cross-checks, writes composed records, and transitions between header, line, and total sections.

5. **Subroutines (Begsr/Endsr)**
   - Each EDI segment (ED01-ED27) has a processing routine, which parses data, manages state, and prepares internal data structures.
   - Additional subroutines: validation, cross-checks, writing output records, error handling, and utility routines for things like decimal normalization.

---

## Key Program Concepts

### EDI Segment Processing

- **Segment Dispatcher**: The main loop reads from the input EDI file, identifies the segment, and calls the corresponding subroutine.
- **Examples**:
  - `ED01`: Message header, initializes invoice header.
  - `ED05`: Party information (buyer, seller, etc.).
  - `ED13`: Invoice line, item identification.
  - `ED20`: Tax percentage.

- Within each subroutine:
  - Reads the EDI segment into a DS (data structure).
  - Transfers or translates data to the internal record structure.
  - Handles lookup, normalization, and validation.

### Order & Reference Validation

- **Order Matching**: The program cross-checks the invoice against the order master/detail to ensure item lines, quantities, pricing, etc., are valid.
- **Reference Resolution**: Uses keys and lookups to resolve references (e.g., NOBB number to internal item number).

### Decimal Handling

- EDI fields may have variable formatting for numeric/decimal fields.
- The `desm_sjk` subroutine normalizes, splits, and safely converts numeric strings (including minus sign, decimal point/comma) to numeric variables.

### Logging, Error Handling, and Status Codes

- Status and error codes are tracked per line and at the message level, and written to dedicated log files.
- Meaningful error messages are associated with status codes (e.g., "Feil i best.nr." = "Error in order number").

### Output Record Writing

- The program builds output records in internal DS and writes them to the output/processing file (`ledilu`), using the proper keys.

---

## Line Numbering and Sequencing

- The program maintains distinct sequencing for logical sections:
  - 10: Header info
  - 20: Party info
  - 30: References
  - 40: Transport info
  - 50: Invoice lines
  - 55: Order lines not matched in EDI
  - 60, 65: Additional fees/text
  - 90: Totals

These sequence numbers help differentiate between record types in output and control the order of processing.

---

## Highlights of Important Subroutines

### Main Loop

```rpg
read lwefpf                                 // Read an input EDI line
dow not %eof
   eval w_rect = %subst(faklin:1:4)         // Segment identifier (ED01, ...)
   select
      when w_rect = 'ED01'
         exsr ed01
      when w_rect = 'ED02'
         exsr ed02
      ...
   endsl
   read lwefpf
enddo
```

### ED01 (Header) Processing Example

```rpg
ed01 begsr
   if b_ftot = *on
      exsr skriv_tfakt                     // Write previous invoice total if needed
   endif
   exsr hent_mnum                          // Get next invoice/message number
   exsr null_hfakt                         // Clear header data structures
   exsr null_tfakt
   eval f_ed01 = faklin                    // Map EDI field to DS
   eval d_fh_dtyp = f_mkod01
   eval d_fh_fanr = f_fanr01
   eval d_fh_fako = f_mfun01
   ...
   eval b_fhod = *on                       // Header state on
   ...
endsr
```

### Decimal Normalization (`desm_sjk`)

This routine extracts and normalizes a value from a string (e.g., " 123,45" -> 123.45), handling:
- Trimming spaces/zeroes
- Removing non-numeric chars (except . and ,)
- Handling minus sign
- Splitting integer and fraction part

```rpg
desm_sjk begsr
   eval w_sign = %subst(w_stri:1:1)
   eval w_stri = %xlate('-':'0':w_stri)
   ... // Find decimal places, parse parts
   eval(h) w_resu = w_hltn  + w_dstn
   if w_sign = '-'
      eval w_resu = w_resu * -1
   endif
endsr
```

### Bestillingsnr/Beslin Lookups

Routines like `finn_besnr`, `finn_besnob`, and `sjekk_beslin` parse and resolve order numbers and line references from free-form EDI text or lookups via NOBB.

### Error Logging

If critical errors occur in validation (e.g., unmatched order line, invalid references), the program writes error records with context to a dedicated error log, and marks the EDI message/status accordingly.

---

## Extensions and Change History

The source uses extensive in-line documentation and versioning, e.g.:
- `6.20`, `6.22` denote features like improved handling of decimal fields, status code handling, or additional logging.
- In-line comments (often in Norwegian) document business logic changes.

---

## Summary Table of Main Data Structures

| Data Structure | Purpose                        | Example Fields         |
| -------------- | ----------------------------- | --------------------- |
| `f_edNN`       | EDI inbound segments           | f_idNN, f_xxxxNN      |
| `d_fakh1-6`    | Outbound invoice hode sections | d_fh_dtyp, d_fh_fanr  |
| `d_fakl`       | Outbound invoice line          | d_fl_llin, d_fl_vean  |
| `d_fakt`       | Outbound invoice total         | d_ft_ftot, ...        |

---

## Developer Tips and Onboarding Advice

- **Code is highly stateful**: Watch for indicator flags and variables managing section transitions.
- **References to EDI standards**: Familiarity with EDI standards (EDIFACT) can help understand segment meanings.
- **Validation is business-driven**: Many validation checks match very specific business rules (e.g., order/line matching).
- **Logging is integral**: Both for audit/compliance and for operational troubleshooting.

---

## Further Reading

- EDI/EDIFACT invoice segment documentation for field meanings (ED01 = header, ED13 = line, etc.).
- IBM RPG reference for legacy file and record handling.
- Internal system documentation for file layouts referenced (`lohel1`, `lodtl1`, etc.).

---

If you have specific questions about a subroutine or data mapping, please ask for a focused explanation on that area!