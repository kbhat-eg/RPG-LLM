```markdown
# Program LI740R Overview

This IBM ILE RPG program links sales orders ("bestillinger") with incoming EDI messages by matching totals within a small tolerance. It reads unprocessed EDI message lines, extracts the invoice or order confirmation totals, compares them to order totals, and updates the EDI message records when a match is found.

---

## 1. H-Specification

- `option(*nodebugio)`  
  Disables debug I/O to optimize performance.  
- `datedit(*dmy)`  
  Sets date format to day–month–year.

---

## 2. File Declarations (F-Specs)

| File   | Type | Disk? | Rename                         | Prefix  |
| ------ | ---- | ----- | ------------------------------ | ------- |
| `fledilr` | PFR  | Y     | `ledipfr` → `ledilrr`         | none    |
| `fledil1` | PF   | Y     | `ledipfr` → `ledil1r`         | xx:2    |
| `fledil3` | PF   | Y     | `ledipfr` → `ledil3r`         | none    |
| `flohelr` | PF   | Y     | `lohepfr` → `lohelrr`         | none    |

- **Purpose**  
  - **`ledilx`** files store EDI message lines.  
  - **`lohelr`** stores order headers.

---

## 3. Data Definitions (D-Specs)

1. **Local Data Area (LDA)**  
   - `l_user`: user ID  
   - `l_fnav`: function name

2. **Parameters**  
   - `p_inlr`: *ON when calling for cleanup  
   - `p_stat`: status flag  
   - `p_type`, `p_numm`, `p_suff`: incoming message type, number, suffix

3. **Data Structures**  
   - **Invoice Header** (`d_fakh1`)  
   - **Invoice Totals** (`d_fakt`)  
   - **Order Confirmation Header** (`d_obkh`)  
   - **Order Confirmation Totals** (`d_obks`)  
   - **Additional detail structures** for lines and charges  

4. **Working Variables**  
   - `w_etot`, `w_btot`: extracted EDI total / order total  
   - `w_diff`: absolute difference  
   - `x`: loop counter  

5. **Constants**  
   - `lo`, `up`: lower/upper-case alphabets  
   - `digit`, `null`: helper constants  

---

## 4. Initialization Subroutine (*INZSR)

- Sets up key lists (`klist`) for chained and sequential reads:
  - **`ledil1_key`**: for looking up totals.  
  - **`ledil3_key`** / **`ledil3_key2`**: to fetch candidate EDI message lines.  
  - **`ledilr_key`** / **`ledilr_key2`**: to update matching EDI lines.  
  - **`lohelr_key`** / **`lohelr_key2`**: to read orders.  
- Records current date/time into `w_date`, `w_time`, and extracts `w_year`.  
- Initializes `ledilr_type`, `ledil1_type`, `ledil3_type` from `p_type`.

---

## 5. Main Logic

1. **Early Exit**  
   If `p_inlr = *ON`, jump to cleanup.

2. **Fetch EDI Message Lines**  
   - Initialize key fields:
     ```
     ledil3_type = p_type
     ledil3_numm = p_numm
     ledil3_suff = 0
     ledil3_line = 0
     ledil3_mnum = 0
     ledil3_mlin = 0
     ```
   - `SETLL` / `READE` over `ledil3`.

3. **Filter Unprocessed Messages**  
   Criteria:
   - `%trim(likode) = *BLANKS` (no processing code yet)  
   - `limlin = 100001` (specific line type)

4. **Extract EDI Total (`w_etot`)**  
   - Chain to `ledil1` using:
     ```
     ledil1_mnum = limnum
     ledil1_mlin = 900001
     ```
   - If found:
     - If `p_type = 'FAKT'`: use `d_ft_teks` from `d_fakt`.  
     - Else (order conf.): use `d_os_ntot` or fallback to `d_os_suml` from `d_obks`.  
   - Else set `w_etot = 0`.

5. **Loop Through Orders (`lohelr`)**  
   - Key on `p_numm`, `suff = 0`; calculate:
     ```
     w_btot = lototi - lototr  // gross minus returns
     w_diff = abs(w_etot - w_btot)
     ```
   - If `w_diff < 10` (currency units), consider it a match:
     - Copy order number (`lonumm`) to `p_numm`, `losuff` to `p_suff`.  
     - `GOTO opd_edi` to perform update.

6. **Advance to Next EDI Message**  
   Loop `READE ledil3` until `%EOF`.

---

## 6. Subroutine: Update EDI Message (`opd_edi_sub`)

- Called when a match is found.
- Uses `SETLL` / `READE` over `ledilr` with:
  ```
  ledilr_mnum = limnum  // message number from ledil3
  ledilr_mlin = 0
  ```
- For each matching record, update:
  ```
  linumm = lonumm   // link order number
  lisuff = losuff   // link order suffix
  UPDATE ledilrr
  ```
- Ends when `%EOF`.

---

## 7. Cleanup and Exit

- Tag `avslutt`:  
  - If `p_inlr = *ON`, set RPG indicator `*INLR = *ON` to close files and end program.  
- `RETURN` from main procedure.

---

**Pedagogical Notes**

- Key-list definitions in *INZSR map file fields to working variables before any I/O.  
- `READE` reads all records matching the most recent key (useful for sequential processing).  
- An absolute difference tolerance (`< 10`) allows minor rounding variances between totals.  
- Goto/Tag and subroutine (`begsr`/`endsr`) reflect classic RPG control flow.
```