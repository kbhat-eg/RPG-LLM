# Overview

This RPG IV (ILE RPG) source code is for a program used to retrieve purchase prices on up to three units of measure for an item, given a company, item, supplier type, and date. It fetches these prices from various files (databases), considering things like price group, supplier priorities, campaigns/promotions, and valid dates. The code has evolved, with many documented changes (see the comments at the top).

## Main Purpose

- **Input:** Company, item, supplier type, price group, date, (optionally campaign, delivery type, warehouse).
- **Output:** For up to three purchase units:
  - Unit
  - Cost price and purchase price
  - Conversion factor (for units 2 and 3, vs. unit 1)

- If a purchase price couldn't be found, it defaults to the cost price.

---

# Key Components

## File Declarations

- The program works with several database files, e.g.:
  - `vvprl1` - Item price register
  - `vvenl4`, `vvenl2`, `vvenl4` - Item unit registers (by purchase/sales unit)
  - `vvarl1` - Item master
  - `vtill9` - Campaigns
  - `vveppf` - Item-unit-price group
- Files are usually renamed for local record formats.

---

## Parameter Declarations

- Input and output parameters for the entry point are declared as standalone fields (using the `like()` keyword to match their data types to those in the files).
- Parameters include:
  - Input: Company, item, price group, supplier type, date, campaign, delivery type, warehouse
  - Output: Three times: unit, cost price, purchase price, conversion factor

---

## Variables

- **`x`**: Counter for how many units found (max 3)
- **`b_pris`**: Flag indicating if a price has been found
- **`w_*`**: Working variables (e.g., for company, date, warehouse)
- **`p_*`**: Parameters (input/output)
- **SQL status vars**: Used for SQL operations

---

## Initialization (`*inzsr` Subroutine)

- Maps input parameters to local variables.
- Initializes output parameters to blanks/zeroes.
- Gets system date if input date is blank.
- Calls external program `CO402R` to determine if packaging class is required.

---

# Main Logic Flow

### 1. Preprocessing

1. **Check if the supplier is internal or from a specific system (RDS):**
   - Uses SQL to look up supplier information, flags if it is a distribution supplier.

2. **Get warehouse code (`w_lage`)**:
   - Uses either supplied value or default from parameter.

3. **Find preferred supplier for the item/warehouse**:
   - Calls external program `VL721R` to retrieve this information.

4. **Get item info from item master** (if needed).

---

### 2. Fetching Prices for Item Units

- The logic attempts several strategies in order:

#### a. Preferred Approach
   - Try to fetch price info for the purchase unit using the supplier for the warehouse, prioritized supplier, then main supplier, via subroutine `sjekk_vvep`.
   - If found, process up to three units, mapping:
     - Unit
     - Cost price
     - Purchase price
     - Conversion factor

#### b. Fallbacks
   - If nothing found for purchase units, look up prices using sales units.

#### c. Defaults
   - If purchase price is not found (is zero), set it equal to the cost price.

#### d. Conversion Factors
   - For units 2 and 3, set conversion factors as ratios vs. unit 1.

---

### 3. Subroutine: `hent_pris` (Fetch Price Information)

This is a key subroutine that attempts to extract pricing data, with several fallback strategies:

- If there is an active campaign (`p_kamp`), check for campaign prices (including price group blank fallback).
- If no campaign, check for valid campaign by date (including price group blank fallback).
- If not found in campaigns, lookup standard price register using supplier type and price group, with fallbacks (delivery type = 0, price group blank).
- Updates output parameter fields for each found unit (up to three).

---

### 4. Subroutine: `sjekk_vvep` (Check Item-Unit-Price Group)

- Uses embedded SQL to fetch orderable units from the item-unit-price group file, joined to the item-unit file.
- For each unit:
  - If packaging class is required, skip if missing.
  - Tries to get price info using prioritized order of suppliers.
  - Continues until three units found or end of dataset.
- Uses a SQL cursor for flexible fetching.

---

### 5. Key Lists

- Key lists (`klist`) are used to build composite keys for file access:
  - For `vvprl1` (item price register)
  - For `vtill9` (campaigns)
  - For `vvenl4` and `vvenl2` (item unit registers)
  - Others as needed.

---

# Error Handling and Fallbacks

- Various checks (using flags, SQL status, etc.) to attempt alternative lookups if data is missing.
- The code contains multiple fallback paths, e.g.:
  - If no data in campaigns, check standard price register.
  - If no matching price group, use blank.
  - If supplier type not found, try with zero (generic).
  - If purchase price is missing, use cost price.

---

# Comments and Versioning

- The code is heavily commented in Norwegian, with a detailed change log at the top.
- Comments describe each step and outline the business reasoning (e.g., use prioritized supplier, fallback logic, etc.).

---

# Typical Use Case (Summary)

Given the inputs (company, item, warehouse, etc.), the program outputs price and conversion information for up to three purchase units (if available), using a prioritized and fallback logic based on supplier, price group, campaigns, and validity dates.

- **Business logic is prioritized:**
  - Start with the most specific and relevant data (given supplier, price group, campaigns).
  - If not found, increase generality (generic supplier, blank price group, standard prices).

---

# Subroutines and External Calls

- Uses embedded SQL for flexible queries and cursor-based processing.
- Calls to external programs (e.g., `VL721R`, `CO402R`) for supplier or business-specific info.

---

# Onboarding Tips

- **File Structure:** Familiarize yourself with the database files used (item, item-unit, price register, campaigns), and their keys.
- **Parameter Passing:** The program is designed for called/batch use, with input/output parameters for easy integration.
- **Fallback Logic:** Be aware of the multi-level lookup logic and why it exists (to find the best possible price match).
- **External Integrations:** Understand what the external programs do, especially if business rules change.
- **Testing:** To verify or troubleshoot, try input scenarios where each fallback path is used.

---

# Conclusion

This program forms a sophisticated price lookup for up to three units of measure per item, considering a broad set of business rules regarding suppliers, price groups, campaigns, and more. It implements robust fallback logic to maximize successful price retrieval. The code is modular, with well-defined subroutines and external calls, and is carefully maintained with clear version history.