# RPG Program `RA601R` - Explanation

## **Overview**

This program prints ("utskrift av") various code registries ("koderegister") used in a company's financial/accounting system. It generates reports on master data such as status codes, voucher codes, payment methods, VAT codes, account groupings, departments, etc. The user can select which registers to print. 

**Main Features:**
- Modular structure: Each code register type is printed by a named subroutine (`KODxx`).
- Reads various code master files for the company (`firma`) in question.
- Highly table-driven: The order and content of the report is based on user choices supplied in the `IX` array.
- Many standard IBM i RPG idioms: indicators, data areas, subfile read loops, print file handling.

---

## **Header & Metadata**

```rpgle
h option(*nodebugio) datedit(*dmy)
```
- `*NODEBUGIO`: Compile with no debug info for I/O operations (more efficient).
- `*DMY`: Default date format is day/month/year.

The comments describe:
- System, program name, and main function.
- Change log / version history (in Norwegian).
- Indicator usage (IBM i RPG indicators for function keys, errors, etc.).

---

## **File Declarations**

Each line declares a file used in the program. Example:

```rpgle
fafirl1    if   e           k disk
fraa1l1    if   e           k disk    rename(raa1pfr:raa1l1r)
...
fra601p    o    e             printer oflind(*in30)
```

- `fafirl1` ... `fraa6l1` etc.: Input files for each registry (e.g., status codes, voucher codes, etc.).
- `rename(...)`: Renames the record format (for programs with many similar files).
- `fra601p`: Output printer file, triggers page break on indicator `*IN30`.

---

## **Data Definitions**

### **Array Data**
```rpgle
d txt             s             30    dim(29) ctdata perrcd(1)
d kto             s             30    dim(29) ctdata perrcd(1)
```
- `txt`: Array of 29 descriptions, initialized via compile time data (`ctdata`).
- `kto`: Similar array for account descriptions.

### **Program Variables**
- Many variables correspond to fields in the code files (e.g., `w_firm`, `w_akod`).
- Variables like `ktxt`, `sider`, and work fields for passing parameters to called programs/subroutines.
- Examples:
    - `w_firm`: contains the selected company number.
    - `sider`: page counter.
    - `p_text`: text field for account descriptions.

---

## **Main Processing Logic**

The main calculation routine is a checklist and dispatcher — for each code register, it checks if the corresponding entry in the `IX` array is `'1'` (i.e., selected for printing), then calls the named subroutine.

Example:
```rpgle
c     if        ix(1) = '1'
c               exsr      kod00
c     endif
```
...repeated for each register code (up to `exsr kod28`).

---

## **Subroutines (`kodxx`)**

The core of the program logic. Each code register type has a subroutine — e.g., `KOD01` for voucher codes, `KOD02` for payment methods, etc.

**Subroutine Structure (Generalized):**
1. Initialize work variables (key fields, temporary fields, etc.).
2. Set file position with `SETLL` or `CHAIN` based on the current company (and other keys).
3. Output header line(s) via `write head1` and a section heading (`lXXh`).
4. Loop: read all relevant records for the company and write a print line for each (`lXX`).
5. Handle page breaks if indicator `*IN30` is on.
6. Some routines call out to other programs (e.g., for account description lookup).

### **Example Snippet (`kod01`) - Voucher Codes**

```rpgle
c     kod01         begsr
c                   eval      w_akod = *zeros
c     key01         setll     ra01l1
c                   move      txt(2)        ktxt
c                   eval      sider = sider + 1
c                   write     head1
c                   write     l01h
c     les01         tag
c                   read      ra01l1r                                10
c                   if        *in10 = *on
c                   goto      end01
c                   endif
c                   if        raafir > w_firm
c                   goto      end01
c                   endif
c   30              do
c                   eval      sider = sider + 1
c                   write     head1
c                   write     l01h
c                   eval      *in30 = *off
c                   enddo
c                   write     l01
c                   goto      les01
c     end01         endsr
```
- Begins by initializing the key field and positioning the file.
- Writes heading.
- Loops through all records, writing details, and breaks on page/full report.

### **Special Logic Examples**
- Filtering out logically deleted or blocked records (e.g. for department or cost center, checking for a 'blocked' flag).
- Enriching output by calling other programs (e.g., to resolve account names via `CALL 'RS740R'`).

---

## **Indicator Handling**

- RPG indicators (`*INxx`) are used for error and control flow:
    - `*IN30`: Page overflow, triggers new page.
    - `*IN10`, `*IN61`, etc.: End of file or record not found.

---

## **Initialization Subroutine**

```rpgle
c     *inzsr        begsr
 ...
c                   move      l_firm        w_firm
...
c                   endsr
```
- Reads initial data such as the selected company, and builds up key lists for indexed access to all data files.

---

## **Compile-Time Data**
At the end, the `**` delimited blocks provide compile-time initialization for the arrays (e.g., registry section titles and account types).

---

## **How To Extend or Modify**

- To add a new code register: 
    - Add new print subroutine (`kodNN`).
    - Add file declaration and variables.
    - Add to selection and dispatcher (`IX(N)`).
    - Add to compile time data as needed.

- To change which registers are printed by default, adjust the initialization of the `IX` array.

---

## **Summary Table**

| Subroutine | Registry Printed      | File(s) Used   | Array (`IX`) Index |
|------------|----------------------|--------------- |-------------------|
| `KOD00`    | Status codes         | raa1l1, ...    | 1                 |
| `KOD01`    | Voucher codes        | ra01l1         | 2                 |
| `KOD02`    | Payment methods      | ra02l1         | 3                 |
| ...        | ...                  | ...            | ...               |
| `KOD28`    | Cost bearer          | ra28l1         | 29                |

---

## **Key Notes for Onboarding**

- **Language:** Variable/field names and comments are largely in Norwegian.
- **Program Flow:** Follows classic RPG cycle with a dispatcher loop calling subroutines.
- **Customization:** The program is easily extensible by following the strong pattern established.
- **File Structure:** Each subroutine expects its file(s) in a consistent format per company.
- **Indicator Mastery:** Understanding legacy RPG indicators is crucial for correct maintenance.

---

## **References**

- IBM RPG/400 Reference: [IBM Documentation](https://www.ibm.com/docs/en/i/7.4?topic=rpg-rpg400-reference)
- IBM i Print File Programming: [IBM Print Files](https://www.ibm.com/docs/en/i/7.3?topic=applications-print-files)
- Norwegian accounting/ERP terminology for understanding field names and register types.

---

**In summary:**  
This RPG program is a highly modular report generator for financial/accounting code registers, designed for an IBM i (AS/400) environment. Its structure and array-driven logic make it relatively easy to extend and maintain, provided the developer is comfortable with classic ILE RPG patterns and Norwegian financial terminology.