```markdown
# IBM ILE RPG Program EK760R - Bonus Calculation for Customer and Item

This document explains the ILE RPG program `EK760R`. The program is designed to calculate customer bonuses for specific items, based on various customer, item, and agreement conditions.

---

## 1. **Program Overview**

- **Purpose**: Calculate the bonus for a customer (`kunde bonus`) for a given item, considering multiple potential agreements and hierarchies.
- **Typical Use Case**: Sales orders or similar transactions where customer-specific bonus calculations are needed.

---

## 2. **File and Data Definitions**

### **Database Files (DISK Files)**
- `ekboi1`, `ekboid`: Main files for bonus agreements.
- `ekbei2`: Element file for line-level bonus information.
- `vvarl1`, `vvasl1`, `jvarl1`: Item master files (active, deleted, special types).

Files are renamed for internal use (e.g., `rename(ekbost:ekboi1r)`), which is standard practice in RPG to differentiate record formats.

### **Parameters**
Parameters passed to the program (typically via *ENTRY or an external call):
- `p_firm`: Firm/Company number.
- `p_bkun`: Bonus customer number.
- `p_kund`: Customer number.
- `p_kpro`: Customer project number.
- `p_rkat`: Discount/bonus category.
- `p_dato`: Date for bonus calculation.
- `p_vare`: Item number.
- `p_enhe`, `p_lety`, `p_ldor`: Unit, delivery type, and supplier.
- `p_sapr`: Invoice amount (basis for bonus calculation).
- `p_bobe`: Output parameter for calculated bonus.

### **Main Working Variables and Arrays**
- Arrays (e.g., `a_boty(99)`): Used to track bonus types already processed, avoiding duplicates.
- Numerous working variables for keys and calculation logic, all named to correspond to file fields (e.g., `ekboi1_bkun`).

---

## 3. **Main Logic Flow**

### **3.1 Initialization and Parameter Validation**
- The program initializes the output bonus (`p_bobe = 0`).
- If insufficient input is provided (e.g., missing customer/item or amount), the program ends early (`goto avslutt`).

### **3.2 Retrieve and Validate Item Details**
- Tries to find the item in different item master files. If not found, it exits.
- Checks if the item is marked as ineligible for bonus calculation (`vvkbon = 1`), and exits if so.

### **3.3 Select Customer**
- Determines the effective customer to process: either explicit (`p_kund`) or falls back to bonus customer (`p_bkun`).

### **3.4 Determine Calculation Date**
- Uses the passed date (`p_dato`) if given; otherwise uses current system date.

### **3.5 Find and Apply Bonus Agreements**
- The program first looks for agreements at the bonus customer level.
- Then loops through all customers from the `ekboid` view for any matching agreements.
- For every agreement found, invokes the `kalk_bonus` subroutine.

---

## 4. **Subroutines**

### **4.1 `kalk_bonus` (Bonus Calculation)**
- Handles the actual bonus calculation for the item and customer context.
- Loops over possible levels/types of agreements (hierarchies and combinations) according to a complex, documented hierarchy list.
- For each agreement level:
  - Constructs the search key.
  - Reads the agreement records.
  - If a valid agreement is found for the period (date matching), and not already processed (bonus type is not in the array), marks it as found (`b_bonu = *on`), updates arrays, and processes the bonus calculation.
- For every eligible agreement found, the bonus is calculated as:
  ```
  p_bobe = p_bobe + (p_sapr * ekebpr / 100)
  ```
  Where `ekebpr` is the bonus percentage.

- The hierarchical search is very thorough, covering:
  - Customer + project + item + unit + delivery type, etc.
  - Customer + module + unit, etc.
  - Discount/bonus category + item, etc.
  - General/unspecified agreements.

#### **Bonus Agreement Hierarchy Table**
- The most prominent part of this subroutine is the detailed table of 160(!) different search patterns, reflecting combinations of customer/project/category/item/group/mod/supplier/unit/delivery type.
- The program follows this sequence to find the best/most specific match.

### **4.2 `bonusnivå` (Bonus Level Finder)**
- For each combination, check if effective dates for the agreement match the calculation date.
- Uses arrays and lookup to prevent duplicate processing of the same bonus type.
- As soon as a matching bonus is found, it exits (priority to the most specific match).

---

## 5. **Key Construction Logic**

- RPG KLISTs (`ekboi1_key`, etc.) are used to define the multi-field keys for database access.
  - The keys reflect the hierarchy of bonus agreements.
- Key values are dynamically set according to the desired bonus level being checked.

---

## 6. **Entry and Initialization (`*inzsr`)**

- Initializes working variables and sets up parameters from the external call.
- Sets the firm/company field according to the input.

---

## 7. **Typical Flow Example**

1. **Call to program with parameters:** firm, customer, item, invoice amount, etc.
2. **Validation:** Are all required inputs present?
3. **Item found in master file?**
4. **Check item not marked as ineligible.**
5. **Decide which customer to use.**
6. **Find bonus agreement(s) in order of specificity, from most specific to most general, using the detailed hierarchy.**
7. **For each agreement found:**
   - **Check the date validity.**
   - **Check no prior bonus of same type has been applied.**
   - **Calculate and add the bonus to output.**
8. **Return the accumulated bonus.**

---

## 8. **Notable Implementation Details**

- **Hierarchy and Specificity:** The program's power lies in its exhaustive search for the "most specific" agreement first, falling back to more general agreements if nothing is found.
- **Date Range Handling:** Each agreement is validated against the transaction date to ensure it is active.
- **Avoid Double Bonus:** An array tracks which bonus types have already been processed.
- **Parameterization:** All key data is parameterized, making the program very flexible for many scenarios.
- **Old-style RPG:** This code is in traditional (fixed-format) RPG IV, which is verbose but robust.

---

## 9. **Onboarding Tips for Developers**

- **Start with Parameter Structure:** Understand what each parameter means; they directly drive calculations.
- **Follow the Flow:** The main program logic is sequential, with key processing in the `kalk_bonus` and `bonusniveau` subroutines.
- **Hierarchies Matter:** The core feature is the hierarchy of agreement lookups—study how key fields are set in each loop.
- **Test with Data:** Have test records at different hierarchy levels to observe which bonus is picked.
- **Refactoring:** Because of the repetitive patterns (especially in looped database reads), there is good potential for modularization or using free-format RPG for clarity.

---

## 10. **Summary**

This program is a robust, highly specific solution for calculating item/customer bonuses in a complex pricing/discounting environment. Its core strength is the comprehensive agreement hierarchy and careful management of which agreements apply, and when.

If you need to extend or debug, focus on how the hierarchy is traversed, and ensure that the right bonus level is being selected for each scenario.
```