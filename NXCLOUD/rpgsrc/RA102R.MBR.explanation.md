# Explanation of RA102R RPG Program

This RPG (Report Program Generator) program, named **RA102R**, is used for maintaining payment types ("Betalingsmåter, vedlikehold") in an IBM i (AS/400) environment. The code uses both classic (fixed-format) and newer free-format RPG IV syntax, and features subfiles for display and maintenance, access control, and interaction with several physical and logical files.

Below is a breakdown of the major components and flow of the program.

---

## 1. **Header and Environment Settings**

```rpg
h option(*nodebugio) datedit(*dmy)
```
- `*nodebugio`: Disables certain debugging features for I/O operations.
- `datedit(*dmy)`: Sets the date format to Day/Month/Year.

---

## 2. **File Declarations**

```rpg
fra02l1    if   e           k disk    rename(ra02pfr:ra02l1r)
fra02l2    if   e           k disk    rename(ra02pfr:ra02l2r)
fra02lr    if   e           k disk    rename(ra02pfr:ra02lrr)
fra02lu    uf a e           k disk    rename(ra02pfr:ra02lur)

fra102d    cf   e             workstn sfile(b1sfl:w_srrn)
```

- **fra02l1, fra02l2, fra02lr, fra02lu**: Logical and update views of the core database file `ra02pfr` with various logical files for different access paths (by code, by description, for lookup, update, etc.).
- **fra102d**: Workstation display file handling the subfile `b1sfl` with relative record number `w_srrn`.

---

## 3. **Local Data Area and Work Variables**

Local data area fields (LDA) are used to carry session-related info like user, company, etc.

```rpg
d                uds
d l_user                911    920
d l_firm                944    946  0
...
d w_stel          s              4  0   // Subfile counter
d w_spge          s              4  0   // Page size
d w_srrn          s              4  0   // Relative subfile record number
...
```
Variables are extensively commented to describe their purposes, especially regarding subfile management (pagination, cursor, active row/column, etc.).

---

## 4. **Constants and Access Control**

```rpg
d c_sfil          s              2  0 inz(14) // Subfile page size
d u_s701          s              1    inz(*off) // Access control flag
```
Access control is periodically checked using programs `CO402R` and `AD005R`.

---

## 5. **Prototype for External Access Control Program**

```rpg
DCL-PR CO402R EXTPGM('CO402R');
  p_filgrp            char(3)     const;
  p_firm              packed(3:0) const;
  p_lager             packed(2:0) const;
  p_nokkel            char(50)    const;
  p_verdi1            char(1);
  p_verdi2            char(2048);
END-PR;
```
This prototype enables calling the external program `CO402R` to check user permissions.

---

## 6. **Indicator Usage Convention**

The program adopts a strict indicator (flag) scheme for controlling program flow, display attributes, and error signaling. For instance:
- `*in10` Rollup (Page down),
- `*in11` Rolldown (Page up),
- `*in12`/`*in13` Subfile display controls,
- `*in30` Protect fields,
- `*in31-*in79` Error/warning indicators, etc.

---

## 7. **Program Main Processing Loop**

The C spec flow revolves around a main display loop handling subfile display (`b2ctl`, `b2cmd`), user actions, and function key handling. The logic is:

1. **Display Subfile Control Screen (`b2ctl`), or Command Screen (`b2cmd`).**
2. **Access Control for Function Keys and Options:**  
   Function key access is checked with external program `AD005R` if access control is enabled (`u_s701`).
3. **Function Key Handling:**  
   - F3/F12 (`*inkc`, `*inkl`) — Exit program,
   - F5 (`*inke`) — Refresh/renew,
   - F6 (`*inkf`) — Add new row,
   - Page Up/Down (`*in10`, `*in11`) — Subfile paging,
   - Home (`*in21`), etc.
4. **Positioning:**  
   If user provides search criteria (by code or description), the program positions the file cursor accordingly and reloads the subfile.
5. **Subfile Handling:**  
   Reads all active subfile records and allows the user to select actions (change, copy, delete, show).

---

## 8. **Subroutines:**

### a. **forny** — Refresh Subfile
Refreshes subfile data after changes.

### b. **posisjoner** — Position in Subfile
Handles searching by either code or description and repositions accordingly.

### c. **subfile** — Process Subfile Rows
Handles option selection for each row (change, copy, delete, display), also integrates option-level access control.

### d. **xc1bld** — Process "Add New Row" Screen (C1BLD)
Handles the dialog for adding a new payment type, including checks for duplicates.

### e. **xc1msg** — Display Message When Row Exists
Shows a message if a user tries to add a new code that already exists.

### f. **xc2bld** — Process "Update/View Row" Screen (C2BLD)
Handles the display and updating of details for a payment type.

### g. **xd1win** — Process "Delete Row" Window (D1WIN)
Handles deletion, with confirmation.

### h. **xk1win** — Process "Copy Row" Window (K1WIN)
Handles duplication of a payment type record.

### i. **clr_subfile** — Clear Subfile
Blank out (clear) the subfile and associated counters/flags.

### j. **crt_subfile** — Create (Fill) Subfile
Populate subfile with payment records from the database according to current filter and position, handling paging.

### k. **bck_subfile** — Page Backward in Subfile
Handles scrolling backwards through the paged subfile display.

### l. **dsp_subfile** — Show Subfile
Handles actual display of the subfile.

### m. ***inzsr** — Initialization
On program start:
- Sets up file keys for different positioning access.
- Checks access control (calls `CO402R` and `AD005R`).
- Initializes subfile for first display.

---

## 9. **Access Control**

Access control is a major feature:
- On initialization, and for function keys/options, access is verified using programs `CO402R` and `AD005R`.
- If a user is "Sperret" (locked out), they're denied access to options or the whole program.

---

## 10. **Subfile Usage**

- Subfiles (`B1SFL`, `B2CTL`, etc.) are used for efficient display and maintenance of lists on green-screen interfaces.
- Paging, adding, updating, copying and deleting are all managed directly via subfiles.
- The subfile is maintained via `w_srrn` (relative record number), and all subfile-related variables are clearly explained in the comments.

---

## 11. **Flow Summary**

1. Initialize, check user access.
2. Display main subfile list.
3. User acts (add, change, copy, delete, show, page, position).
4. Program branches as needed (show add/update/copy/delete windows, perform action).
5. After action, subfile refreshed.
6. User can exit at any time via function keys.

---

## 12. **Noteworthy Details**

- **Modular**: Most actions are handled in their own subroutines, making the logic readable and maintainable.
- **Error Handling**: Via indicators (set *in31, *in32, etc.).
- **Comments**: The program is well-annotated, especially for fields and subfile management.
- **Norwegian Language**: Several comments and field names are in Norwegian; e.g., "Betalingsmåter" = Payment Methods.

---

## 13. **Modernization**

Note that while much of the code is classic fixed-format RPG, some modern free-form RPG (`dcl-s`, free-form `if`, etc.) is also present, especially for newer features (such as access control in version 7.01).

---

## 14. **Key Takeaways for New Developers**

- **Understand the Subfile Model**: Most user interaction is via subfiles.
- **Familiarize with Indicators**: They control program behavior and interface logic.
- **External Programs Are Key**: For security/access control.
- **Modularization**: Most business logic is in subroutines.
- **Error/Validation Logic**: Is handled early (before updates/writes).
- **Access Control**: Is checked at the start, and before executing sensitive actions.

---

## 15. **References**

- **DDS**: Display and file definitions are key to understanding the UI and file layouts.
- **External Programs**:
  - `CO402R`: For checking if access control applies to this program.
  - `AD005R`: For verifying access per user/routine/option.

---

**In summary**, this is a well-structured, production-grade RPG program for maintaining payment methods, with strong support for user access control, subfile-driven UI, and modular business logic. It is a good model for classic IBM i green-screen applications.