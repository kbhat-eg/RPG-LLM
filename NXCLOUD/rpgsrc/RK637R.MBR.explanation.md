# RPG Program Explanation: RK637R - Print Customer Information

This RPG program is intended to read customer information from the database, fetch related descriptive texts (like categories and terms), optionally fetch company information, and then print a formatted customer report. The code makes use of subroutines and data structures for modularity and maintainability.

---

## 1. **File Declarations**

```rpg
frkunl1    if   e           k disk    rename(rkunpfr:rkunl1r)
faforl1    if   e           k disk    rename(aforpfr:aforl1r)
frk637p    o    e             printer oflind(*in30)
```

- **frkunl1**: Input file for customer master data (`rkunpfr`), renamed to `rkunl1r` in program.
- **faforl1**: Input file for routine/form register (`aforpfr`), renamed to `aforl1r`.
- **frk637p**: Output file; printer file for the report; signals overflow with indicator `*in30`.

---

## 2. **Data Structure and Variables**

Temporary variables hold and structure customer, company, and report data.

```rpg
d w_firm          s                   like(rkfirm)
d w_prfi          s              1  0
...
d w_fbgi          s             13
```

- **w_firm, w_prfi, ...**: Working fields for company and customer information.
- **p_kund, p_valg**: Program parameters (customer number and selection value).
- **rkunl1_kund, aforl1_ruti**: Work variables for keys in file operations.
- **UDS block (user data space)**: Used for storing various "local" info from input parameters or environment.

---

## 3. **Main Logic**

### a. **Read Customer**

```rpg
c                   eval      rkunl1_kund = p_kund
c     rkunl1_key    chain     rkunl1                             61
```
- Retrieve customer record using the passed-in customer number parameter (`p_kund`).

### b. **Fetch Descriptive Texts**

```rpg
c                   exsr      hent
```
- Calls the `hent` subroutine to look up and fill out descriptive fields about the customer.

### c. **Print Fixed Data & Customer Information**

```rpg
c                   eval      a1valg = p_valg
c                   write     head
c                   write     linje
```
- Sets up the report line with selection value, writes the header (`head`), then the customer information line (`linje`).

### d. **End Program**

```rpg
c     slutt         tag
c                   eval      *inlr = *on
```
- Sets last record indicator `*INLR`, marking the program for cleanup/exit.

---

## 4. **Subroutines**

### a. **hent - Fetch Descriptions**

```rpg
c     hent          begsr
     ...
c                   endsr
```

- **Customer Category**: Calls program `RS711R` with the customer's category code, to receive category text.
- **Payment Terms**: Calls `RS703R` using the payment terms code to fetch the terms text.
- **Postal Place**: Calls `RS730R` with the postal number to get the city/place name.
- **Credit Limit Calculation**: Multiplies the stored credit limit by 1,000 (possibly for currency formatting).

**Purpose**: Populates description fields for later printout.

### b. **Initialization Subroutine**

```rpg
c     *inzsr        begsr
     ...
c                   endsr
```

- Sets up input parameters.
- Builds file access keys.
- Fetches entries from the routine register (`aforl1`), determines whether to fetch company info.
- If requested, calls another program (`R�707R`) to fetch company information and populates report variables.
- Clears or sets company info based on routine register flags.

---

## 5. **External Calls**

- `RS711R`, `RS703R`, `RS730R`: Retrieve description texts for category, payment terms, and postal place.
- `R�707R`: Retrieves company information if indicated by parameters/settings.

---

## 6. **General Flow**

1. **Initialization**:
    - Parameters set up, file keys prepared, company info fetched if needed.

2. **Main Logic**:
    - Customer record is read.
    - Related texts for category, payment, and city are fetched via subroutine.
    - Header and customer info lines are written to the print file.

3. **Program Ends**:
    - Resources are cleaned up, program ends properly.

---

## 7. **Special Notes**

- The code uses structured programming via subroutines.
- Heavy use of external program calls for text and info retrieval.
- Variables and field names are mostly Norwegian—e.g., `kunde` = customer, `betingelse` = condition, `firma` = company.
- **No error handling** for missing records, other than checking routine register lookup (`%found`).
- Date formatting is set to DMY: `h datedit(*dmy)`.

---

## 8. **Summary Table of Key Variables**

| Variable     | Description                                |
|--------------|--------------------------------------------|
| p_kund       | Input: Customer number                     |
| p_valg       | Input: Selection value                     |
| w_firm       | Working: Company number                    |
| w_prfi       | Working: Company info flag                 |
| w_fnav       | Working: Company name                      |
| w_ckod       | Working: Payment terms code                |
| w_ctxt       | Working: Payment terms text                |
| w_kkod       | Working: Customer category code            |
| w_ktxt       | Working: Customer category text            |
| w_ponr       | Working: Postal number                     |
| w_sted       | Working: Postal place name                 |
| a1fnav, ...  | Output: Fields for report lines            |

---

## 9. **Typical Use Case**

- This program would be called from a higher-level process, passing a customer number and some selection flag.
- It would print a formatted report of that customer’s details, resolving codes to text via external calls, and including company info as required.

---

### **Onboarding Takeaway**

- **Read**: Customer record from file.
- **Enrich**: Use subroutines/calls to augment with descriptive info.
- **Print**: Output a formatted report.
- **Modular**: Uses subroutines and external programs for key logic.
- **Adaptable**: Company info inclusion is controlled by parameters in the routine register.

This code is a good example of classic ILE RPG design for reporting and information retrieval on IBM i systems, utilizing modular code, external calls, and file I/O.