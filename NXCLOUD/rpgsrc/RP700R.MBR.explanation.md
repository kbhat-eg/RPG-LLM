# IBM ILE RPG Program Explanation

This RPG program is a legacy ILE RPG (mainly RPG III/400 style with some RPG IV features) routine designed to **parse, validate, and process project-related records** from an input file/stream. The program supports data for Projects, Sub-Projects, and Activities, and validates various fields before writing output and logging errors for each record.

Below is a **structured explanation** of the source:

---

## 1. **File Declarations**
```rpg
fxl_prosj  up   f  512        disk
frpxllu    uf a e           k disk    rename(rpxlpfr:rpxllur)
frp1pl1    if   e           k disk    rename(rp1ppfr:rp1pl1r)
frp2ul1    if   e           k disk    rename(rp2upfr:rp2ul1r)
frp3al1    if   e           k disk    rename(rp3apfr:rp3al1r)
frkunl1    if   e           k disk    rename(rkunpfr:rkunl1r)
filonl1    if   e           k disk    rename(ilonpfr:ilonl1r)
fra07l1    if   e           k disk    rename(ra07pfr:ra07l1r)
fra09l1    if   e           k disk    rename(ra09pfr:ra09l1r)
```
- **Input File (`xl_prosj`)**: 512-byte records, likely delimited or fixed width, containing project data to be uploaded/validated.
- **Output/Lookup Files**: Several logical/physical files for projects, subprojects, lookups, etc., with record format renaming for code clarity.

---

## 2. **Data Area Structure & Constants**
```rpg
d                uds
d l_user                911    920
d l_filg                931    933
d l_firm                944    946  0
d l_fnav                951    980

d Lo              c                   'abcdefghijklmnopqrstuvwxyz...'
d Up              c                   'ABCDEFGHIJKLMNOPQRSTUVWXYZ...'
```
- **UDS**: Declares fields from the program's user data space (LDA), used for user, company, or session information.
- **Case Constants**: Lowercase and uppercase alphabet strings, probably for conversion or comparison logic.

---

## 3. **Field Variable Declarations**
- **Key Variables**: Used for building keys for file lookups (CHAIN operations).
- **Field Variables**: Working storage for each possible field in the input record, for project, subproject, and activity (almost always `CHAR` of varying length).
- **Error Tracking**: `w_feil` stores error codes concatenated as the program validates fields.

---

## 4. **Input Record Format**
```rpg
IXL_Prosj  ns  01
I                                  1  512  prosj
```
- Declares the **input buffer** `prosj` and its fixed record size (512 char).

---

## 5. **Main Processing Logic** (Starts after input read)

### a. **Skipping Blank/Header Lines**
```rpg
if %subst(prosj:1:5) = ';;;;;' or
   %subst(prosj:1:8) = 'PROSJEKT' or
   %subst(prosj:1:8) = 'Prosjekt'
   goto end
endif
```
- Skips empty lines, or lines that look like headers (by inspecting the start of the record for certain patterns).

---

### b. **Whitespace and Delimiter Normalization**
```rpg
eval i = %scan('            ':prosj)
eval %subst(prosj:i:5) = ';;;;;'
eval w_rec = prosj
```
- Pads or replaces trailing spaces with delimiters to ensure the record splits correctly.

- Next, a series of `%xlate` statements:
  - **Character Conversion**: Replaces various special or platform-specific characters with proper Scandinavian letters (e.g., '�', '�', '�').

---

### c. **Parsing the Input Record**
A **long sequence of lines** uses index and substring operations, delimited by semi-colon `;`, to extract each field from the input record for:
- Project
- Subproject
- Activity

Example:
```rpg
eval i = %scan(';':prosj)
eval d_ppro = %trim(%subst(prosj:1:i-1))
eval prosj  = %subst(prosj:i+1:512-i)
```
- Repeats for every field in every section, parsing the record field-by-field.

---

### d. **Validation Logic**

For each level (Project, Subproject, Activity), the program performs:

**1. Existence Checks**:  
- Checks if the `project number` / `subproject number` / `activity number` exist by doing a `CHAIN` to appropriate files using built keys (combination of company, project number, etc).  
- If already present, logs errors like `'P1'`, `'P2'`, `'P3'`.

**2. Date Validations**:
- Validates and reformats **start and end dates** using a date-parsing subroutine (`testdato`).  
- If faulty, logs error codes (e.g., `'P4'`, `'U4'`, `'A4'`, etc).

**3. Master Data Lookups**:
- Looks up **project manager**, **department**, **customer number** in respective master files.
- If not found, logs with error codes (e.g., `'P6'`, `'P7'`, `'P8'`, etc).

**4. Code Value Checks**:
- Project type, status, and splitting flags (like "Uses subproject/activity") must be in allowed values.
- If not, logs errors (e.g., `'P9'`, `'P10'`, ...).

**5. Repeat for Subproject and Activity**:
- The same pattern (date, manager, department, etc.) repeats for each hierarchy.

---

### e. **Record Output and Logging**
- After validation, with or without errors, the program:
    - **Writes** a record to an output file (`rpxllur`), including error codes.
    - Prepares an updated log record combining the input with error string and uses an O-spec (Output specification) to write to an audit/output file.

---

## 6. **Subroutine: `testdato` – Date Validation**
This subroutine:
- **Attempts to parse dates** in several possible formats, including:
    - `ddmmyy`
    - `yymmdd`
    - `dd.mm.yy` / `dd-mm-yy`
    - `dd.mm.yyyy` / `dd-mm-yyyy`
    - `yyyy.mm.dd` / `yyyy-mm-dd`
- **If valid**, converts to ISO date format.
- **If invalid**, sets a flag so the main logic can append error codes.

---

## 7. **Subroutine: Initialization (`*inzsr`)**
- Builds all necessary **key-lists** for the various database lookups (project, subproject, manager, department, customer, etc).
- Sets up company/firm code.

---

## 8. **Output Specification**
```rpg
oxl_prosj  E            xl_upd
o                       prosj
```
- Defines the output record, matching the input, for auditing, logging, or confirmation, and probably includes error status, used in an EXCEPT statement.

---

## **Summary Table: Main Variables and Their Usage**

| Variable   | Description                           |
|------------|---------------------------------------|
| `prosj`    | Input record buffer                   |
| `d_xxxx`   | Parsed fields for project, subproj, activity |
| `w_feil`   | Collected error codes for the record  |
| `w_iso`    | ISO-formatted date                    |
| `w_rec`    | Working copy of the input record      |
| `l_user`/`l_firm` | From local data area            |

---

## **Typical Flow for a Single Record**

1. **Read input** from `xl_prosj`.
2. **Skip** if blank/header.
3. **Normalize** record (handle special characters, whitespace, delimiters).
4. **Parse** into component fields.
5. **Validate** each field:
   - Check existence in master tables.
   - Validate date formats.
   - Check code values, cross references.
6. **Write** output record with error codes, and update log file.
7. **Repeat** for next record.

---

## **Target Audience Notes**
- **This program is highly procedural, legacy RPG** (uses lots of substring, manual parsing).
- **All error handling is record-based** (aggregated error codes per record).
- **It is batch-oriented**, designed to process a large file (or stream) of project records in a single run.
- **Most downstream processing is driven by the error code field**, which can be checked by users or subsequent jobs.

---

## **Key Takeaways for New Developers**
- **Extend or adapt** error codes and logic as project definitions evolve, especially if data model or business rules change.
- To **modify field parsing** (e.g., add a new subfield), update both the parsing section and the validation logic.
- **Maintain consistency** between the field positions/order in the input file and the parsing logic.
- When **interfacing with new master data tables**, add new `CHAIN` logic and corresponding key lists.
- The **date parsing subroutine** is crucial for reliability—updates to accepted date formats must be coded here.

---

> **In short, the program reads and parses structured (semi-colon delimited) text lines representing project hierarchy, validates the existence, format, and cross-references fields across multiple master files, collects error codes, and writes updated records for error tracking or further downstream processing.**