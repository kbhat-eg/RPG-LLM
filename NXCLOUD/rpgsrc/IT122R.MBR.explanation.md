# IT122R â€“ Currency Rate Update from NAV

## Overview

This program, **IT122R**, is responsible for updating currency exchange rates in the system, based on data received from an external source (NAV). It supports three main operations: **INSERT**, **UPDATE**, and **DELETE** of currency rates, and also maintains a historical log of these updates.

The program operates primarily on the **RA16LU** logical file (renamed as `ra16lur`), which holds the main currency data, and also updates the historical register **RA61ST** via embedded SQL.

## Key Business Logic

- **Only updates existing currency codes:** New rates are only updated for currencies that already exist in the master table. Insert attempts for non-existing codes will trigger an update instead, but if the code does not exist, a status of '9' is set to avoid unnecessary logging (as per version 7.01 change).
- **Historical logging:** Every successful insert or update also writes an entry to the historical currency table (`RA61ST`), to keep track of rate changes over time (added in version 7.02).
- **Parameter-driven:** All operations and data are controlled via parameters passed to the program, allowing for flexible integration with upstream systems.

## Program Structure

### 1. Initialization and Parameter Handling

- **Parameters:**  
  - `p_firm`: Firm identifier  
  - `p_comd`: Command (`INSERT`, `UPDATE`, `DELETE`)  
  - `p_parm`: Parameter string containing currency data  
  - `p_user`: User performing the operation  
  - `p_stat`: Status output (set by the program)

- **Entry Point:**  
  The program begins at the `*inzsr` subroutine, where it initializes variables, parses parameters, and sets up the timestamp for the update.

- **Key List:**  
  The key for accessing records in `ra16lur` is composed of `w_firm` and `ra16lu_pkod` (currency code).

### 2. Main Processing

- **Parameter Parsing (`red_flt`):**  
  The subroutine `red_flt` extracts and transforms data from the parameter string (`p_parm`). It parses the currency code, description, date, and exchange rate, handling both formatting and conversion to appropriate data types.  
  - The currency code is at position 59 (3 characters).
  - The description is at position 62 (20 characters).
  - The date is parsed from position 40 (10 characters), with dashes removed and converted to numeric and date types.
  - The exchange rate is extracted by locating the comma, then finding the start of the number, and converting it to a packed decimal with 6 decimals.

- **Command Dispatch:**  
  Based on `p_comd`, the program dispatches to the corresponding subroutine:
  - `nyrec` (Insert)
  - `oppdrec` (Update)
  - `sletrec` (Delete)

### 3. Subroutines

#### A. Insert (`nyrec`)

- Checks if the currency code exists in `ra16lur`:
  - **If not found:** Creates a new record with the provided data, sets status to '1', and calls `val_hist` to log the change.
  - **If found:** Calls `oppdrec` (update logic) instead.

#### B. Update (`oppdrec`)

- Checks if the currency code exists in `ra16lu`:
  - **If found:** Updates the record with new data, sets status to '1', and logs to history.
  - **If not found:** Sets status to '9' (indicating no update performed).

#### C. Delete (`sletrec`)

- Attempts to delete the currency code from `ra16lur` if it exists, and sets status to '1'.

#### D. History Logging (`val_hist`)

- Uses embedded SQL to insert a row into `ra61st` (historical currency table) with the updated values and a system identifier `'N_SYST'`.

#### E. Error Handling (`*pssr`)

- If an unhandled error occurs, clears the status and signals program end.

### 4. File and Database Interactions

- **`ra16lur` (RA16LU):** Main logical file for currency rates. All CRUD operations target this file.
- **`ra61st`:** Historical register for currency rate changes. Updated via embedded SQL after every successful insert or update.

### 5. Notable Design Decisions & Conventions

- **Parameter String Parsing:** The program expects a fixed-format string for incoming data, and uses position-based parsing. This is a legacy approach common in older RPG systems, but requires upstream systems to adhere strictly to the format.
- **Status Codes:** The program uses a single-character status output (`p_stat`) to indicate operation results:  
  - `'1'` = Success  
  - `'9'` = Update not performed (record not found on update)
- **Minimal Logging:** By setting status `'9'` when an update is not performed, the program avoids unnecessary logging, as per customer request.
- **Embedded SQL for History:** Modernizes the historical logging by using SQL, ensuring compatibility and performance.

### 6. Integration Points

- **Upstream:** Expects to be called by a controlling program or batch process, which passes in the required parameters.
- **Downstream:** Updates are reflected in the currency master (`ra16lu`) and history (`ra61st`), which may be used by financial modules, reporting, or audit trails.

## Summary Table

| Subroutine   | Purpose                                              |
|--------------|------------------------------------------------------|
| `*inzsr`     | Initialize, parse parameters, set up keys/timestamps |
| `red_flt`    | Parse and convert parameter string to variables      |
| `nyrec`      | Insert new currency rate, or update if exists        |
| `oppdrec`    | Update existing currency rate                        |
| `sletrec`    | Delete currency rate                                 |
| `val_hist`   | Log update to historical table (via SQL)             |
| `*pssr`      | Error handling                                       |

## Key Variables

- `w_firm`, `w_gkod`: Firm and currency code (from parameters)
- `w_text`: Currency description
- `w_dato`, `w_date`, `w_time`: Date/time of rate
- `w_kurs`: Exchange rate (decimal, 6 decimals)
- `p_stat`: Status output

---

**In summary:**  
This program is a robust, parameter-driven utility for maintaining currency rates in the system, with built-in auditing and careful handling of business rules around updates and logging. It is designed for integration with automated data feeds and supports traceability via historical records.