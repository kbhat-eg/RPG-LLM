# RPG Program MO701R – Source Code Explanation

This RPG program (MO701R) is designed to monitor and generate base data for type 7: it counts the number of outstanding backorders for stock items per day. Here's a detailed explanation for onboarding developers.

---

## High-Level Purpose

- **Primary Goal:**  
  For a specific company and date, the program:
  - Removes previous monitoring records for that date.
  - Scans sales orders, identifies stock items with outstanding quantities (backorders).
  - Logs these findings in a monitoring file for further reporting or analysis.

---

## Header and Documentation

- **`h option(*nodebugio) datedit(*dmy)`**  
  - Compilation options: No debug IO, date format DD/MM/YY.

- **Program/Modification Log:**  
  - Contains detailed comments on system, program, version history, and summary of changes (including extended functionality and bug fixes).

---

## File Definitions (`F-Specs`)

Defines several physical/logical files mapped to the program with renames:

- **Order header/details files**: `foheld`, `fodtl1`, `fodtlv`, `sodtlr`
- **Item master files**: `vvarl1`, `votylr`, `vvlel1`
- **Monitoring log (output) file**: `lwo7lu`
- All files are opened for input (`I`), update (`U`), frequently keyed, and sometimes with alternate record formats via `rename`.

---

## Data Definitions (`D-Specs`)

- **Work Variables:**  
  - Mirrors for fields in file records to hold values during processing, e.g.:
    - `foheld_bdat`, `fodtlv_vare`, `sodtlr_aarr`, `lwo7lu_odat`, etc.
  - System fields: company (`w_firm`), date (`w_dato`), user, time, order numbers, etc.
  - Utility flags: `b_inlr`, `b_rest`, `b_lagv` (used as logical switches).

- **Local Data Area:**  
  - Extracts company number from user space.

---

## Main Program Flow

### 1. **DELETE PHASE**: Cleans Up Previous Records

- **Deletes** previous monitoring records for `w_dato` (the date being processed) from the `lwo7lu` file.

### 2. **READ PHASE**: Processes Orders

- **Sets the year part:** Extracts year from processing date for use in historical keys.
- **Calls subroutine `les_ordre`:** Reads through the order header file (`foheld`), filters, then processes order lines.

---

## Subroutines

### `les_ordre`: Reads through Orders

- Loops through all order headers for the company/date.
- **Checks order type** via `votylr` file (ignores type 0, skips quotes).
- For each matching order, loops through corresponding order detail lines (`fodtl1`).
  - Calls `ctrl_vare` to check if item is a stock item.
  - If yes, calls `ctrl_rest` to check for backorders (remaining quantities not yet fulfilled).
  - If backorders exist (`w_ant > 0`), prepares output variables and calls `skriv_logg` to log the result.

### `skriv_logg`: Writes/Updates Monitoring Records

- **Clears record buffer.**
- **Checks** if a monitoring record for this combination already exists (`chain` on key).
  - If found: Updates it.
  - If not found: Initializes additional fields, then writes a new record.

### `ctrl_vare`: Checks if Item Is a Stock Item

- Calls an external program `VL710R` to determine item type.
- If the returned item type (`w_vtyp`) is 'L', sets `b_lagv` (*on).

### `ctrl_rest`: Checks for Outstanding Quantities (Backorders)

- Checks both detail (`fodtlv`) and historical sales lines (`sodtlr`) for outstanding quantities—tries multiple suffixes up to 98.
- Sets `w_ant` to the count found, and `w_sys` to indicate source.

---

## Initialization (`*inzsr`)

- **Define Key Lists:**  
  - For items, orders, order details, historical invoices, order type, and monitoring file.
- **Define Entry Parameters:**  
  - Accepts process date as input.
- **Sets up main work variables** from input/local data area.

---

## Notes on Some Special Conventions

- **Suffix Handling:**  
  - Suffix (typically 2-digit) is incremented to check for multiple lines/items on an order.

- **Logical Flags:**  
  - `b_lagv`: Set if item is a stock item.
  - `b_rest`: Used for controlling the backorder check loop.
  - `b_inlr`: Set at end-of-program to signal RPG to close files and cleanup.

---

## Sequence of Operation

1. **Entry (Mainline):**
   - Receives company and date.
   - Clears out old monitoring records for that date.
   - Extracts the year part.
   - Invokes order reading routine.

2. **Order/Line Processing:**
   - For each order, for each detail:
     - Checks if it's a relevant item (stock item).
     - Checks for unfulfilled quantities.
     - If any are found, logs a monitoring record.

3. **Logging:**
   - Updates or inserts into monitoring file, with all relevant details (order, item, quantity, etc).

4. **Exit:**
   - Sets on *INLR to end program.

---

## Business Logic Summary

- **Removes old results**
- **Finds orders for a day**
- **For each order and line:**
  - Is it a stock item?
  - Is there backorder (unfulfilled quantity)?
  - Log summary if so

---

## External Dependencies

- **Program `VL710R`:**  
  Returns information on item type, used to check if an item is a stock item.

---

## Useful for New Developers

- **Key Learning Areas:**  
  - Understanding file/key usage, how record-level access works in RPG.
  - Familiarizing with typical Norwegian field names (`vare`, `numm`, `suff`, etc.).
  - Subroutine and entry parameter usage.
  - Handling suffix loops for split order lines.

---

## Nordic Language Notes

- Many comments and field names are in Norwegian:
  - `vare` = item/article
  - `dato` = date
  - `ordre` = order
  - `antall restordre` = number of backorders
  - `lagervarer` = stock item
  - `beskrivelse` = description

---

## Program Extension Points

- **Extending for new files** (new item types, new logging requirements)
- **Adapting to new data structures** by adjusting key lists and subroutine logic.
- **Internationalization** by altering comments/field names to English as needed.

---

**Summary:**  
This program is a batch utility for inventory/order management, scanning sales orders for a day, detecting backorders on stock items, and storing this data for type 7 monitoring reports. It demonstrates classic record-level RPG logic with business rules mostly codified in subroutines and external modules.