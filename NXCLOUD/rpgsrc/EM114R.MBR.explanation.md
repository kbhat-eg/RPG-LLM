# RPG Program Explanation: EM114R

This RPG program, **EM114R**, is used on the IBM i (AS/400) platform to check whether a customer has met the requirements for receiving a bonus. The logic is centered around verifying bonus eligibility based on customer and bonus template information.

---

## 1. **Header and Documentation**

- `h option(*nodebugio) datedit(*dmy)`
  - Specifies no debug I/O and uses day/month/year date editing.
- The extensive comments describe the program's purpose, history, indicator usage, and change log.
- The program is maintained in system "ASOFAK".

---

## 2. **File Declarations**

```rpgle
fembhi1    if   e           k disk    rename(embhst:embhi1r)
frkbpl1    if   e           k disk    rename(rkbppfr:rkbpl1r)
```
- **embhi1**: Bonus template file (renamed record format).
- **rkbpl1**: Customer file (renamed record format).
- Both are keyed (`k`) and externally described (`e`).

---

## 3. **Data Structures and Variables**

### Local Data Area (LDA)
```rpgle
d                uds
d  l_user               911    920
d  l_firm               944    946  0
d  l_fnav               951    980
```
- Reads values from specific substrings in the LDA, including user, firm, and navigation info.

### Display Feedback Data Structure
```rpgle
d dspfbk          ds
d  d_fcrn               378    379I 0
```
- Possibly used for display file feedback on cursor position.

### Key Variables
```rpgle
d embhi1_hbot     s                   like(emhbot)
d embhi1_hmnr     s                   like(emhmnr)
```
- Used to build the key for accessing the bonus template.

### Customer Key Variable
```rpgle
d rkbpl1_bkun     s                   like(rkbkun)
```
- Used to build the key for accessing the customer file.

### Working Variables
```rpgle
d w_firm          s                   like(emhfir)
d p_kund          s                   like(rkbkun)
d p_hmnr          s                   like(emhmnr)
d p_tbot          s                   like(emhbot)
d p_ok            s              1
```
- `w_firm`: Holds the company code.
- `p_kund`, `p_hmnr`, `p_tbot`: Parameters for the customer, bonus template, and template number.
- `p_ok`: Output flag indicating bonus eligibility ('1' = eligible, '0' = not eligible).

---

## 4. **Initialization (*INZSR) Subroutine**

```rpgle
c     *inzsr        begsr
c     *entry        plist
c                   parm                    p_kund
c                   parm                    p_tbot
c                   parm                    p_hmnr
c                   parm                    p_ok
```
- Entry parameters `p_kund`, `p_tbot`, `p_hmnr`, `p_ok` are set up for use.
- `embhi1_key` and `rkbpl1_key` klist blocks define composite keys for DB access, including firm.
- The firm (`w_firm`) is fetched from the LDA (`l_firm`).
- Subroutine ends with `endsr`.

---

## 5. **Main Processing Logic**

### Set Default Eligibility
```rpgle
c                   eval      p_ok = '1'
```
- Assume customer is eligible by default.

### Find Bonus Template
```rpgle
c                   eval      embhi1_hbot = p_tbot
c                   eval      embhi1_hmnr = p_hmnr
c     embhi1_key    chain     embhi1
```
- Set up key fields for bonus template (embhi1) and perform a `chain` (keyed read).

#### If Bonus Template Found
```rpgle
c                   if        %found(embhi1)
    * 2=Lojalitetsbonus 3=Betalingsbonus
c                   if        emhbka = 2 or
c                             emhbka = 3
    ...
```
- Checks if the bonus category (`emhbka`) is loyalty (2) or payment (3) bonus.

##### Check Customer Conditions
```rpgle
c                   eval      rkbpl1_bkun = p_kund
c     rkbpl1_key    chain     rkbpl1
c                   if        %found(rkbpl1)
    * Loyalty bonus
c                   if        emhbka = 2 and
c                             rkbloj <> 1
c                   eval      p_ok = '0'
c                   endif
    * Payment bonus
c                   if        emhbka = 3 and
c                             rkbbet <> 1
c                   eval      p_ok = '0'
c                   endif
c                   else
c                   eval      p_ok = '0'
c                   endif
```
- For **Loyalty Bonus (2)**: Checks if customer field `rkbloj` = 1. If not, not eligible.
- For **Payment Bonus (3)**: Checks if `rkbbet` = 1. If not, not eligible.
- If customer record not found, not eligible.

##### No Special Bonus Logic
```rpgle
c                   endif
```
- If the bonus type is neither 2 nor 3, no special check is done (defaults to eligible).

#### If Bonus Template Not Found
```rpgle
c                   else
c                   eval      p_ok = '0'
c                   endif
```
- If the bonus template isn't found, customer is not eligible.

### End of Program
```rpgle
c                   eval      *inlr = *on
```
- Ends the program and releases resources.

---

## 6. **Indicator Usage**

Described in the comments, but the program itself does not use numbered indicators directlyâ€”it relies on structured logic. Indicators mentioned include LR (last record), screen controls (10-15), error/warning (31-79), and work indicators (80-99).

---

## 7. **Summary**

- **Purpose:** Checks if a customer qualifies for a bonus based on template and customer data.
- **Inputs:** Customer number, template, template number.
- **Key Steps:**
  1. Load parameters and firm code.
  2. Look up the bonus template; if not found, return not eligible.
  3. If found and of relevant type:
      - Look up the customer.
      - For loyalty/payment bonus, check specific customer fields.
      - Set eligibility flag accordingly.
- **Output:** `p_ok` = '1' if eligible, '0' if not.

---

## 8. **Onboarding Notes**

- You must be familiar with the relevant files (`EMBHST`, `RKBPPFR`), especially fields like `emhbka`, `rkbloj`, `rkbbet`.
- The logic is simple: Find the bonus template, then, depending on the template type, check for customer conditions.
- All key lookups are controlled via explicit keys composed of firm and the relevant fields.
- The program is batch/CL-callable (not interactive), takes parameters, and returns an eligibility flag.

---

This structure makes it easy to change bonus requirements or extend checks for new bonus types in the future.