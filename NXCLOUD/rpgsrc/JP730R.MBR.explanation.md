# RPG Program Explanation: JP730R

This RPG program, JP730R, is used for updating or creating "betingelser/rabattelementer" (conditions/discount elements) based on data supplied from Norgros/NIB (in XML format), similar to rules found when importing from NOBB kontrakt. The program reads records from an input XML file and updates several physical/logical files containing condition and discount data.

Below is a detailed walkthrough of the code structure, logic, and key routines.

---

## 1. **Header and Metadata**

- Uses the *NODEBUGIO and *DMY date edit options.
- Comments indicate this is a maintenance program, regularly versioned and extended.
- Norwegian comments describe functional changes and business rules.

---

## 2. **File Declarations**

```rpg
fnxbepf    uf   e           k disk
fjvarl3    if   e           k disk    rename(jvarpfr:jvarl3r)
fjbetl1    if   e           k disk    rename(jbetpfr:jbetl1r)
fjbetla    if   e           k disk    rename(jbetpfr:jbetlar)
fjbetlu    uf a e           k disk    rename(jbetpfr:jbetlur)
fjraelu    uf a e           k disk    rename(jraepfr:jraelur)
fjstsl1    if   e           k disk    rename(jstspfr:jstsl1r)
```

- `nxbepf`: Main input file, presumably containing parsed XML data.
- `jvarl3`, `jbetl1`, `jbetla`, `jbetlu`, `jraelu`, `jstsl1`: Various files holding product, condition, and discount information. Often logical files on top of base files.

---

## 3. **Data Structure and Variable Definitions**

The code defines several data structures (DS) for the different components:

### Supplier Data (Leverandør):

```rpg
d                 ds
d d_lrec                        20
d  d_levn                        6    overlay(d_lrec:1)
d   d_levn_num                   6  0 overlay(d_levn:1)
d  d_stat                        1    overlay(d_lrec:7)
d   d_stat_num                   1  0 overlay(d_stat:1)
```
- Used to manage supplier numbers and status.

### Condition Data (Betingelse):

```rpg
d                 ds
d d_brec                       150
d  d_ogrp                        2    overlay(d_brec:1)
d   d_ogrp_num                   2  0 overlay(d_ogrp:1)
...
d  d_bkey                       10    overlay(d_brec:33)
d   d_bkey_num                  10  0 overlay(d_bkey:1)
d  d_btxt                       35    overlay(d_brec:43)
...
d  d_bfda                       10    overlay(d_brec:78)
d   d_bfda_iso                    d   overlay(d_bfda:1) datfmt(*iso)
...
```

- Holds parsed fields for one "betingelse" (condition), with overlays for both alphanumeric and numeric interpretations of data.
- Dates are handled in both character and ISO date formats.

### Discount Element Data (Rabattelement):

Similar pattern as above, structured for the discount element.

### Key Variables

Many single variables are defined like `jbetl1_ogrp`, `jbetla_beti`, etc., typically used to map data from input or structures to database keys for file access/update.

---

## 4. **Constants**

Many constants are defined for:

- XML tags (e.g., `<Lev>`, `<Status>`, `<Betingelse>`, `<Rabattelement>`, etc.)
- Common digit/character sets.
- Numeric and special values for business logic.

---

## 5. **Program Initialization**

```rpg
c                   eval      b_inlr = *on
c                   time                    w_edat
c                   time                    w_etim
```
- Flags the end of the program (`*INLR = *ON` at end).
- Gets current date and time for use in record stamping.

---

## 6. **Main Processing Loop**

### Reads the XML-Extract File Line-by-Line

```rpg
c                   read      nxbepfr
c                   dow       not %eof(nxbepf)
   ...
c                   delete    nxbepfr
c                   read      nxbepfr
c                   enddo
```
- Each record in `nxbepf` represents (presumably) a line/element from an XML file.
- For each line, the code:
  - Detects and processes elements based on their opening XML tag.
  - Handles distinction between supplier, condition, and rabattelement records.
  - Calls appropriate "uttr_xxx" (extract_xxx) or "beh_xxx" (process_xxx) subroutines.

---

## 7. **Element Parsing and Extraction**

For each XML element encountered:

- Uses `%scan` and `%subst` to find and extract relevant content between tags.
- The logic and the field list (constants for XML tags) handle business-specific XML structures.
- Elements such as `<Lev_nr>`, `<Status>`, `<Betingelse>`, `<Rabattelement>` trigger their treatment routines (`exsr ...`).

---

## 8. **Subroutines**

Key subroutines found in the code:

### **uttr_kild**: Identify Source

- Sets flag if correct "Kilde" (source) is detected (e.g., '0' for NIBk).

### **beh_levr**: Process Supplier Block

- Loops through all lines for a supplier.
- Detects start of new condition and processes with `beh_beti`.
- At the end, calls `rydd_levr` to clean old conditions and discounts for the supplier.

### **levr_init**: Supplier Initialization

- Clears supplier data structure.

### **uttr_levn/stat**: Extract Supplier Number/Status

- Validates and parses these fields.

### **beh_beti**: Process Condition

- Loops through XML lines within a `<Betingelse>` block.
- Extracts all relevant condition fields.
- At end of block, calls `skr_beti` to update/create condition record.

### **beti_init**: Condition Initialization

- Clears/zeros all fields in the betingelse data structure.

### **uttr_xxx Subroutines**: One for each parsed condition field, e.g., `uttr_ogrp`, `uttr_nobb`, `uttr_teks`, etc.

- Parse, validate, and store data in DS fields.

### **skr_beti**: Write/Update Condition Record

- Handles update-or-insert logic for condition based on file keys.
- Special logic for NOBB-vs-NIB numbers, and for "Farveringen" company.
- Sets various output fields, handles activation flags, and writes to `jbetlur` (update file).

### **beh_raba**: Process Discount Element

- Similar pattern to `beh_beti`, but for `<Rabattelement>`.
- Extracts and validates discount fields, calls `skr_raba` to update.

### **skr_raba**: Write/Update Discount Element

- Verifies all flags and required data.
- Handles value conversion (including decimal, negative values, and exceeding max).
- Updates or creates record in `jraelur`.

### **konv_XML_esc**: Convert XML Escaped Characters

- Converts XML character entities (such as &amp;, &lt;, etc.) to their actual characters in text fields.

### **rydd_levr & slett_raba**: Data Cleanup

- Remove old "not own" conditions and discounts for the current supplier.

### **sjekk_endr**: Check for Changes in Discount Element

- Looks up existing (backup) records to determine if any field has changed, setting flags accordingly.

---

## 9. **Keys and File Access "KLIST"s**

- Various "klist" and "kfld" blocks are defined for building file access keys.
- Each file (conditions, discounts, backup) has a set of key fields to facilitate efficient searching and updating.

---

## 10. **Entry and Parameter Handling**

- The program accepts the firm number as a parameter (`p_firm`), stores in `w_firm`, and uses that as part of all key lookups and writes.

---

## 11. **Error Handling, Validation, and Data Integrity**

- Many flags, such as `b_lfel`, `b_bfel`, and `b_rfel`, are set if fields are invalid or missing.
- Subroutines like `skr_beti` and `skr_raba` check these before writing, and skip write if a flag is set.
- Data validation includes checks for proper numeric format, correct field lengths, and date values.

---

## 12. **Special Notes**

- Several sections are commented out (using `c*`)—these may be logic that was previously in use or retained for reference.
- Comments in Norwegian help clarify company- or domain-specific logic (e.g., special business rules for "Farveringen" or extended price group logic).

---

## **Summary**

This program is a classic, large-monolithic RPG routine for mass-importing and updating condition/discount (betingelse/rabattelement) data from XML extracts provided by external parties, with careful validation, key management, and record-keeping. The XML is parsed in its own (non-XML-parser) way by scanning for tag names and extracting substrings.

**Main takeaways:**
- Reads each XML element sequentially from a file.
- For each detected business object (supplier, condition, discount), processes all its elements/sub-fields.
- Updates or creates records in condition and discount files as needed.
- Maintains data integrity and prevents duplicates by using composite keys and field flags for validation.
- Cleans up old data for the same supplier when new data is processed.
- Converts XML-escaped characters in text fields for proper storage.
- Handles date/time stamping and user tracking as appropriate for audit.

**If you’re onboarding to this code:**
- Understand the data files and their structures.
- Review the key structure for each file and how the program manages updates vs. inserts.
- Familiarize yourself with the custom XML parsing approach.
- Pay special attention to the use of overlays and flags for field validation and data integrity.

*If you have questions about specific routines or file layouts, provide the source or DDS for further analysis!*