# Program AP055R – Integration with Lognet Transport Service

## Overview

This RPG program (`AP055R`) is a core integration component between our ERP system and the Lognet transport service. Its primary function is to assemble, send, and process shipment order information as JSON via a REST API, facilitating logistics and transport tracking. The program extracts order, customer, and item data from internal files, formats it into a JSON request according to a template, sends it to Lognet, and processes the response, updating local tracking records accordingly.

The program is heavily parameterized and relies on a variety of configuration switches, file-based data, and external service calls. It is designed to be robust, with multiple business rules and fallback mechanisms to handle data inconsistencies and integration failures.

---

## Key Business Logic and Flow

### 1. **Initialization and Parameter Handling**

- The program expects several parameters:
  - `p_firm`: Company code
  - `p_numm`: Order number
  - `p_suff`: Order suffix
  - `p_toid`: Transport order ID (optional, may be generated)
  - `p_2fid`: Alternative transport provider code (optional)
  - `p_stat`: Status return value

- It loads various configuration and credential values from the `afpspf` and `aposextnst` tables using embedded SQL. These include API URLs, user credentials, JSON template paths, and API keys.

- Several switches are loaded to control business rules:
  - Whether to include internal orders in the transfer (`u_inte`)
  - Whether to perform character set conversion on dates (`u_konv`)

### 2. **Order and Customer Data Retrieval**

- The program looks up order header (`fohel1`), order lines (`fodtlr`), customer (`rkunl1`), and warehouse/department (`ra10l1`) data.
- It gathers shipment details such as sender and receiver addresses, contact information, number of packages, total weight/volume, and other references.

- Special handling exists for:
  - Internal order types (may be excluded from transfer based on configuration)
  - Overriding the default transport provider code if specified for the warehouse
  - Generating unique shipment references if not already present

### 3. **JSON Request Construction**

- The JSON request is built using a template loaded from the IFS (integrated file system). The program uses the CGIDEV2 toolkit to substitute variables into the template.
- Key fields populated include:
  - Shipment and order references
  - Dates (with optional character set conversion)
  - Sender, receiver, and delivery addresses
  - Contact and phone information
  - Package, weight, and volume details
  - Line item details (looped for each order line, with weight/volume calculations)

### 4. **Transmission to Lognet**

- The filled JSON request and its headers (including the API key) are written to files in the IFS.
- The program then calls the external program `AW702C` to perform the HTTP POST to Lognet's `/api/shipment` endpoint.
- The response is expected in a corresponding `.response` file.

### 5. **Response Handling and Local Update**

- The program reads the response file, extracting the `consignmentReference` (Lognet's tracking ID) from the returned JSON.
- It updates or inserts a record in the local tracking table (`ftrpiu`) with the new consignment reference and status.
- Character set conversion on the response file is attempted if required by configuration, using the program `AP060C`.

### 6. **IFS File Cleanup**

- After successful processing, the program attempts to clean up (delete) the request, header, and response files from the IFS. This is currently disabled for safety (`if 1=2`), but the code is present for future reactivation.

### 7. **Error Handling**

- Any failure in data lookup, file I/O, or web service call results in the status being set to 'FALSE' and the program exiting gracefully. There is a PSSR error routine for unexpected errors.

---

## Notable Design and Domain-Specific Features

### A. **File and Database Interactions**

- **Data Files**: The program interacts with a large number of files, most of which are logical or physical files representing orders, customers, items, and configuration data.
- **SQL Usage**: Embedded SQL is used for configuration and credential retrieval, making it easier to adapt to new settings without code changes.
- **IFS**: The use of IFS for JSON request/response management allows for easy debugging and integration with external HTTP clients.

### B. **Template-Based JSON Construction**

- The use of CGIDEV2's HTML buffer and variable substitution routines (`UpdHTMLVar`, `WrtSection`, etc.) allows for flexible and maintainable JSON request construction. The template can be changed without code modification.

### C. **Business Rule Switches**

- Switches for including/excluding internal orders and for character set conversion are controlled via configuration, with logic to override global settings per warehouse.
- The program supports custom transport provider codes per warehouse (overriding the default from the configuration file).

### D. **Shipment Reference Generation**

- If an existing transport order ID is not found, the program generates a new one based on the current date and order number, with optional character set adjustments.

### E. **Order Status Logic**

- The program determines whether an order is ready for dispatch by scanning the log file for status code '6' or higher, checking both the current and previous year to handle year-crossing orders.

### F. **Item Weight and Volume Calculation**

- For each order line, the program attempts to determine weight and volume from several sources, falling back as needed, and excludes lines representing services or miscellaneous items.

### G. **Contact and Phone Number Handling**

- Contact person and phone number are sourced from multiple places, including customer project records and customer master data, with fallback logic to ensure the best available information is used.

### H. **External Program Calls**

- Several external programs are called for specialized tasks:
  - `FO780R`: Calculates total weight/volume for the order
  - `VL710R`: Retrieves item type and related info
  - `AW702C`: Performs the HTTP POST to Lognet
  - `AP060C`: Handles CCSID (character set) conversion on response files
  - `CO402R`: Reads configuration switches

---

## Module and API Relationships

- **CGIDEV2**: Used for template management and variable substitution in building JSON requests.
- **AW702C**: Handles the actual HTTP communication with Lognet’s API.
- **AP060C**: Used for character set conversion on files received from Lognet.
- **CO402R**: Reads configuration switches, especially for controlling transfer of internal orders and character set conversion logic.
- **FO780R/VL710R**: Used for business logic calculations on orders and items.

---

## Coding and Naming Conventions

- **File and Field Prefixes**: File names and fields use consistent prefixes (e.g., `fohel1`, `fodtlr` for order header/lines, `rkunl1` for customer, etc.).
- **Key Lists**: Key lists (`klist`) are defined for each file access pattern, ensuring maintainability and clarity.
- **Version Comments**: The code is well-commented with version markers (e.g., `7.01`, `8.02`) indicating when changes were introduced and by whom.
- **Switches and Flags**: Boolean flags are named with `u_` and `b_` prefixes for user and business switches, respectively.

---

## Error Handling and Robustness

- The program is defensive: any missing required data (order, customer, configuration) causes an immediate exit with a 'FALSE' status.
- File and API errors are handled with explicit checks and a central error routine.

---

## Integration Points and External Dependencies

- **IFS Path**: All temporary files are placed in `/home/<company_group>/trp_tracking/`.
- **Configuration Table**: The `afpspf` and `aposextnst` tables are central sources for runtime configuration, API credentials, and template locations.
- **Lognet API**: All communication is via REST, with JSON payloads and API key authentication.

---

## Summary Flow

1. **Initialization**: Load parameters, configuration, and credentials.
2. **Data Gathering**: Retrieve order, customer, item, and warehouse data.
3. **Business Logic**: Apply rules for internal orders, provider codes, and status.
4. **JSON Construction**: Build the request using a template and substitute all required variables.
5. **Transmission**: Write the request to IFS and send it via HTTP POST.
6. **Response Handling**: Read and parse the response, update tracking records.
7. **Cleanup**: Attempt to delete temporary files.
8. **Error Handling**: On any error, set status to 'FALSE' and exit.

---

## For New Developers

- **Understand the data model**: Familiarize yourself with the order, customer, and item files, as well as the configuration tables.
- **CGIDEV2 usage**: The JSON request is built using CGIDEV2 routines—review the templates in IFS for structure.
- **Switches matter**: Many business rules are controlled by configuration switches, which can be set globally or per warehouse.
- **External calls**: Know what each called program does, especially for weight/volume calculation and HTTP communication.
- **Debugging**: Temporary files in IFS are your main resource for troubleshooting integration issues.

---

## Change History and Maintenance

- The code is heavily versioned with detailed comments for each change, including bug fixes, feature additions, and adjustments for business rules.
- All major integration points and business logic branches are documented in the comments for traceability.

---

**In summary**, this program is a critical middleware component for outbound logistics, with a strong emphasis on configurability, data integrity, and robust integration with external transport services. Understanding its structure and flow is essential for maintaining and extending our logistics integration capabilities.