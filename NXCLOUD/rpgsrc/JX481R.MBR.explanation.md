# IBM ILE RPG Code Explanation

This program is written for IBM i (previously AS/400) in ILE RPG and handles processing of product (item) records with reference to price groups. Below is a detailed explanation of its structure and logic to help orient new developers.

---

## 1. **Program Overview and Purpose**

The header comments describe the system and program:
- **System**: ASOFAK
- **Program**: JX481R
- **Description**: Finds all items with a price group, checks status, and deletes those found.
- **Main tasks**:
    - Looks up items (varer)
    - For each item, finds relevant price group data
    - Performs processing (including output)
    - Deletes records as needed

---

## 2. **File Declarations**

Several files are declared at the top using the `F` spec:
- `vvarl1` - Main item master file.
- `jlevl3` - Supplier data (“lev” = “leverandør”, supplier).
- `jvdtl1` - Possibly detail data for items.
- `ra30l1` - Used for price group association.
- `vvprlr`, `vvprlu` - Price-related files (`uf` means update file).
- `lwexpf` - Output file (probably a report/export file).

All files are declared with external descriptions and keyed access.

---

## 3. **Data Definitions**

### Local Data Area (LDA)
- `l_firm` is used to fetch the firm/company code from the local data area.

### Key Variables
Variables like `jlevl3_enum`, `jvdtl1_dvar`, etc., are used to hold keys for file access (CHAIN, SETLL, READE).

### Working Variables
A number of working fields such as `w_prgr`, `w_pgbe`, `w_pgfr`, etc., are used for price group, status, quantities, and other attributes.

---

## 4. **Control Flow: Main Program Logic**

#### **Initialization**
- The program probably starts with `*INZSR` (initialization subroutine), setting up keys and reading the firm number, writing export file headers, and fetching tax/mva factors.

#### **Main Loop**
1. **Read all items**:  
   ```
   vvarl1_key setll vvarl1
   vvarl1_key reade vvarl1
   dow *in90 = *off
   ```
   This reads through the entire item master file.

2. **For each item**, check if it's relevant:
   ```
   if vvnobb <> 0
   ```
   (Checks a selection field on the item.)

3. **Find all price groups for the item**:
   ```
   ra30l1_key setll ra30l1
   ra30l1_key reade ra30l1
   dow not %eof
      exsr finn_prisg
      ra30l1_key reade ra30l1
   enddo
   ```
   For each price group found, call subroutine `finn_prisg`.

4. **Repeat for all items**.

---

## 5. **Subroutines**

### **finn_prisg** (Find Price Givers)
- **Purpose**: Finds all “price givers” (suppliers/prices) for a given item and price group.
- **SQL Cursor**: Uses embedded SQL to select all distinct `vpldor` (probably supplier or price provider) for the current item and price group.
    ```
    declare prisg cursor for
      select distinct(vpldor)
      from vvprpf
      where vpfirm = :w_firm and
            vpvare = :vvvare and
            vpprgr = :redkod and
            vpldor <> 0
      for read only
    ```
- **Processing Loop**:  
  Opens this cursor, fetches each result, and for each, calls the `behandling` (processing) subroutine.

### **behandling** (Processing)
- **Purpose**: For the current item, price group, and supplier, processes the business logic.
- Looks up additional details (calls `hent_pris`).
- If some calculated/returned fields are blank (e.g., `w_prut`, `w_pgbe`, `w_pgfr`), appends item info to `exclin` string and writes it to `lwexpfr`.
- **Deletes** all records for the combination from the update file `vvprlu/vvprlur`.
    - This is a purge/cleanup step.

### **hent_pris** (Fetch Price Information)
- **Purpose**: Fetches price info and status for transfer from the item master to another register.
- **Looks up supplier** in `jlevl3` file.
- **Calls another program** (`JV750R`) with a large list of parameters — likely a central price calculation routine.
- Assigns returned values to working fields for further processing.

### **Initialization (`*inzsr`)**
- **Defines all key lists** for file access.
- **Initializes w_firm** from the LDA.
- **Writes file headers** to the export/output file (`lwexpfr`).
- **Fetches tax/mva factors** (calls program `FØ705R`).

---

## 6. **Other Details**

- **SQL Integration**: 
    - Uses embedded SQL in RPG for dynamic data selection.
- **Norwegian Comments/Field Names**: 
    - The program was written in a Norwegian context (e.g., “varenr” = item number, “prisgruppe” = price group, “leverandør” = supplier, “sletter” = delete, etc.).
- **Version Comments**:
    - Comments throughout reference dates and changes, indicating ongoing maintenance and enhancements.

---

## 7. **Typical Run-Through Example**

1. Program starts, reads firm number, writes headers.
2. Loops through items in the master file.
3. For each item:
   - If selection field (`vvnobb`) is not zero, loops through all matching price groups.
   - For each price group, finds all suppliers/price givers via SQL.
   - For each combination, fetches price data, writes to output if conditions met, and deletes records from the update file.

---

## 8. **Key Points for Developers**

- **Subroutines**: All business logic is encapsulated in subroutines – `finn_prisg`, `behandling`, `hent_pris`, and `*inzsr`.
- **Keyed File Access**: Extensive use of keyed file access for efficient lookup.
- **Purge Operation**: After writing export records, related records are purged from the working/update files.
- **External Programs**: Central logic is delegated to other programs (e.g., price calculation).

---

## 9. **Onboarding Hints**

- **Understand the file layouts**: Review file definitions in DDS.
- **Study the external programs**: Especially `JV750R` and `FØ705R` for price and tax logic.
- **Test impact**: Because records are deleted, run in a test environment first!
- **Field names**: If not familiar with Norwegian, keep a reference for field translations.

---

### In summary:
This program is a batch-utility that:
- Iterates through all products,
- For each product, finds price group and supplier combinations,
- Checks and exports their price data if certain conditions are met,
- Cleans up by deleting processed records.

The design splits data gathering, processing, and deletion into modular subroutines with careful key management and SQL integration.