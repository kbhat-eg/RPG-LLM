# RPG Program: Selection of Purchasing Statistics Transactions (Utvalg av innkjøpsstatistikktransaksjoner)

---

## Overview

This RPG program is used to select and process records from a purchasing statistics file. It allows a flexible selection (filtering) and sorting of records according to a wide range of parameterized options, driven by control parameter files. The output is typically a report, with structured headings and groupings, suitable for further analysis or review.

The program is used in a Norwegian business context (as indicated by naming and comments) and is tailored for IBM i (AS/400) systems. It uses traditional fixed-format RPG IV (ILE RPG) coding conventions.

---

## Key Components

### File Declarations

- **Fslpml1**: Selection parameter file (`slpml1`), input only, keyed access.
- **Fsistpf**: Main statistics transaction file (`sistpf`), input only, sequential access.
- **Fslwwpf**: Output file for selected records (`slwwpf`), output only.
- **Fsi600p**: Printer file for report output (`si600p`), output only.

### Data Structures

A large number of arrays and data structures are defined to hold selection criteria, sort terms, grouping values, and support variables.

- **rpt, utv, hhgr, uhgr, uugr, rgr, oogp, hogp, hhgp, uogp, uhgp, uugp, kka, rka, dis, sel, lan, srfvar, srtvar, srflev, srtlev, srflad, srtlad, oty, avd, lag, pra**: Arrays to hold selection codes and parameter values for different sorts of groupings and fields (see the end for code numbers to meaning mapping).
- **w_ahug, w_ohug, w_peri, ...**: Work variables and overlays for building and manipulating compound sort/group keys.
- **alfX**: Temporary alphanumeric variables for matching and comparison.

### Input Specifications

- Detailed I-specs read fields from the selection parameter file (`slpml1`), depending on the selection code.

### Main Control Flow

#### 1. **Initialization**
- The *INZSR subroutine initializes all working variables and reads parametric control records from the selection parameter file to set up selection and grouping arrays.

#### 2. **Main Processing Loop**
- Tag `xtrans`: The main read loop.
    - Reads a record from the main statistics file (`sistpf`).
    - If EOF, branches to tag `endprg` to close out and report.
    - Checks if the record belongs to the correct company (FIRMA).
    - For each possible selection/grouping (driven by `utv(x) = 'J'`), calls the appropriate subroutine to determine if the record matches the criteria. If any check fails (`*IN98 = *ON`), skips to the next record.
    - If all selection checks pass, builds up to three sort keys (`swsrt1`, `swsrt2`, `swsrt3`) based on which sort flags are set, using fields from the current record.
    - Writes the qualifying record to the output file (`slwwpf`), and loops back for the next read.

#### 3. **Subroutines for Selection Logic**
- **subhgr, subugr, subrgr, subgrp, subkka, subrka, subdis, subsel, sublan, subvnr, sublnr, subper, subfnr, subfda, suboty, subavd, sublag, subpra, subkam**
    - Each subroutine is responsible for one kind of selection (e.g., main group, sub-group, discount group, etc.)
    - These routines compare the current record's field(s) to the corresponding parameter list, set *IN98 to OFF if there is a match, or leave it ON to indicate exclusion.
    - For range-based checks (like product number from/to), they check if the current record's value is inside any defined range.

#### 4. **Building Sorting Terms**
- The program allows the user to define up to three sort terms (field concatenations) per record, using flags (*IN11, *IN12, etc.) that correspond to the selection parameter file configuration.
- The sort keys are then filled by moving/copying the relevant record fields as specified.

#### 5. **Report Headings and Overflow Handling**
- Subroutines (heading, overflow) are used to print report titles/headings, especially at page breaks.

#### 6. **Final Totals and End Processing**
- At end-of-job, or end-of-data, the program writes summary/totals records and headings as necessary.

---

## Parameterization and Selection Codes

At the end of the source is a list of code numbers and their meaning (see `GRUPPER SOM KAN SELEKTERES`). Example codes:

| Code | Meaning                |
|------|------------------------|
| 11   | Hovedgruppe            |
| 12   | Undergruppe            |
| 13   | Rabattgrp.             |
| 14   | Overgruppe (Nobb)      |
| 21   | Leverandørkategori     |
| 22   | Rabattkategori         |
| 23   | Distrikt               |
| 24   | Selger                 |
| 25   | Land                   |
| 31   | Varenummer             |
| 32   | Leverandør             |
| 41   | Periode                |
| 42   | Fakturanummer/Kreditnr |
| 43   | Fakturadato            |
| 44   | Kampanje               |
| 51   | Ordretype              |
| 52   | Avdeling               |
| 53   | Lager                  |
| 54   | Produktansvarlig       |

These codes allow the same program to flexibly filter by almost any business dimension needed in purchasing statistics.

---

## Example: How A Selection Works

Suppose the user sets up parameters to select only records for "Hovedgruppe" (main group) 10 and 20.

- In the parameter file (`slpml1`), there are entries for `srkode = 11` (main group), with group numbers 10 and 20 set.
- During the processing, for each record, the program checks `utv(11) = 'J'` (main group selection active), calls `subhgr`, which loops through the `hhgr(n)` array to compare against the current record's main group; if a match is found, the record is included.

---

## Notable Technical Features

- **Highly Parameterized**: Changing which fields records are selected or grouped/sorted by does not require source code change, only parameter table changes.
- **Traditional RPG**: Uses fixed-format, primarily C-specs and I-specs, which is common in IBM i batch/report programs.
- **Array-based Design**: For flexibility in handling up to 999 selection/grouping values per field.
- **Legacy Techniques**: Heavily uses MOVE, MOVEL, EVAL, and overlays for field processing, typical of older RPG.
- **Early Exit**: Uses GOTO and tags for structured processing, with fast skip-outs for unmatched records.
- **Structured Output**: Report headings, overflow handling, and subheading writing are controlled via subroutines.

---

## How to Onboard a Developer

- **Understand the parameter table (`slpml1`)**: All selection and sorting logic is driven by this file.
- **Get familiar with the data dictionary**: Know what each code and field stands for (see the meaning code table above).
- **Trace the main loop**: The program reads one stat record at a time and passes it through a series of selection routines.
- **Match RPG code blocks to business logic**: Each subroutine is named for its purpose (e.g., `subhgr` = select on main group).
- **Recognize the sort-logic flags**: Which flags like *IN11 or *IN12 get set depends on what the controlling parameter record says (see heading construction in *INZSR).
- **Adapt to new requirements by adjusting parameters**: To change what is selected/sorted on, update the control/parameter file, not the code.
- **Output record structure**: The final output can be used as input for other processes or as a direct report, depending on system setup.

---

## Summary

This program is a robust, highly parameterized engine for selecting, grouping, and sorting purchasing statistics transactions on IBM i. It reflects best practices from traditional RPG batch reporting and offers strong flexibility through its external parameter control. New developers should focus on:
- Understanding the selection parameter structure and code mapping,
- Tracing selection and sorting through the well-named subroutines,
- Recognizing the role of each array and workfield.

All changes and customization for business needs are intended to be achieved through externalizing parameters rather than changing the RPG code itself.