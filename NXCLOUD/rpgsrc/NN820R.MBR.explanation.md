# Program Overview  
This RPG ILE program (NN820R) services a data queue request to fetch invoice headers (“faktura-hode”) from ASOFAK’s sales files. It:  
- Reads requests from an input data queue.  
- Determines matching invoices.  
- Returns counts and detailed invoice headers via an output data queue.  

---

## File Definitions  
- **sohelr, sohel1, sohel5, sohel6**  
  - All keyed physical files (`IF E K DISK`) renamed to `sohel?r`.  
  - They represent different keyed views of the same underlying invoice header records (e.g., by invoice number, date, customer name).  

---

## Parameters  
Parameters arrive via program interface (data queue API):  
- **p_dtqi/p_dtqo**: Input/output data queue names.  
- **p_bibl**: Library name for data queue.  
- **p_inpl/p_outl**: Input/output data lengths.  
- **p_wait, p_keyo, p_keyl, p_uniq, p_sndl, p_sndi**: API control values.  
- **p_firm**: Company number.  
- **p_feil**: Error indicator.  

---

## Data Structures  
1. **Input DS (d_inpu, 70 bytes)**  
   - d_aarr (year), d_kund (customer), d_binr (invoice#), d_fkda (invoice date), d_navn (name), d_fbla (start invoice#), d_anta (quantity).  
2. **Output DS – count (d_outa, 7 bytes)**  
   - d_arec = '1' (record type), d_antf (number of matches).  
3. **Output DS – detail (d_outp, 65 bytes)**  
   - d_orec = '2' (record type), d_obin (invoice#), d_ofkd (date), d_onav (name), d_fsum (sum).  

---

## Variables & Constants  
- **Work fields**:  
  - w_firm, w_aarr, w_kund, w_binr, w_fkda, w_fbla – working copies of input keys.  
  - w_antf (count), w_anta (requested count), w_tell (output counter), w_sign (sign flag), w_leng (name length), w_dato_alf (formatted date).  
- **Flags**:  
  - b_sall (select all), b_back (reverse order), b_reck (start reading).  
- **Helpers**:  
  - s_binr (last invoice# seen).  
- **Constants**:  
  - `lo`/`up` for lowercase/uppercase translation (Norwegian letters included).  

---

## Main Processing Loop  

1. **Read Input Data Queue**  
   - `QRCVDTAQ` is called in a loop until an all-blank input buffer ends processing.  

2. **Process Each Request**  
   - If input not blank, jump to `behandling` subroutine.  

3. **Exit**  
   - On end-of-input, set LR and return.  

---

## Subroutine: behandling  
1. **Unpack input fields** into work variables.  
2. **Normalize year/date**:  
   - Convert d_aarr or d_fkda to internal formats if needed.  
3. **Determine selection mode**:  
   - **b_sall**: if invoice range and date/name are blank → select all for customer.  
   - **b_back**: if requested quantity negative → reverse order.  
4. **Compute w_anta** (abs quantity), w_leng (name search length), upper-case name.  
5. **Count matching invoices** → call `antall_fakt`.  
6. **Send count record** via `QSNDDTAQ`.  
7. **Fetch and send invoice headers** → call `faktura`.  

---

## Subroutine: antall_fakt  
Counts matching invoices without sum=0 and removes duplicates by invoice#:  
1. Initialize counters and last‐seen invoice#.  
2. If **select all**:  
   - Position on first invoice of year/customer (`sohel1_key2`), `READE` through them.  
3. Else if **specific invoice#**:  
   - `CHAIN` on sohelr.  
4. Else if **invoice date**:  
   - `SETLL`/`READE` on sohel5 by date.  
5. Else if **name search**:  
   - `SETLL`/`READ` on sohel6 by name key.  
6. For each record:  
   - Check customer match, sum≠0, invoice# different → increment w_antf.  
7. Output w_antf in d_antf and send via `QSNDDTAQ`.  

---

## Subroutine: faktura  
Fetches up to w_anta invoice headers and sends them:  
1. **Compute start keys** based on input range, select‐all and reverse flags:  
   - Set sohel?r_key lists accordingly (chain or setgt/gt).  
2. **Determine b_reck**: Start reading immediately or wait for the requested range boundary.  
3. **Invoke `read_sohepf`** to position cursor.  
4. **Loop** while not %EOF and output count < w_anta:  
   - Filter on year, customer, sum≠0.  
   - If in range (b_reck logic and input fbl):  
     - If name search, match substring.  
     - Build output DS (d_obin, d_ofkd, d_onav, d_fsum).  
     - Increment w_tell and send via `QSNDDTAQ`.  
   - Call `read_sohepf` to get next record.  

---

## Subroutine: read_sohepf  
Abstracts record retrieval:  
- If **reverse** (b_back): uses `READE` on the chosen key.  
- Else uses `READPE` (or `READP`) to read forward preserving position.  

---

## Error & Initialization Routines  
- **\*PSSr**: Sets `p_feil = *on` and exits on error.  
- **\*inzsr**: Entry point on program start:  
  - Defines parameter list and key lists for file operations.  
  - Loads `w_firm` from p_firm.  
  - Gets current date/time into w_dato.  

---

# Key Takeaways  
- The program leverages multiple keyed access paths (invoice#, date, name) on the same file.  
- It handles selection ranges, quantity limits, and both forward/backward ordering.  
- Communication with the caller is via data queue APIs (`QRCVDTAQ`/`QSNDDTAQ`), sending first a count record, then detail records.  
- Subroutines modularize counting, fetching, and record traversal logic.