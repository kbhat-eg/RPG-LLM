# Documentation: Program LB700R – User Access Control

## Overview

**Program Name:** LB700R  
**System:** ASLAGR  
**Purpose:**  
This program is a generic utility for checking if a user has access to a specific function within the system. It looks up the user's access rights in the `lusrL1` (user register) file and returns whether the user has the requested access.

**Typical Use Case:**  
Other programs call LB700R with a function code (1–20) to check, and LB700R returns (via parameter) whether the user has access (`0` = No, `1` = Yes).

---

## File and Data Area Usage

### Files

- **lusrl1**  
  - Physical file containing user access rights.
  - Renamed record format to `lusrl1r` in this program.
  - Accessed with a composite key: company (firm) + user.

### Data Areas

- **Local Data Area (LDA)**  
  - Used to retrieve session-specific information:
    - `l_wsid` (workstation id): positions 901–910
    - `l_user` (user id): positions 911–920
    - `l_firm` (firm/company number): positions 944–946

---

## Parameters

- **Input:**
  - `p_kode` (2,0): The access code to check (values 1–20).
- **Output:**
  - `p_onof` (like lbko01): The result. Set to `1` if access is granted, `0` otherwise.

---

## Main Logic

1. **Initialization:**
   - The program starts with defaulting `p_onof` to `0` (no access).
   - The `*inzsr` subroutine is called on program initialization.
     - Sets up the file key (`w_firm` and `lusrl1_user`) using values from the LDA.
     - Receives parameters from the caller.

2. **User Lookup:**
   - Performs a `CHAIN` operation on the `lusrl1` file using the firm and user as the key.
   - If the user is found, the program evaluates which access code to check based on `p_kode`.

3. **Access Check:**
   - There is a series of `IF` statements, each corresponding to access codes 1–15.
     - For `p_kode = 01`, it sets `p_onof` to the value of `lbko01` (field in lusrl1).
     - For `p_kode = 02`, it sets `p_onof` to `lbko02`, and so on up to `lbko15`.
   - If the user record is not found, or `p_kode` is outside the range 1–15, `p_onof` remains `0`.

4. **Return:**
   - The program sets the LR indicator (`*INLR = *ON`) and returns to the caller.

---

## Domain/Business Logic Notes

- **User Register (`lusrL1`):**
  - Contains one record per user per company.
  - Each access code (01–15) is represented by a separate field (`lbko01` ... `lbko15`).
  - The fields are expected to be binary flags (0/1), representing access denied/granted.

- **Access Codes:**
  - The program currently supports access codes 1–15 (despite the comment mentioning 1–20).
  - If additional codes are needed, the code must be extended to handle `lbko16` ... `lbko20`.

- **Session Context:**
  - The user and firm are dynamically determined from the LDA, ensuring the check is for the current session.

---

## Conventions and Design Decisions

- **Parameter Passing:**
  - Uses classic RPG parameter list (`PLIST`) for communication with the caller.
  - Output is returned via reference parameter.

- **Key Construction:**
  - The key for the user lookup is constructed in the initialization subroutine, ensuring consistency.

- **No Debug I/O:**
  - `H OPTION(*NODEBUGIO)` is specified to prevent debug I/O, likely for performance or security.

- **Hardcoded Access Mapping:**
  - The mapping of `p_kode` to field (`lbko01` ... `lbko15`) is explicit via `IF` statements.
  - This is straightforward but not scalable; if more codes are added, code changes are required.

- **File Renaming:**
  - The record format is renamed to avoid conflicts or for clarity.

---

## Interactions with Other Modules

- **Caller Responsibility:**
  - The calling program must supply:
    - The access code to check.
    - A variable to receive the result.
  - The calling context is responsible for ensuring the LDA is populated with the correct user and firm.

- **No External APIs:**
  - The program operates entirely on the local database and LDA.

---

## Potential Enhancements

- **Support for More Codes:**
  - To handle up to 20 codes as indicated in the comments, extend the IF logic.

- **Refactoring:**
  - Consider using an array or data structure for access flags to simplify code and improve scalability.

- **Error Handling:**
  - Currently, if the user is not found, access is denied by default. If more granular error reporting is needed, this should be expanded.

---

## Summary Table

| Component         | Description                                                               |
|-------------------|---------------------------------------------------------------------------|
| Input             | Access code (1–15), via parameter                                         |
| Output            | Access flag (0/1), via parameter                                          |
| Key Data Sources  | LDA (user, firm), lusrl1 file                                             |
| Main Logic        | Lookup user, check access code, return result                             |
| Extensibility     | Limited (hardcoded mapping for 15 codes)                                  |
| Domain Assumptions| One record per user per company; access rights as one field per function  |

---

## Key Takeaways for New Developers

- This is a utility program for access control, not a business transaction program.
- It relies on conventions: LDA usage for session context, explicit mapping of codes.
- Any changes to the access rights structure (e.g., more codes) require code changes.
- The program is designed for performance and simplicity, suitable for being called frequently from other programs.