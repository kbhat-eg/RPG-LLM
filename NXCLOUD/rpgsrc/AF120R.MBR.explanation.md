# RPG Program Explanation: AF120R – Maintenance of File Groups per Server

This ILE RPG (Report Program Generator) program, named **AF120R**, is designed for the maintenance (creation, update, deletion, and inquiry) of file groups assigned to servers in an IBM i environment. It is a "green screen" interactive program utilizing subfiles, function keys, and several data structures for efficient user interaction and data maintenance.

Below you will find a structured explanation, covering overall design, file definitions, variables, indicators, subroutines, and the control flow of the main logic.

---

## 1. **Program Heading and Documentation**

The header provides:
- **Options:** No debug I/O, date format DMY
- **Descriptions:** Historical changes, who made them, and when
- **Indicator Usage:** Comments mapping RPG indicators (e.g. LR, 10, 11, 12, etc.) to their meaning in the program, especially for screen handling and control.

---

## 2. **File Declarations**

### Physical and Logical Files

```rpg
fafgri1    if   e           k disk    rename(afgrst:afgri1r)
fafgrir    if   e           k disk    rename(afgrst:afgrlrr)
fafgriu    uf a e           k disk    rename(afgrst:afgriur)
```
- These are database files used for reading (I: input), updating (U: update), and possibly writing. They are renamed in the program to specific record formats for clarity.

### Display Files

```rpg
faf120d    cf   e             workstn sfile(b1sfl:w_srrn)
f                                     infds(dspfbk)
```
- The display file is interactive (workstn), using subfiles for batch display (SFILE) and a feedback data structure (INFDS) for screen details.

---

## 3. **Data Structure and Field Definitions**

### Local Data Area

```rpg
d                uds
d l_user                911    920
d l_fnav                951    980
```
- Holds user id and function navigation, from a user data structure (LDA).

### Information Data Structure

```rpg
d dspfbk          ds
d  d_fcrn               378    379I 0
```
- Captures feedback from the workstation; e.g., the first record number on the page.

### Keyfields and Working Variables

Many fields are **LIKE** database fields (type and length identical), ensuring integrity.
- Examples: `afgri1_gsrv`, `afgri1_gfgr`, `afgrir_gsrv`, etc., used as keys or working copies.

#### Subfile Variables

```rpg
d w_fcrn          s              4  0
...
d w_srrn          s              4  0
...
```
- Used for paging/subfile logic: tracking current, first, and last record numbers, subfile sizes, etc.

### Flags and Functional Variables

- `b_oppr`, `b_forn`, `b_anul`, etc. are 1-character flags for controlling logic flows (e.g., create/update/cancel states).

---

## 4. **Display/Screens and Subfile Processing**

**Screens Used:**
- **B1SFL:** Subfile records
- **B2CTL:** Subfile control (header/footer)
- **B2CMD, C1BLD, C2BLD, D1WIN, K1WIN, etc.:** Various pop-ups or mode-specific screens

**Subfile Usage:**  
Subfiles enable batch display and manipulation of records. Users can page, select, and invoke maintenance modes efficiently.

---

## 5. **Main Logic and Flow**

### Main Control Loop

- The main control logic is organized using labels (tags) and `goto` statements, resembling state-driven design.
- The flow starts with displaying a command screen, then processing user actions (function keys, positionings, etc.).

**Example:**
```rpg
c     b2taga        tag
c                   write     b2cmd    // Show CMD keys
c     b2tagb        tag
c                   exsr      dsp_subfile
...
c                   select
c                   when      *inkc or *inkl
c                   goto      avslutt
c                   when      *inke
c                   exsr      forny
c                   goto      b2tagb
...
```
- **Function key handling:** Each key triggers a subroutine or state change.
    - e.g. F12 (INKC) or Cancel will terminate the program.
    - F5 (INKE) will refresh ("forny").

### Positioning

- If position fields are filled, the program searches and positions to a specific group or server using subroutine `søk`.

### Subfile Handling

- The `subfile` subroutine loops through records in the subfile, acting on user input per row (edit, copy, delete, view).
- Each operation invokes relevant subroutines, like `xc2bld` for edit/view, `xk1win` for copy, etc.

---

## 6. **Subroutines**

### forny (Refresh Subfile)
- Repositions to the current record if needed, sets key variables, clears and creates the subfile content anew from disk.

### søk (Search/Positioning)
- Determines if search is by group or server and fills subfile from that point.

### subfile
- Loops through subfile rows to process row-select actions.

### xc1bld (Handle New Record)
- Processes the create/new record screen (C1BLD), checks for duplicates, and, if all good, calls the maintenance screen.

### xc1msg (Duplicate Row Message)
- If a row exists already, pops up a message and allows the user to abort or proceed.

### xc2bld (Edit/View Maintenance)
- Handles the main maintenance pop-up (C2BLD). If the record exists, loads its fields for editing/viewing. Otherwise, presents blanks for a new entry.
- Updates or inserts the record as appropriate.

### xd1win (Handle Delete)
- Pop-up to confirm and execute the deletion of a record.

### xk1win (Handle Copy)
- Handles the copy operation: fills the copy window, ensures the new target key does not already exist, and invokes the maintenance program for the new row.

### clr_subfile, crt_subfile
- Clears subfile and repopulates it, using dynamic SQL to query data by group or by server, paginating as needed.
- `crt_subfile` prepares and declares SQL statement, executes query, and writes results into the subfile buffer for display.

### dsp_subfile
- Handles display logic for the subfile, managing necessary indicators, and saving state for later navigation.

### spørring (Inquiry)
- Placeholder for handling inquiries; empty in this program.

### *inzsr (Initialization SR)
- Set up for keys, indicator defaults, initial subfile load, etc.

---

## 7. **Indicator (INxx) Usage**

RPG indicators (IN01-IN99) are used as Boolean flags to control screen display, field protection, error markers, paging, etc.
- E.g. *IN14 (Subfile clear), *IN15 (Subfile end), *IN30 (Protect fields when viewing), *IN31-79 (Warnings/errors), *IN80-99 (working flags)

---

## 8. **SQL Integration**

- Uses embedded SQL for dynamic queries, enhancing flexibility:
    - Dynamically builds the query depending on user position (group or server)
    - Prepares, declares, and fetches results into program variables.

---

## 9. **Summary of Maintenance Operations**

- **Create New (Opprett):** User enters server+group, program checks if it exists, warns if so, else permits entry of new data.
- **Edit (Endre):** User selects a row to edit, program loads current data, allows changes, then updates the record.
- **Delete (Slett):** User confirms deletion, after which the record is removed.
- **Copy (Kopier):** User can copy an existing row to a new key, as long as that key does not exist.
- **View (Vis):** User can view a row's details in a protected mode with fields disabled.

---

## 10. **Typical User Flow**

1. User enters main screen with subfile lists of file groups per server.
2. User can page, position, refresh, create new, edit, delete, copy, or view by using function keys or selecting rows.
3. The program dynamically loads and maintains data based on these actions, providing appropriate feedback, protecting fields, and handling errors.

---

## 11. **User Interface Design**

- Relies on classic IBM i subfile screens for table-like batch entry, with pop-up windows for special actions.
- Indicators manage onscreen feedback (e.g., errors, confirmation messages).
- All navigation is managed through the main loop and subroutine calls, with judicious use of GOTO and TAGs, as is common in legacy RPG.

---

## 12. **Key Takeaways for Onboarding**

- **Subfile logic** is the program's backbone: mastering how records are presented, selected, and acted upon is critical.
- **Indicator management** is central: understand how each is set/reset and what it controls.
- **Screen-to-database mapping:** Operations generally involve reading or writing to specific database files/formats, with clear variable naming.
- **SQL usage:** Dynamic query logic handles positioning and filtering efficiently.
- **Control flow** relies on subroutines, TAG labels, and GOTOs - not modern structured blocks.
- **Comments and history:** Are extensive and valuable for context.

---

**In summary:**  
The program is a typical IBM i subfile-based maintenance utility, with enhancements for filtering, paging, and dynamic record management. Maintenance actions are invoked per-row, with strong user feedback. The code is dense and procedural, but well-structured for its era and platform.

---

**Tips for new developers:**
- Familiarize yourself with IBM i subfile and indicator patterns.
- Use the comments and indicator maps.
- Trace the subfile creation (`clr_subfile`, `crt_subfile`) and action-handling subroutines.
- Most routines are invoked from the main select structure—start there to follow the logic.