# VV490R â€“ Product Deletion Eligibility Check

## Overview

This program (`VV490R`) determines whether a product (referred to as "vare") can be safely deleted from the system. It enforces business rules by checking for the existence of the product in various tables (orders, warehouse, store status, and purchase orders) to ensure referential integrity and prevent deletion of products that are still referenced elsewhere.

The program is primarily invoked as a subroutine or service program, receiving parameters and setting output flags to indicate if the product is referenced in critical business contexts.

---

## Business Context

- **Product Deletion**: Products must not be deleted if referenced in active orders, inventory, store status, or purchase orders.
- **Tables Checked**:
  - Sales order lines and headers
  - Order types (to distinguish between quotes and actual orders)
  - Warehouse/inventory status
  - Store-specific product status
  - Purchase order lines and headers

---

## Key Design Considerations

- **Centralized Validation**: All deletion rules are enforced in a single program, minimizing the risk of inconsistent business logic across the system.
- **Extensibility**: Comments indicate that if additional tables are included in the checks, related copy jobs and file overrides must also be updated.
- **Parameterization**: Uses a parameter list for input/output, allowing flexible integration with other modules.
- **Non-standard LR Handling**: The `p_inlr` parameter controls whether the program sets `*INLR`, allowing the caller to manage object closure if desired.

---

## File Relationships

The program interacts with several files, each representing a business entity. Note the use of `RENAME` to map physical file names to logical record formats (for clarity and versioning):

- `fodtlv` (Order Line)
- `fohel1` (Order Header)
- `fstsl1` (Warehouse/Inventory Status)
- `votyl1` (Order Type)
- `bstsl1` (Store Status)
- `lodtlv` (Purchase Order Line)
- `lohel1` (Purchase Order Header)

---

## Parameters

- `p_firm`: Company identifier (used as part of all file keys)
- `p_vare`: Product identifier
- `p_inlr`: Input flag; if set, program will not set `*INLR` (allows for batch processing)
- `p_ordr`: Output flag; set to `*ON` if product is found in any order/store/purchase context
- `p_lagr`: Output flag; set to `*ON` if product has inventory in warehouse

---

## Main Processing Logic

### 1. Initialization

- Input parameters are loaded into local working variables.
- Output flags (`p_ordr`, `p_lagr`) are initialized to `*OFF`.

### 2. Order Reference Check

- Reads all order lines (`fodtlv`) for the product.
- For each line:
  - Fetches the order header (`fohel1`) and order type (`votyl1`).
  - If the order type's processing code (`vaoakk`) is not zero (i.e., not a quote), sets `p_ordr = *ON` and exits loop.
- **Business Rule**: Products in actual orders (not quotes) block deletion.

### 3. Warehouse/Inventory Check

- Looks up warehouse status (`fstsl1`) for the product.
- If found and inventory flag (`faalag`) is set, calls program `LL765R` to check for inventory.
  - If inventory exists, sets `p_lagr = *ON`.
- **Note**: Delegates inventory check to another program for modularity.

### 4. Special Store/Product Checks

- If the product matches a specific field in warehouse status (`faavnr`), sets `p_ordr = *ON`.
- Checks if the product is referenced in any of the store status fields (`baavar`, `baagva`, `baadva`) in `bstsl1`.
  - If found, sets `p_ordr = *ON`.

### 5. Purchase Order Check

- Reads all purchase order lines (`lodtlv`) for the product.
- For each, fetches the purchase order header (`lohel1`).
  - If found, sets `p_ordr = *ON`.

### 6. Program Termination

- If `p_inlr` is not set, sets `*INLR = *ON` to close the program.
- Returns to caller.

---

## Subroutine: Initialization (`*INZSR`)

- Defines the entry parameter list.
- Builds key lists for all file accesses.
- Ensures all keys are consistently constructed from the company and product IDs.

---

## Notable Conventions and Patterns

- **Key Lists (`KLIST`)**: Used extensively for keyed file access, supporting maintainability and clarity.
- **Conditional *INLR Handling**: Allows the caller to control program closure, supporting batch processing scenarios.
- **Extensive Comments**: Business rules and change history are documented inline for traceability.
- **Separation of Concerns**: Delegates inventory checks to a dedicated program (`LL765R`).

---

## Interactions with Other Modules

- **LL765R**: Called to determine if the product has warehouse inventory. The interface expects firm, product, and output flags.
- **Database Files**: All business checks are performed via direct file access; no APIs or service programs are used for business logic encapsulation.

---

## Change History Highlights

- Added checks for order type, store-specific product numbers, and purchase order lines as the business requirements evolved.
- Extended key fields for number expansion and price group changes.

---

## Summary Table: Output Flags

| Output Flag | Meaning When Set | Triggering Condition(s)                           |
|-------------|------------------|---------------------------------------------------|
| `p_ordr`    | Product is referenced in orders, store, or purchase orders | Found in sales order (not quote), store status, or purchase order |
| `p_lagr`    | Product has inventory in warehouse      | Inventory check via `LL765R` returns positive      |

---

## Usage Notes

- **To Add More Checks**: Update both this program and any related copy/override jobs.
- **On Integration**: Always check output flags after call; do not delete product if either is set.
- **On Batch Runs**: Use `p_inlr` to manage program closure when called in a loop.

---

## Conclusion

This program is a critical safeguard for product master data integrity, centralizing all deletion precondition checks. Its structure and conventions support maintainability, extensibility, and robust business rule enforcement.