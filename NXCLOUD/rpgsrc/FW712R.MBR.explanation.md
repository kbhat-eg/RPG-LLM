# Explanation of RPG Program FW712R: Vendor Item Registry Creation

This RPG (ILE RPG IV / RPGLE) program, part of the "ASOFAK" system, is designed to read item data from an input file and write structured records to a vendor item registry, specifically for Ole Moe Engros. Below is a structured walkthrough and explanation of the main sections:

---

## 1. File Declarations

```rpg
fflvwpf    if   e           k disk
ffenkl1    if   e           k disk    rename(fenkpfr:fenkl1r)
fflvapf    o  a e             disk
```

- **flvwpf**: Input file, keyed, for reading item data.
- **fenkl1**: Input file, keyed, likely for unit (enhet) conversion, with a record format rename.
- **flvapf**: Output file, for writing to the vendor item register.

---

## 2. Local Data Area

```rpg
d                uds
d l_user                911    920
```
- UDS: User Data Section, used for storing environmental/operational variables like user ID.
- `l_user`: Variable to hold user information from the local data area (positions 911–920).

---

## 3. Data Structure Definitions

The main data buffer `d_inpu` (173 chars) is usefully overlaid with several subfields (using `overlay`), so that specific item attributes can be manipulated individually.

```rpg
d                 ds
d d_inpu                       173
d  d_vare                       13    overlay(d_inpu:1)    // Item number
d  d_vgrp                        4    overlay(d_inpu:14)   // Item group
d  d_tek1                       30    overlay(d_inpu:19)   // Item text 1
d  d_enhe                        3    overlay(d_inpu:50)   // Unit
d  d_tek2                       30    overlay(d_inpu:54)   // Item text 2
d  d_anta                        5    overlay(d_inpu:85)   // Pack quantity
d  d_sapr                       10    overlay(d_inpu:91)   // Sales price
d   d_sapr_kr                    7  0 overlay(d_sapr:1)    // Sales price kroner
d   d_sapr_øre                   2  2 overlay(d_sapr:9)    // Sales price øre
d  d_inpr                       10    overlay(d_inpu:102)  // Purchase price
d   d_inpr_kr                    7  0 overlay(d_inpr:1)    // Purchase price kroner
d   d_inpr_øre                   2  2 overlay(d_inpr:9)    // Purchase price øre
d  d_grpr                       10    overlay(d_inpu:113)  // Base price 1
d  d_eann                       13  0 overlay(d_inpu:124)  // EAN number
d  d_grp2                       10    overlay(d_inpu:137)  // Base price 2
d  d_rgrp                        5  0 overlay(d_inpu:143)  // Discount group
d  d_gtxt                       20    overlay(d_inpu:154)  // Group text
```
This allows direct access to each attribute of an input record.

---

## 4. Parameter and Working Variables

- **Parameters (from *ENTRY):**
    - `p_firm` (company code)
    - `p_ldor` (probably run date/order date)
- **Working variables:** Item text, temporary storage for unit key, string manipulations, and constants.

---

## 5. Main Program Logic

### Program Flow

1. **Initialization**
    - Parameters are collected via the `*inzsr` subroutine.
    - `w_firm` is assigned from `p_firm`.

2. **Processing Loop**
    - Each input record is read from `flvwpf`.
    - Data is mapped from the raw buffer to the structured fields using overlays.
    - Output fields for the vendor register are populated, including trimming and formatting text, calculating prices, and handling unit codes.
    - Field concatenation and unit conversion are performed via subroutines.
    - Timestamps and user information are set.

3. **Writing Output**
    - After all field transformations, a record is written to `flvapf`.
    - The next input record is read; loop continues until EOF.

4. **Program Termination**
    - Sets LR (Last Record) indicator to `*ON` and returns.

---

## 6. Notable Processing Details

### a. Text Concatenation

The subroutine `konkatiner` concatenates item text fields (`fwtek1` and `fwtek2`). It trims spaces and ensures concatenated text fits within the field size limits, then splits the concatenated result back into the two fields for output.

### b. Unit Conversion

For the unit code (`d_enhe`), the program looks up a conversion in `fenkl1` file. If a record is found, it uses the converted unit code.

### c. Default and Calculated Fields

- Some output fields are hardcoded (e.g., `fwhkod = 1`), or set to zero/blank.
- Prices are split into kroner and øre, and then combined for storage.
- Timestamps and user IDs are set for both creation (`fwodat`, `fwotim`, `fwousr`) and editing (`fwedat`, `fwetim`, `fweusr`).

### d. Order/Packing Quantity

- The program validates that `d_anta` (pack quantity) is numeric before using it.
- It pads/trims the value as needed and stores to the correct output field.

---

## 7. Subroutines

### a. `konkatiner`
- Concatenates and trims `fwtek1` and `fwtek2` to create a combined item description, then splits the result back to two output fields, respecting field length limits.

### b. `*inzsr`
- Initialization subroutine for handling parameters and key lists.

---

## 8. Constants

- `digits`: String of digits for validation of pack quantity.

---

## 9. Error Handling

- Uses RPG indicators (`*in90`, `*in91`, `*in92`) for EOF and error checking (e.g., file read status, numeric checks, scan results).

---

## 10. Comments and Documentation

- The code includes Norwegian comments/documentation.
- Change log in the header gives a history of updates.

---

## Summary

**FW712R** processes records from an input file, transforms and enriches item data (including text handling, unit conversion, and price calculations), and writes the results to a vendor item registry file. It makes heavy use of data structures, overlays, subroutines, and field validations to ensure high data integrity and compatibility with the vendor's registry requirements.

---

**If you are onboarding to work on or maintain this program:**

- Get familiar with the file layouts for `flvwpf`, `fenkl1`, and `flvapf`.
- Understand RPG IV data structures and overlays.
- Pay attention to subroutine logic, especially for text manipulation and unit conversion.
- Review indicator-driven error handling if making enhancements.
- Use the parameter and variable naming conventions as examples for consistency.