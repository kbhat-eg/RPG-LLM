# RPG Program RF771R Onboarding Explanation

## Program Purpose
This RPG III/400 program determines which accounting system will receive a transaction, based on a lookup to a file. Each "system" is represented by a code (0 - Nexstep, 1 - Visma-detailed, 2 - Visma-summed, 3 - Zirus).

---

## High-Level Structure

- **File Declaration**: The program works with a file (`fstsl1`) renamed from `fstspfr`.
- **Input Parameters**: Accepts a firm code, returns system code (`p_syst`).
- **Logic**: Looks up firm in the file; if found, retrieves system code from a field; if not found, sets a default system code.
- **Program Flow**: Uses a standard mainline and initialization subroutine (`*INZSR`).

---

## Detailed Walkthrough

### 1. File Definition

```rpgle
ffstsl1    if   e           k disk    rename(fstspfr:fstsl1r)
```
- Declares a keyed, externally-described disk file.
- `rename(fstspfr:fstsl1r)` means the external format `fstspfr` is referenced as `fstsl1r` in this program.

---

### 2. Working Storage

```rpgle
d w_firm          s                   like(faafir)
d p_syst          s              1
d                uds
d l_firm                944    946  0
```
- `w_firm`: Work variable, same type as field `faafir` (presumably firm id).
- `p_syst`: One character, system code to return.
- `l_firm`: A 3-digit field, presumably the incoming firm code.

---

### 3. Mainline Logic

#### File Lookup

```rpgle
c     fstsl1_key    chain     fstsl1
c                   if        not %found(fstsl1)
c                   eval      p_syst = '0'
c                   else
c                   move      faak03        p_syst
c                   endif
```
- Uses key (`fstsl1_key`) to chain (read by key) into `fstsl1`.
- If not found, returns `'0'` (Nexstep) as default.
- If found, moves field `faak03` (likely the system code from file) into output parameter `p_syst`.

---

#### Program End

```rpgle
c     avslutt       tag
c                   eval      *inlr = *on
c                   return
```
- Standard program end: sets *INLR (last record indicator) to *ON to close files and end job.

---

### 4. Initialization Subroutine (`*INZSR`)

```rpgle
c     *inzsr        begsr
c     *entry        plist
c                   parm                    p_syst
c                   eval      w_firm     = l_firm
c     fstsl1_key    klist
c                   kfld                    w_firm
c                   endsr
```
- Subroutine runs once at program start.
- Defines parameter list with output variable `p_syst`.
- Loads input firm code (`l_firm`) into work variable (`w_firm`).
- Prepares keyed list (`klist`) for chaining into the file.
- Sets up keyfield (`w_firm`) for lookups.

---

## Special Notes

- **Parameter Passing**: The program uses a parameter list, with the main output being a 1-character system code.
- **File Access**: Only one file accessed, via a keyed read.
- **Error Handling**: If the firm is not found, defaults to system code `'0'`.
- **Customization Documented**: The code header documents the mapping of codes to systems, aiding maintainability.
- **Legacy Syntax**: Uses fixed-format RPG and the cycle; modern RPG would use /FREE.

---

## Summary Table

| Variable  | Purpose                                              |
|-----------|------------------------------------------------------|
| `l_firm`  | Input: Firm identifier (3 character/digit)           |
| `p_syst`  | Output: System code ('0', '1', '2', '3')             |
| `w_firm`  | Work variable, for file lookup                       |
| `faak03`  | System code field in the file                        |

---

## Process Workflow

1. **Initialize** (copy input to work variables, set up key fields)
2. **Chain (lookup)** the firm in `fstsl1`.
3. **If found**: Return the system code from the file (`faak03`).
4. **If not found**: Return default system code `'0'`.
5. **End** program and return control.

---

## Summary

This is a simple RPG program that, given a firm code, determines the appropriate accounting system by looking up a code in a file. It is designed for extensibility and easy code mapping, making it straightforward to onboard new maintainers.