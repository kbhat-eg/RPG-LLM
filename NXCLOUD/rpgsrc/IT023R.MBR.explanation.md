# IBM ILE RPG Program: IT023R  
## Purpose  
This RPG program manages vouchers code conversion and rounding (as described in the comments: "Konvertering av bilagskoder Ã¥reavrunding"). It is an interactive application, using display files with subfiles, for maintaining code mappings between voucher codes.

---

## High-Level Summary

- **Data Sources**: Multiple physical files (`ikoni1`, `ikonir`, `ikoniu`, `ra01lr`) for code mapping.
- **Display File**: `IT023D` - includes multiple screens and a subfile for listing/conversion management.
- **Keys/Indicators**: Heavy use of IBM i indicators for function key handling and screen management.
- **Major Operations**: List, add, update, and delete voucher code mappings.

---

## File Declarations (F-specs)
- **Physical Files**:
  - `ikoni1`, `ikonir`, `ikoniu`: Mappings (different access paths/usage: inquiry, update, etc.)
  - `ra01lr`: Voucher code register (source of description text).
- **Display File**:
  - `it023d`: Workstation file for user interface, includes subfiles and multiple record formats.
  - `dspfbk`: Data structure for feedback from display file.

---

## Data Structure Declarations (D-specs)

- **Local Data Area (LDA) Fields**: User, firm number, user name.
- **Feedback Data Structure**: For getting current subfile record number.
- **Key Fields**: Used for chaining/positioning in the files.
- **Working Variables**:
  - Screen/subfile mechanics (`w_*` variables).
  - Boolean flags for update/state machine logic.
  - Variables to hold keys, texts, and working data for entries.
- **Constants**:
  - `c_sfil`: Subfile page size (14 records per page).

---

## Indicator Usage

- Detailed mapping of indicators to functions (e.g. `*in10` = Rollup, `*in14` = Sflclr, etc.).
- Indicators are critical in classic RPG for UI, control flow, edit modes, etc.

---

## Program Flow

### Initialization (`*inzsr`)

- Sets up key lists for file access and positions database to the start.
- Reads firm number from LDA.
- Fills initial subfile records.

---

### Main Loop

The program uses a label/tag and `goto` structure (classic RPG style) to navigate between user interactions:

- **b2taga**: Shows command display (`b2cmd`).
- **b2tagb**: Handles main subfile processing; displays subfile and processes user keys.

#### Function Key Handling (Select/When block):

- F3=Exit (`*inkc`), F12=Cancel (`*inkl`): Exit program.
- F5=Refresh (`*inke`): Calls `forny` subroutine to refresh data.
- F6=New (`*inkf`): Calls `xc1bld` to add a new mapping.
- Page Up (`*in10`): Loads next page, `crt_subfile`.
- Page Down (`*in11`): Loads previous page, `bck_subfile`.
- Home (`*in21`): Sets cursor reposition indicator.

---

### Subroutines and Main Functions

#### Subfile Processing

- **forny**: Refreshes data in the subfile, reposition using current entry, clears, then refills subfile.
- **subfile**: Reads user edits/selections from the subfile; based on the selection (`b1valg`), updates (change), or deletes rows by calling respective subroutines.
- **clr_subfile**: Clears subfile records and resets subfile page handling variables.
- **crt_subfile**: Fills the subfile with records (page-wise).
- **bck_subfile**: Loads the previous page by "read prior" logic.

#### CRUD Operations

- **xc1bld**: Handles 'add new row' screens (`C1BLD`), validates input, ensures no duplicates, then prompts for details and saves.
- **xc1msg/xc3msg**: Display information or error messages to the user.
- **xc2bld**: Handles edit/view screen (`C2BLD`), loads relevant data for the selected mapping, and performs update or insert as required.
- **xd1win**: Handles deletion confirmation screen (`D1WIN`) and performs delete if confirmed.

#### Support Routines

- **dsp_subfile**: Controls display of the subfile listing.
- **sok_bil**: Calls external program (`RA501R`) to search for a voucher code.

---

## Subfile and Screen Management

- Subfiles are used to present the mapping list to the user (paged).
- The program keeps track of the current record, page boundaries, and handles scrolling.
- Indicators are used to control screen states (clear, display, enable/disable fields).

---

## Key RPG Techniques Demonstrated

- **File I/O**: Use of `chain`, `read`, `readc`, `readp` for keyed access and subfile processing.
- **Display File Management**: Advanced subfile handling (`workstn`, multiple record formats, page control).
- **State Indicators**: Classic use of numbered indicators to manage UI and process control.
- **Subroutines**: Modular approach for maintainability (e.g., for CRUD, messaging, subfile ops).
- **Goto/Tags**: "Old school" RPG logic control style, rather than structured blocks.
- **Validation and Error Handling**: Screens for info and error feedback before allowing data changes.
- **Data Area Integration**: Pulls user/session data from LDA.
- **External Program Call**: For voucher code search (`sok_bil`).

---

## Typical User Flow

1. Program starts, subfile fills with current mappings.
2. User can scroll through, add (`F6`), change, or delete mappings.
3. Adding or changing brings up relevant screens; all changes are validated against the master code file.
4. All operations provide user feedback with proper messaging screens.
5. F3 or F12 exits the application.

---

## Business Rules/Logic

- Users can only add mappings where both codes exist in the code register.
- Cannot create duplicate mapping for the same "from" code.
- Provides ability to scroll and page through mappings.
- Detailed feedback and messaging to ensure correct data entry.

---

## Internationalization/Localization

- Comments and field names are in Norwegian (e.g., "bilagskode", "beskrivelse"), suggesting the program is tailored for Norwegian users.

---

## Summary

This is a robust, classic-style RPG program for interactive maintenance of voucher code mappings. It illustrates:
- Efficient use of subfiles for data presentation and user interaction,
- Good validation routines,
- Heavy reliance on legacy RPG idioms (indicators, GOTO, subfile paging),
- Modular structure with subroutines for main operations,
- Integration with data area and external programs for additional reference data.

It is a good example for onboarding RPG developers to maintenance and user interface programming on IBM i.