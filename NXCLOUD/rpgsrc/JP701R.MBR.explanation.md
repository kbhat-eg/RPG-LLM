# Program Overview

This RPG program (JP701R) is designed for the IBM i (AS/400, iSeries) platform. Its main purpose is to update and maintain "betingelser" (conditions/agreements) and "rabattelement" (rebate elements) by reading input files (PC files) from a Nobb Contract. The program is used in a wholesale/distribution context, dealing with supplier conditions, product groups, discounts, and similar commercial structures.

## High-Level Flow

1. **Initialize** — Set shared change date/time, fetch company from LDA, initialize keys.
2. **Process Conditions** — Read and process all conditions records from input file `pcbetpf`.
3. **Delete Old Conditions** — For each new supplier found, delete all non-proprietary, now-stale agreements and rebate records left from the previous supplier.
4. **Process Rebate Elements** — Read and process rebate records from input file `pcraepf`.
5. **End** — Set LR (last record) and exit.

# File Definitions

- **pcbetpf:** Input file with supplier conditions.
- **pcraepf:** Input file with rebate elements.
- **jvarl3, ra30l1, jbetl1, jbetla, jbetlu, jbewl1, jbewla:** Internal and backup files, typically holding permanent condition/rebate data.
- **jwrkpfr:** Work/output file for reporting changes.
- **LDA (Local Data Area):** Used to fetch user/company information.

# Data Structures

- **d_bet/d_rae:** Structures for input data from the PC files.
- **Many overlay fields** to extract and manage different segments of the input records.

# Variables

- **w_***: Working storage for field values. Often used for keys or buffer copies.
- **b_frst, b_head, b_endr, ...:** Boolean flags for procedural logic.
- **jbetlu_*, jbetl1_*, jrawl1_* etc.:** Key fields for chaining into various internal files.

# Main Program Logic

## Initialization

- Set current date/time for transaction stamps.
- Fetch the company number from LDA.

## Reading and Processing Conditions

- For each record in `pcbetpf`:
  - Call subroutine `OPPDAT_BET` to update or insert the condition.
  - If processing a new supplier, call `SLETT_GAMLE` to delete outdated conditions/rabattelement for the previous supplier.

## Reading and Processing Rebate Elements

- For each record in `pcraepf`:
  - Call `OPPDAT_RAE` to update/insert rebate element.
  - Call `OPPDAT_RAE_PG` to handle rebate elements per price group (if enabled).

# Key Subroutines

## OPPDAT_BET<br>(Update Condition)

- Load and parse a record from the condition input file.
- Ignore blank/invalid records.
- If new supplier, call `SLETT_GAMLE`.
- Populate working storage (group, module, etc.); if at item level, look up groups/modules using product number.
- Convert input text (e.g. betingelsestekst) to ASCII.
- Update or insert the condition in the permanent file; logic ensures only non-redundant conditions are persisted.
- If price group logic applies, loop through all groups (`ra30l1`) and update/inserts accordingly.

## OPPDAT_RAE<br>(Update Rebate Element)

- Load and parse a rebate element record.
- Skip blank/invalid records.
- If new supplier, delete all previous "non-own" rebates for this supplier.
- Populate fields (group, module, product, etc.), possibly looking up data based on product number.
- Convert rebate text to ASCII.
- Validate that a matching condition exists; if not, skip.
- Parse "regel" (rule) and "verdi" (amount/percentage), handling negative/positive logic, removing extraneous symbols.
- Write rebate element with all fields set, including calculated values.

## OPPDAT_RAE_PG<br>(Update Rebate by Price Group)

- Iterates over all price groups (`ra30l1`), and for each group, if a matching condition exists, writes the corresponding rebate element for that price group.

## SLETT_GAMLE<br>(Delete Outdated Conditions/Rebates for Supplier)

- Loops through all previous non-proprietary conditions for a supplier.
- For each, deletes if not updated in this run (compares date/time).
- Deletes associated rebate elements.
- Special logic to avoid deleting “own” (proprietary) elements.

## Other utility subroutines

- **sjekk_endr:** Checks if a rebate element has changed (for reporting).
- **sjekk_prgr / sjekk_prgr_be:** Checks if rebate/condition has had a price group previously.
- **skriv / skriv_head:** Report changed/added elements to the work output file.

# Key Handling and Lookup Logic

- Many subroutines use "key lists" to efficiently access records in DB2 tables/files:
  - **chain**: Random access to a record by key
  - **setll/reade**: Sequential access based on key
  - Keys are often composite, including firm number, supplier, group, module, item, etc.

# Error Handling and Robustness

- Multiple checks for blank or malformed input.
- Many overlays and default handling for legacy or invalid data.
- Extensive comments for maintainability and to document business rules.

# Special Features & Notes

- Handles both standard and price-group-specific logic (versions, enhancements referenced in comments).
- Handles translation of text fields for special Norwegian characters and ASCII compatibility.
- DMY date format, adapts for historical versions and bug fixes.
- Sophisticated rules for matching and updating "betingelser" and "rabattelement" by various dimensions (e.g., group, product, module, price group).
- Maintains a reporting/audit trail of changes for later review.

# Onboarding Advice

- **Familiarity with RPG syntax and DB2 access paths (chain, setll, reade) is critical.**
- Understanding the business rules around "conditions" and "rebate elements" is important—study the overlays and data structures.
- Learn the naming convention for the keys and data structures; they're indexed by field and context.
- When updating or extending, pay special attention to legacy logic (e.g., overlays, version history comments).
- Test with realistic PC input files (`pcbetpf`, `pcraepf`), and step through logic for supplier change and price group cases.

---

## Summary Table

| Section                | Purpose                                                    |
|------------------------|------------------------------------------------------------|
| File Definitions       | Declares input, output, and work files                     |
| Data Structures        | Overlay structures for reading and processing input        |
| Variables              | Working storage, including flags, keys, and field buffers  |
| Initialization         | Sets up system fields, including date/time, company        |
| Main Logic             | Reads/updates conditions and rebate elements sequentially  |
| Subroutines            | Modular business logic for updates, deletions, reporting   |
| Key Handling           | Efficient file access and record locking                   |
| Error Handling         | Robust checks on input and processing logic                |
| Reporting              | Outputs changes and audit trail to work files              |