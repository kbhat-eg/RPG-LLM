# Overview

This program (AA016R) manages printer definitions (“Printerstyring, vedlikehold”) via a subfile-driven display. It interacts with several physical files (awsdl1, awsdl2, awsdlr, awsdlu) that store details of printer setups, routines, and printer usage parameters. The main purpose is to enable users to list existing printer definitions, create new ones, update existing entries, copy definitions, or delete them.

It uses multiple display records (B1SFL, B2CTL, B2CMD, etc.) to show lists of printer entries and forms, capture user input (such as keys for new or existing records), and present confirmation windows (e.g., “D1WIN” for delete confirmation). Through subroutines, the code handles positioning, paging, clearing, and populating the subfile so that users can navigate or edit the data.

Below is a structural breakdown of key parts of the code and the business logic behind them.

---

## Files and Data Structures

- **awsdl1 / awsdl2 / awsdlr / awsdlu**  
  These are the core files that store printer definition data. Each file name is referenced via rename keywords to keep the naming consistent (awsdpfr:awsdl1r, etc.). The program uses different files for different types of lookups:
  - awsdl1: Typically keyed by WSID (workstation/user ID) and references routine (ruti) as blank.  
  - awsdl2: Typically keyed by routine (ruti) and references WSID as blank.  
  - awsdlr / awsdlu: Used for retrieving or updating a printer record (chain/update).  
  This separation allows the program to handle both “WSID-based” and “routine-based” lookups.

- **LDA (Local Data Area)**  
  The program retrieves LDA fields like `l_user` (the user ID) and `l_sbib` (possibly the library or environment parameter). These can be appended to new or updated printer records (e.g., for audit).

- **Subfile Elements**  
  Key subfile fields (w_fcrn, w_stel, w_spge, w_srrn, w_sfrn, w_ssrn) control subfile navigation and positioning. The program tracks the page size (`c_sfil` = 14), the first record on the current page, and whether the user scrolls forward or backward.

---

## Display Records and Their Roles

Several display formats are used:
- **B1SFL**: The subfile record format showing each printer definition row.  
- **B2CTL**: The subfile control record handling user actions (paging, function keys, etc.).  
- **B2CMD**: A supplementary command key screen format.  
- **C1BLD / C1MSG**: Screens for adding a new printer definition (C1BLD) and the associated message window (C1MSG) if a record already exists.  
- **C2BLD**: Screen for create/update/display actions on a single printer entry.  
- **D1WIN**: A confirmation “window” for deleting a printer definition.  
- **K1WIN**: A confirmation/copy “window” for copying one printer definition to another.

---

## Main Flow

The program flow is a typical subfile controller pattern:

1. **Initialization**  
   Done in the *inzsr subroutine. It sets up keys for reading each of the physical files and initializes the subfile by clearing it (clr_subfile) and then populating it (crt_subfile).

2. **Screen Loop**  
   The code repeatedly displays a command record (B2CMD) and the subfile control format (B2CTL). User function keys drive subroutines for:
   - Scrolling forward/backward in the subfile.  
   - Positioning to a specific WSID or routine (e.g., b2wsid, b2ruti).  
   - Adding a new record (xc1bld).  
   - Creating/updating/viewing records (xc2bld).  
   - Copying a record (xk1win).  
   - Deleting a record (xd1win).  

3. **Handling User Actions**  
   Within B2CTL handling, the program tests for IBM i function keys (e.g., *IN10 for roll up, *IN11 for roll down, *INKF for “create new,” etc.) and calls the appropriate subroutine:

   - “forny” subroutine: Rebuilds the subfile after changes.  
   - “posisjoner” subroutine: Moves the virtual cursor or subfile pointer based on user input (b2wsid/b2ruti).  
   - “subfile” subroutine: Iterates through the subfile rows, checking if the user requested an edit, copy, delete, or view on a specific line.  
   - “xc1bld” subroutine: Contains logic for creating a new record (C1BLD screen). If the user tries to create an existing record, “xc1msg” displays a warning window.  
   - “xc2bld” subroutine: Called from multiple user actions to load or update an existing record (C2BLD screen). Also checks for output queue validity by calling an external program (AX020C).  
   - “xd1win” subroutine: Handles the delete window (D1WIN). If the user confirms, it deletes the corresponding record in awsdlu.  
   - “xk1win” subroutine: Copies a record from an existing WSID/ruti to a new WSID/ruti (K1WIN).  
   - “clr_subfile” subroutine: Clears the subfile for a fresh display.  
   - “crt_subfile” subroutine: Reads records from awsdl1 or awsdl2 in sequence, writes them to B1SFL, and tracks how many records are loaded until it hits the subfile page size or EOF.  
   - “bck_subfile” subroutine: Pages backward by re-positioning in the file and then reloading the subfile.  
   - “dsp_subfile” subroutine: Displays the control record (with subfile visible) and sets screen indicators to allow user interaction.

4. **Exiting the Program**  
   The label “avslutt” sets *INLR on, ending the application.

---

## Notable Design Points

1. **Dual File Strategy (awsdl1 vs. awsdl2)**  
   The code uses two main data paths—one keyed by WSID, the other by routine. This makes it flexible to handle different search approaches in the same program without multiple separate routines.

2. **Subfile Paging**  
   A typical subfile pattern is used:  
   - Clear subfile content.  
   - Fill with the next block of records (14 at a time).  
   - Track the current “relative record number” (w_srrn) and total subfile size.  
   - Provide forward and backward scrolling subroutines.

3. **Copying Logic**  
   The copy subroutine (xk1win) does a read on the “source” record, prompts the user for a “target” key, and checks if that target record already exists. If not, it reuses the main create/update subroutine (xc2bld) to finish copying.

4. **Validation of Output Queue**  
   When saving a new or updated record, the code calls “AX020C” (an external program) to validate the user input for the output queue (c2outq). If that check fails, *IN33 is turned on to display an error indicator.

5. **Reuse of Subroutines**  
   xc2bld is invoked across different workflows (create, update, copy, or display). This reduces code duplication for the data-presentation logic.

6. **Program Modularity**  
   While all logic is in a single RPG source, the code is structured in discrete, well-named subroutines. Each SR handles a distinct aspect: clearing a subfile, creating a subfile, positioning, updating, etc.

---

## Interactions with Other Modules / APIs

- **AX020C**: Called during record updates in “xc2bld.” It checks the validity of a specified output queue (w_outq).  
- **Local Data Area**: The user ID (`l_user`) is used as the “last-updated-by” field (`aweusr`). This links any changes to the current user’s profile.

---

## Summary

AA016R is a comprehensive subfile program controlling printer definition maintenance. It handles the listing, creation, update, copy, and delete of printer setups in files awsdl1, awsdl2, awsdlr, and awsdlu. Different screens and windows manage each workflow, all coordinated by subfile paging logic and indicator-driven function-key processing. The program exemplifies a modular design with targeted subroutines for each major function (search, validate, create, copy, delete), ensuring maintainability and clarity in printer management.