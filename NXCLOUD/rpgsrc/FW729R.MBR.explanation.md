# RPG Source Code (FW729R) Walkthrough

This RPG (ILE RPG/400) program, `FW729R`, is a batch utility primarily for auditing and reporting *product price changes* for a wholesale/retail inventory system (Optimera). It generates a "control list", emitting records with price changes, and highlights various validation errors. It processes an input file in a specific (INTEG.DAT) format, organizes data for each product ("vare"), runs multiple checks, and emits a detailed report.

This walkthrough is structured for developers new to the code — focusing on major flows, data structures, and validation logic.

---

## 1. **Program Overview**

- **Header:**  
  `h option(*nodebugio) datedit(*dmy)` — disables debug info for IO, sets date edit word.
- **Primary Purpose:**  
  *Process a batch of goods from an integration file, validate fields, compare with current values, and report changes/errors.*
- **Comments:**  
  Scandinavian comments, changelog with versions/patches.
- **Special notes:**  
  - Rejects articles with alphabetics in item number (`varenr`).  
  - Rejects items with invalid groupings or units.
  - Validates and adjusts for differences between direct and warehouse pricing.

---

## 2. **File Declarations**

```rpg
fflvwpf    if   e           k disk         // Input file: batch data, variable record layout
ffw729p    o    e             printer      // Output: report
```
Other files (venhl1, vvprl1, vvenl2, vogrl1, etc.) represent master data:
- Article units
- Price records
- Group hierarchies
- Supplier info

Many files are `rename`d for field reference disambiguation.

---

## 3. **Core Data Structures**

### Arrays for Buffers
```rpg
d a_erec      s          297    dim(99)    // Package records (max 99 per product)
d a_prec      s          297    dim(99)    // Price records (max 99 per product)
```

### Product (Vare) Record
```rpg
d ds
d d_vrec                  297
d  d_nobb                   8  0 overlay(d_vrec:3)    // Item number (NOBB)
d  d_modn                   8  0 overlay(d_vrec:12)   // Model number
... etc.
```
- `overlay`: maps subfields directly onto the 297-byte read buffer.

### Package & Price Records
Defined similarly, with overlays for relevant fields.

### Key Variables
For accessing various indices:
```rpg
d vvenl2_vare    s    like(vevare)      // For price/unit keys
...
d vvprl1_vare    s    like(vpvare)
...
```

### Working Variables/Flags
```rpg
d b_frst         s      1    inz(*off)    // First record indicator
d b_ok           s      1                 // Validation flag
d w_etel         s      2  0              // Package record count
d w_ptel         s      2  0              // Price record count
...
```
---

## 4. **Main Control Loop**

**Initialization:**
```rpg
eval      b_frst = *on
eval      w_etel = 0
eval      w_ptel = 0
eval      w_enh_000 = *blank
eval      w_tell = 0
```

**Header Output:**
```rpg
exsr      hode
```

**Read and Dispatch Input Lines:**
```rpg
read      flvwpf
dow       not %eof
  eval    w_rect = %subst(fwirad:1:1)         // Record type: '1', '2', '3'
  
  if w_rect = '1' and b_frst = *off
     exsr behandling
     eval w_enh_000 = *blank
  endif

  select
    when w_rect = '1'
      eval d_vrec = fwirad
      eval b_frst = *off
    when w_rect = '2'
      eval w_etel += 1
      eval a_erec(w_etel) = fwirad
      if %subst(fwirad:4:3) = '000'
        eval w_enh_000 = %subst(fwirad:10:3)
      endif
    when w_rect = '3'
      eval w_ptel += 1
      eval a_prec(w_ptel) = fwirad
  endsl

  read flvwpf
enddo
```

**After EOF:**  
Process the last product batch:
```rpg
if b_frst = *off and d_vrec <> *blank
   exsr behandling
endif
// Write total record count.
eval t1tell = w_tell
write t1tot 30
exsr overflow
```

---

## 5. **Subroutines**

### a. **`behandling` (Main Handler for Product Batch)**

1. **Product Validation**:  
   `exsr vare`  
   Sets `b_ok = *on` if all checks pass.

2. **Package Validation:**  
   If any package records: `exsr pakning`

3. **Price Validation:**  
   If any price records: `exsr pris`

4. **Reset Buffers**:  
   `w_etel = 0; w_ptel = 0`

---

### b. **`vare` (Article Master Validation)**

- **Reject if missing NOBB number** (`d_nobb = 0`)
- **Group checks:**
  - Overgroup, main group, and subgroup: each checked via `chain` to associated files (`vogrl1`, `vhgrl1`, `vugrl1`) for existence.
- **Unit Test:**  
  - Checks against existing article for differing base unit (by referencing `vvarl1`).
  - Ensures base unit exists in unit register (`venhl1`)
- **Supplier Validation:**  
  - Ensures supplier exists (via `jlevl1`), and is linked.
- **NOBB/Article Number Handling:**  
  - If < 10 million, treated as internal; else as a NOBB number and looked up in `jvarl1`.
- **Item number must be all digits** (`%check(digits:w_vare)`)
- **Sets flag `b_ok = *on` if all checks pass.**

---

### c. **`pakning` (Package Validation)**

- **For each package record:**
  - Normalize numeric fields (replace blanks with `0`)
  - Validate unit against register (`venhl1`).
  - On failure, log error and abort further checks.

---

### d. **`pris` (Price Validation and Change Reporting)**

- **Find up to 5 sales units per article** (`exsr finn_enhet`).
- **For each price record:**
  - Must have both sale and cost price.
  - For each possible sales unit (`w_enh1`..`w_enh5`), run calculation and comparison via `exsr pris_enhet`.

---

### e. **`pris_enhet` (Per-Unit Price Handling)**

- **Validates Sale/Cost/Wholesale/Price for overflow (too high)**.
- **Calculates new prices for the unit.**
- **Finds any price records for this product/unit/supplier/group in vvprl1**.
- **If a change is detected** (old != new price fields):
  - Calculates margin/markup.
  - Emits report for *new* and *old* prices.
  - Increments item count.
- **If prices haven't changed, nothing is written.**

---

### f. **`finn_enhet` (Find Up To Five Sales Units)**

- Reads up to five "sales units" for the article in order (from vvenl2), sets them for use in price comparison.

---

### g. **`feil` (Error Reporting)**

- Logs an entry to the report for the current product, including error description and code.

---

### h. **`hode` and `overflow` (Report Headings)**

- Output report headings at the start and on page overflow.

---

### i. **`*inzsr` (Initialization Subroutine)**

- Build RPG `key lists` for indexed file access.
- Get company id from LDA, current date/time.
- Initialize tax/margin parameters by calling external program `RS205R`.
- Initialize pricing group by calling `VL711R`.

---

## 6. **Field/Variable Naming Conventions**

- `d_*` : data fields for article (vare), package, price, etc.
- `w_*` : working variables
- `b_*` : Boolean flags (e.g., `b_ok`, `b_frst`)
- `a_*` : arrays for holding package/price records for one article
- `vv*`, `ve*`, `vg*`, etc.: often refer to record fields in logical/master files.

---

## 7. **Error Handling & Reporting**

- All validation failures (products, units, suppliers, prices) are written to the report with a description and status code.
- Only products that pass all validation steps are reported as normal price changes.

---

## 8. **Key Points for New Developers**

- **Central Logic:**  
  The program loops over batches of records, groups them by product, validates with reference/master files, and produces a report of changes or errors.
- **Extensive Data Validation:**  
  Each entity (product, package, price) is rigorously checked against master records.
- **Modular via Subroutines:**  
  Each part of the process is in a subroutine, making the code easier to follow and test.
- **Overlay Fields:**  
  Many buffer records use `overlay` to map fixed-format data to meaningful fields.
- **External Program Calls:**  
  Tax rate and price-group lookups are done via `CALL` to external programs.
- **No Interactive UI:**  
  All I/O is file-based; it's a classic batch job.

---

## 9. **Common Pitfalls and Gotchas**

- **Arrays a_erec/a_prec:** Must not exceed 99 per product (no explicit overrun protection shown).
- **Hardcoded field lengths and positions:** Any upstream changes to the integration file require program updates.
- **Assumes existence and integrity of master files:** Missing or inconsistent master data will trigger error reports.
- **Heavy use of overlays and fixed-format files:** Debugging data issues may require hex dumps or DFU.

---

## 10. **Version/Enhancements Notes**

- Extensive changelog is included in the code (patches for handling GTIN, price groups, error logging).
- New price group and other miscelaneous fields have been added over time.

---

**Summary:**  
This is a robust, legacy RPG batch program for auditing and reporting product/master data updates, focused on price changes and validation against a master set of reference data. It is highly structured, procedural, and file-centric—characteristic of IBM i business applications. All processing, validation, and reporting logic is clearly compartmentalized into subroutines, making it approachable for maintenance and onboarding, provided one understands the data and file structures involved.

---

**Tip:**  
If you add/modify fields or validation rules, ensure all overlays and reference checks are kept in sync, and coordinate with the upstream process that generates the input integration file.