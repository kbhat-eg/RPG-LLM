# RPG Program EK110R - Customer Bonus Element Maintenance

## High-Level Function & Purpose

This program (EK110R) is designed to maintain "customer bonus elements" in an IBM i (AS/400) environment using ILE RPG. It supports operations such as view, add, edit, copy, and delete of customer bonus element records via a subfile-based workstation display.

---

## Source Structure Overview

### 1. File Declarations

- **Physical Files**: Many files are declared (`F` specs), each renamed from its base to local record formats, e.g.:
  - `ekbei1`, `ekbeir`, `ekbeiu` — Main bonus element files (with different record formats for inquiry, update).
  - Other files are for lookup: customers, items, groups, etc.
- **Workstation File**: `EK110D` is the display file, using subfile (`SFILE`) for record display and interaction.

---

### 2. Field, Data Area, and Structure Definitions

- **Parameter fields (`p_...`)**: Used to receive starting keys when the program is called.
- **Local Data Area (LDA)**: Used to retrieve session/user info.
- **Display Feedback Data Structure (`dspfbk`)**: Used for cursor location and display control.
- **Key and Working Variables**: Used for searching, displaying, updating, positioning, and operational flags.

---

### 3. Indicator (Flag) Management

- RPG indicators are used for:
  - Program end (`LR`), subfile actions (rollup, clear, end), error/status display, etc.
  - Special indicators are set to protect fields, signal error messages or working states.

---

### 4. Subroutines and Mainline Flow

#### **Initialization (`*INZSR`)**

- Imports parameters (keys and filter fields).
- Initializes main key lists for DB access.
- Calls lookup chains to fill heading info for context (e.g., customer name, group description) to display.
- Positions the database and loads the subfile.

#### **Main Menu Loop**

- **Command Screen (`b2cmd`)**: Displayed first to handle command keys.
- **Subfile Display**: Operations are handled via subfile:
  - Reads subfile for user actions (edit, copy, delete, inquiry).
  - Handles Page Up/Down, Home, enter keys, etc.

#### **Subfile Operation Subroutines**

- **forny**: Refreshes (clears and reloads) the subfile display.
- **subfile**: Main loop over subfile records to process user actions (edit, copy, delete, view).
  - Each row's action is handled by calling the respective subroutine, e.g., `xc2bld` for edit/view, `xd1win` for delete, `xk1win` for copy.

#### **Entry/Add New Record (`xc1bld`)**

- Handles the add-new logic:
  - Prompts user for new keys.
  - Validates that the new record does not already exist.
  - Calls `xc2bld` to process maintenance.

#### **Edit/View (`xc2bld`)**

- Loads the selected record into the edit screen.
- Allows editing, validates inputs.
- On save, updates or writes the new record.

#### **Copy (`xk1win`)**

- Allows the user to specify a target key for the copy.
- Validates the target does not exist.
- Calls maintenance to save as a new record.

#### **Delete (`xd1win`)**

- Loads the selected record.
- Shows confirmation window.
- On confirmation, deletes the record.

#### **Subfile Handling**

- **clr_subfile**: Clears the subfile.
- **crt_subfile**: Loads ("pages") records based on keys/filters into the subfile for user interaction.
- **dsp_subfile**: Controls the actual display of subfile window, sets indicators depending on whether there are records present.

#### **Inquiry (`spørring`)**

- Placeholder for handling inquiry logic (not implemented in this snippet).

---

### 5. Key Lists

Key lists are defined for each file access to ensure consistent DB lookups and updates, matching the fields as per input keys or working fields.

---

## Notable Variables and Concepts

- **w_srrn, w_ssrn, w_spge, w_sfrn, w_fcrn**: Manage subfile record numbers, current page, and cursor positioning.
- **b1valg**: Action chosen for a subfile line (2=edit, 3=copy, 4=delete, 5=view).
- **b_oppr, b_forn, b_subf, b_anul, b_feil**: Flags for flow control, operation status, errors.
- **p_ & w_ variables**: `p_` are parameters passed on entry; `w_` are working copies used for DB accesses and within the program flow.

---

## Screen Handling

- The program is highly subfile-driven (scrollable list of rows), using indicators to manage display and field protection (e.g. for view-only mode).
- Several dialog "windows" are used for add, edit, copy, delete confirmations.

---

## Summary of Workflow

1. **Program starts**. Parameters are set, heading info is looked up and display context is prepared.
2. **Subfile is loaded** with current records (filtered by keys/parameters).
3. **User interacts** via function keys or subfile row actions:
    - Add: Prompts for new keys, validates, then enters maintenance.
    - Edit/View: Loads row into detail screen for update/view.
    - Copy: Allows user to specify keys for a new row as a copy of an existing row.
    - Delete: Deletes the row after confirmation.
4. **Subfile and display are refreshed** upon changes.
5. **User can exit** at any main point via function keys.

---

## Special Features / Notes

- **Extensive use of indicators**: Both for field protection and for displaying status/errors.
- **User-friendly flow**: Main command handling, paging, validation, copy/confirm prompts.
- **Field-level validation**: For example, lower/higher boundary checks, record existence checks before add/copy.
- **Internationalization/Comments**: Many comments and field names are Norwegian or Danish.

---

## Onboarding Summary

- **Understand the subfile mechanics**: Most user interactions are handled via the subfile and associated indicators.
- **DB structure knowledge is key**: Know the files, record formats, and their relationships, as the program is heavily data-driven.
- **Indicators control everything**: Field protection, error display, subfile end, etc.
- **Modify with care**: Due to tight key and flow control, be cautious about changing field relationships or indicator logic.

If you need to enhance, fix, or debug this program, focus first on understanding the key lists, subfile paging logic, and the interplay between the add/edit/copy/delete subroutines. The business logic is embedded in the handling of the subfile and its related screens. Each subroutine is self-contained for its purpose, with validations and feedback for user actions.