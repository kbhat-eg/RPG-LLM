# RPG Program FO405R – Copy Company Data

This RPG III/IV program (FO405R) is used to copy all the data for a company (firma) across a set of related database files, presumably to clone company master data, reference data, etc., into a new company number. The code is written in Norwegian, but is straightforward to follow if you’re familiar with RPG and IBM i file handling.

---

## 1. **Header Section**

- `h option(*nodebugio)`: Compiles without debug information for file I/O operations (performance-oriented).
- Comments indicate history, version changes, and code origins.
- The program name is `FO405R`, described as “Kopier firma” (“Copy company”).

---

## 2. **File Declarations**

Each file declared has both an input and output declaration—input to read records, output to write (copy) them.

- Example:
  ```rpg
  fvahgl1    if   e           k disk    rename(vahgpfr:vahgl1r)
  fvahglu    o    e           k disk    rename(vahgpfr:vahglur)
  ```
  - `if`/`of`: Input/Output, Full procedural.
  - `e`: Externally-described file.
  - `k`: File is keyed.
  - `disk`: Disk file (DB).
  - `rename(from:to)`: Record format rename.
- This pattern is repeated for dozens of files, grouped logically by master data (groups, items, prices, etc.).

---

## 3. **Data Definitions**

- Many working fields are defined, e.g.:
    ```rpg
    d w_firm          s              3  0    // Target company number
    d l_user                911    920        // User info
    d l_firm                944    946  0     // Company number (from input)
    ```
- Fields like `l_user`, `l_firm` correspond to parameters or positions in a parameter list (from legacy program parameter passing).

---

## 4. **Main Logic – Copy Loops**

For each file pair (input/output), the same copy pattern is used:

### **a) Set Key and Read**

```rpg
c     vahgl1_key    setll     vahgl1      90
c     vahgl1_key    reade     vahgl1      90
c                   dow       *in90 = *off
```
- **`setll`**: Sets lower limit (positions cursor to first record for the key).
- **`reade`**: Reads the record for the given key.
- **`dow *in90 = *off`**: Loop as long as read is successful.

### **b) Modify Fields**

Fields in each record are updated for the new company:
```rpg
c                   eval      vfhfir = w_firm
6.10 c              time                    vfhoda
6.10 c              time                    vfhoti
6.10 c              eval      vfhous = l_user
```
- Update company field (e.g., `vfhfir`) to the new company (`w_firm`).
- Update audit fields, e.g. creation/modification date/time and user (for traceability).

### **c) Write and Loop**

```rpg
c                   write     vahglur
c     vahgl1_key    reade     vahgl1      90
c                   enddo
```
- **`write`**: Writes the modified record to the output file (usually an update or an insert).
- **Repeat** steps for all records in the source file for the company.

### **d) Repeat for All Tables**

This structure is repeated for all company-dependent tables: groups, items, prices, parameters, offers, etc.

---

## 5. **End Program Section**

```rpg
c     avslutt       tag
c                   eval      *inlr = *on
c                   return
```
- `*inlr = *on`: Turns on LR (last record) indicator, ending the program and closing all files.

---

## 6. **Initialization (INZSR) – Subroutine**

This subroutine does the startup logic:

```rpg
c     *inzsr        begsr
  // Parameter list with company number
c     *entry        plist
c                   parm                    w_firm
  // Build Key Lists for All Files
c     vahgl1_key    klist
c                   kfld                    l_firm
  // ...repeated for all files...
c                   endsr
```
- **`*entry`**: Entry parameter list, main parameter is the target company number (`w_firm`).
- **Keylists**: All keys are set up to use `l_firm` (the company number parameter) for file operations. This simplifies keyed access by using the same variable for all file operations.
- Multiple keylists, one for each DB file.

---

## 7. **Notable Practices**

- **Audit Trail**: Program updates creation/user/date/time fields for traceability on every new record written.
- **Batch Oriented**: Designed for batch execution; no user interaction.
- **Scalability**: Adding new company-dependent tables is simply a matter of copying the code block structure.

---

## 8. **General Flow**

1. **INZSR initializes**: Reads the target company number and fills in the key fields.
2. **For each file**:
    - Reads all records for the input company.
    - Updates the company number and audit fields.
    - Writes each record to the respective output table for the new company.
3. **Ends with proper closure**, setting the LR indicator.

---

## 9. **Summary Table of Files (Examples)**

| Source File | Output File | Description (Norwegian)     | Description (English)   |
|-------------|-------------|-----------------------------|------------------------|
| VAHGL1      | VAHGLU      | Alternativ hovedgruppe      | Alternate Main Group   |
| VVARL1      | VVARLU      | Vare                        | Item                   |
| VVEPL1      | VVEPLU      | Vare-enhet-prisgiver        | Item Unit Price Giver  |
| VSHEL1      | VSHELU      | Varesortiment hode          | Assortment Header      |
| etc.        | ...         | ...                         | ...                    |

---

## 10. **Key Takeaways for Onboarding**

- **Purpose**: Copy all master/reference data for a company across all related tables.
- **How**: For each table, read all records for the source company, update to the new company, write to output.
- **Modification Points**: To add new tables, mimic an existing copy loop and add file declarations.
- **Audit**: Every record written is updated with current user and timestamp (see `time` and user assignments).
- **Parameterization**: Code is controlled by entry parameters (likely passed from a CL or another RPG program).

---

## 11. **Potential Pitfalls**

- **Hard-coded field updates**: Must ensure that all new tables use correct company and audit fields in their record formats.
- **Performance**: For large data sets, this will be I/O intensive.
- **Referential Integrity**: If target company already exists, consider handling of duplicate keys or overwrites.

---

## 12. **Further Modernization**

- Consider refactoring into RPG IV / Free Format for maintainability.
- Use service programs or procedures for the repetitive copy logic.
- Dynamic table handling could reduce code duplication.

---

**In summary**:  
This program is a template-based, batch copy utility for transferring all company-dependent data from one company number to another, ensuring auditability by updating all relevant audit fields, and using a highly structured, repeatable copy pattern for every table involved.