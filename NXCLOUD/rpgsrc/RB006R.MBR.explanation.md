# RPG Program RB002R – Explanation

This RPG (Report Program Generator) code is designed to extract and transform customer data from database files on IBM i (AS/400), producing a comma-separated output (CSV-style) for use with business systems, such as Visma Business. The intent is to read customer information and format it according to predefined requirements, handling certain versions and business rules along the way.

Let’s walk through the code, section by section:

---

## 1. **Header Section**

```rpg
h option(*nodebugio) datedit(*dmy)
h decedit('0.')
```
- **option(*nodebugio)**: Disables debugging of I/O operations, making the program run slightly faster.
- **datedit(*dmy)**: Sets the default date format to day-month-year.
- **decedit('0.')**: Sets the decimal edit code (0 as thousands separator, . as decimal).

---

## 2. **Documentation and Revision Info**

Comment block containing:
- System, program name, and a description (extracts lines from LOVF, formats for Business/kundeinfo).
- Change history with version numbers, initials, and change details.

---

## 3. **File Declarations**

```rpg
flovfl1    if   e           k disk
frlevl1    if   e           k disk    rename(rlevpfr:rlevl1r)
frb10l1    if   e           k disk    rename(rb10pfr:rb10l1r)
frv03pf    o    e           k disk
```

- **Input Files**:
    - `LOVFL1`: Main input file (likely the customer table).
    - `RLEVL1` (renamed from `RLEVPFR`): For customer address/name lookup.
    - `RB10L1` (renamed from `RB10PFR`): Possibly for company/firm end information.
- **Output File**:
    - `RV03PF`: Output file, probably for the CSV data.

---

## 4. **Data Definitions**

```rpg
d                uds
d l_filg                931    933
d l_firm                944    946  0
d w_levr          s                   like(rllevr)
...
d u_post          s              1    inz(*off)
```
- **l_filg, l_firm**: Fields from user data space (UDS) or program interface.
- **w_levr, w_biln, w_firm, rlevl1_levr**: Work variables mirroring database fields.
- **tell**: A counter (for one-time actions).
- **w_rlflev, w_rlfacn**: Work variables for "Invoice Customer" and "Factoring Number".
- **u_post**: A switch (flag) to control if postal code is included with address.

---

## 5. **External Program Declaration (`CO402R`)**

```rpg
dcl-s co402_verdi1  char(1);
dcl-s co402_verdi2  char(2048);
DCL-PR CO402R EXTPGM('CO402R');
  p_filgrp            char(3)     const;
  p_firm              packed(3:0) const;
  p_lager             packed(2:0) const;
  p_nokkel            char(50)    const;
  p_verdi1            char(1);
  p_verdi2            char(2048);
END-PR;
```
- Declares interface to external program `CO402R`, which is used to check if postal code should be included with the city (uses a switch named `ØKONOMI_EKSTERNT_POSTNR_POSTSTED`).

---

## 6. **Main Program Logic**

### Initialization

```rpg
eval w_firm = l_firm
```
- Initializes the work variable `w_firm` from the LDA or input value.

---

### Main Read Loop

```rpg
nyles tag
read lovfl1 60
if *in60 = '1'
   goto slutt
endif
```
- Reads records from `LOVFL1`. If end-of-file (EOF, indicator 60 is on), branch to “slutt” (end).

### Heading Output (once)

```rpg
if tell = 0
   add 1 tell
   eval rvdata = *blank
   write rv03pfr
   eval rvdata = %trim('@IMPORT_METHOD(1)')
   write rv03pfr
   eval rvdata = %trim('@ActoR(=SupNO,') + ... + ('InvoCust,FactNo)')
   write rv03pfr
   eval w_biln = lgbiln
endif
```
- On the first iteration (when `tell = 0`):
    - Writes empty line.
    - Writes header lines specifying import method and field names.
    - Saves the first “bilagsnr” (voucher number).

### Process Each Record

```rpg
exsr finnadr
goto nyles
```
- Calls subroutine `finnadr` to process and output the formatted data for the customer record.
- Continues with the next record.

---

### Program End

```rpg
slutt tag
eval rvdata = *blank
write rv03pfr
read rb10l1 90
eval rvdata = %trim('@FIRM_END(') + %trim(rafirb) + %trim(')')
write rv03pfr
eval *inlr = *on
```
- After processing all records:
    - Writes blank lines and a line marking the end of firm data (e.g., `@FIRM_END(20063)`).
    - Signals end-of-program (`*inlr = *on`).

---

## 7. **Subroutines**

### a. `finnadr` – Find Name, Address, etc., Write Output

**Keys into customer info:**
```rpg
eval w_levr = lgkund
eval rlevl1_levr = w_levr
chain rlevl1 90
```
- Prepares key and looks up customer in `rlevl1`.

**Postal Code/Area Handling:**
```rpg
if %found(rlevl1) and u_post = *off and %char(rlponr) = %subst(rlsted:1:4)
   eval rlsted = %subst(rlsted:6:25)
endif
```
- If the postal code equals the first 4 chars of the post area (and postal-code switch is off), strip the postal code from the area.

**Invoice Customer and Factoring Number (Version 8.02):**
```rpg
if rlflev = 0
   movel *blanks w_rlflev
else
   movel rlflev w_rlflev
endif
if rlfacn = 0
   movel *blanks w_rlfacn
else
   movel rlfacn w_rlfacn
endif
```
- If “Invoice Customer” or “Factoring Number” is zero, output as blanks instead of “0”.

**Output Record:**
```rpg
if *in90 = *off
   eval rvdata = *blank
   eval rvdata = %trim('"') + ... + %trim(w_rlfacn) + '"'
   write rv03pfr
endif
```
- If customer record was found, outputs a line with all required fields, quoted and separated, as per the constructed string.

---

### b. `*inzsr` – Initialization Subroutine

```rpg
CallP CO402R(l_filg:w_firm:0:'ØKONOMI_EKSTERNT_POSTNR_POSTSTED':
             co402_verdi1:co402_verdi2);
if co402_verdi1 = '1';
   u_post = *on;
endif;
```
- Calls external program to find out if postal code should be removed from post area name.
- Sets flag (`u_post`) for later logic.

---

### c. Key List (`klist`) for Lookup

```rpg
rlevl1_key    klist
kfld w_firm
kfld rlevl1_levr
```
- Specifies composite key for chaining to the customer file.

---

## 8. **Special Handling and Business Rules**

- Version comments indicate continuous adaptation, such as for Visma Business, changing header text, removing content, or controlling post area logic.
- The program is parameterized using the LDA and external settings, which allows for flexible deployment in different environments or companies.

---

## 9. **Summary/Usage Scenario**

This program is typically run as a batch job to generate customer master files for import into another system (like an ERP). It extracts, formats, and outputs customer info, dealing with various business requirements as dictated by the change log and parameterization.

---

## **Key Takeaways**

- Reads customer and supplementary data from IBM i physical files.
- Outputs formatted, possibly comma-separated, records for external consumption.
- Handles field cleaning and value substitutions per business rules.
- Uses external switches and parameters for dynamic logic (postal code display, etc.).
- Employs RPG native features (chains, indicators, subroutines) in a structured, maintainable way.

---

If you’re onboarding to this code, your main tasks will likely involve:
- Understanding the business context for each field.
- Possibly adapting field output or logic for new requirements or target systems.
- Maintaining compatibility with external switch programs and respecting the modular approach.