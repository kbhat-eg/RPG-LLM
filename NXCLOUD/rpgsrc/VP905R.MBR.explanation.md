## Overview

This program, named **VP905R**, calculates and returns a final selling price (including any applicable discounts or coverage adjustments) for a given item (vare) and customer context. It pulls data from various physical files, looks up standard and special prices, applies different layers of discounts, handles VAT codes, and optionally uses coverage-based price adjustments. It then returns the computed price (and related metadata) in the specified output parameter.

Below is a high-level outline of its functionality and notable design details.

---

## Main Responsibilities

1. **Retrieve base item information**  
   - Uses external service calls (e.g., calling `VL710R`) and database lookups (CHAIN commands against files like `vvarl1`, `jvarl1`) to verify if the item is valid and to gather initial data such as base prices, item type, coverage percentage (dekningsgrad), or cost price.

2. **Determine standard prices**  
   - Subroutine **`hent_standard`** attempts to find a selling price (and cost price if needed) based on date, delivery type, and an optional price group. If no direct price is found for the item under a given delivery type and price group, the code falls back through several permutations (e.g., *delivery type 0*, *price group blank*, etc.).

3. **Check for special prices or order-specified prices**  
   - Subroutine **`ordre`** checks if the program call references a specific order/quotation line number. If so, it fetches the line’s prices and discounts directly (this overrides standard pricing logic).  
   - Subroutine **`hent_matrise`** scans a large discount/price matrix with multiple levels of match criteria (e.g., item, groups, module, customer categories, etc.). If a match is found, it can override the standard price or apply discounts.

4. **Apply coverage and discount logic**  
   - Subroutine **`dekning`** applies a coverage-based calculation if a coverage percentage is specified as an input. It can override the normal price with a value that meets the requested coverage.  
   - Subroutine **`beregn_pris`** then compares different computed prices (special price, net price, cost-plus coverage scenario, etc.) to choose the final “lowest” relevant selling price for the customer.

5. **VAT (MVA) handling**  
   - Subroutine **`mva_kode`** determines the correct tax/VAT code. It considers whether the sale is tax-free, or if the customer’s setup mandates special taxes (e.g., special invoice handling, or a different VAT code from the item’s definition).

6. **Customer-specific logic**  
   - The code honors various parameters:  
     - Customer discount categories (`w_rkat`),  
     - Customer group or “almenning” logic for bruksrett-rabatt (subroutine **`hent_bruksrett`**),  
     - Potential overrides from “kundeprosjekt” records, which can change the normal discount category or the item’s price.

7. **Layered approach to discount matrix**  
   - Subroutine **`hent_matrise`** uses a multi-layer match approach, essentially enumerating numerous match sequences (rabattkategori, kundekategori, item hierarchy, delivery type, etc.) in a single run. It checks from the most specific match (exact item and delivery type) to more general matches (group-level or “blank” conditions).  
   - Whenever a match is found, it collects applicable discounts or coverage percentage, or sets a special price. The code references a large range of steps (documented in the source comments) to find the highest-priority entry.

8. **Bruksrett-rabatt**  
   - Some customers have special “usage rights” (bruksrett) discounts. Subroutine **`hent_bruksrett`** checks for these on a per-item or group basis, again overriding or adding discount percentages.

9. **Returning results**  
   - After all computations, the program stores results in an output data structure (`horec`), placing final values for selling price, discount percentages, cost price, coverage factor, or any usage-right discount.  
   - The calling program receives a 100-byte structure containing all final price data, codes, and relevant discount/coverage information.

10. **Resource cleanup**  
   - If a particular flag (`hiinlr`) is off, the program calls subroutine **`lukk_vl710`** to close out its external calls before ending with `*inlr = *on` (marking the program for removal from memory if running in an RPG cycle environment).

---

## Notable Design Aspects

- **Extensive “fallback” logic:**  
  Nearly every pricing path has multiple fallback sequences for retrieving data. For example, standard price lookups step down from specific (item + price group + delivery type) to more general (item alone), while discount matrix lookups also step through many sub-levels. This approach ensures that if the highest specificity is not found, the process continues to the next-until it finds an applicable match.

- **Large discount matrix hierarchy:**  
  The comment block that details 1–240 “levels” (or more) in the discount matrix reveals a design where every possible combination of (customer, item, categories, modules, groups, etc.) is tested. The program systematically traverses these in subroutine **`hent_matrise`**.

- **Use of subroutines for modularization:**  
  The program is subdivided into subroutines to handle discrete tasks:
  - `init` for initializing fields.  
  - `mva_kode` for VAT code decisions.  
  - `hent_standard` for standard pricing.  
  - `ordre` for order-based overrides.  
  - `dekning` for coverage-based logic.  
  - `hent_matrise` and `hent_bruksrett` for discount logic.  
  - `beregn_pris` for final comparison.  
  - `spesialpris` and `rabatt` for applying special pricing or discount lines from the matrix.  
  - `tilb_sjekk` for finding group-level “tilbudspris.”  

- **Multiple physical file lookups (CHAIN/READE/SETLL):**  
  Each physical file (e.g., `vvarl1`, `vvprl1`, `vtill1`, `fohel1`, etc.) has a key list, and the program repeatedly uses them to find a matching record. The naming convention includes “l1,” “l5,” etc., to differentiate data levels or record formats for the same physical file.

- **Flag-based flow control:**  
  Several single-character or single-byte fields (like `b_pris`, `b_spes`, `b_raba`) act as “switches” to indicate if a specific logic path is active (e.g., if a price was found). This style is typical in older RPG designs, providing a quick on/off check for each pricing path.

- **Integration with external modules:**  
  The subroutine **`lukk_vl710`** calls program `VL710R` again (with flags changed) as a way of finalizing data or releasing resources. This indicates that item data is initially fetched by the same external routine (`VL710R`) in multiple ways.

---

## Interactions With Other Modules / Data Sources

- **VL710R**: Called twice (initially and optionally at the end) to retrieve or finalize item data (e.g., cost data, stock info, coverage flags).  
- **Files**:  
  - **`vvarl1` / `jvarl1`**: Main item or “VA item” records.  
  - **`vvprl1`**: Standard item price records.  
  - **`vtill1`**: Special “tilbud” (offer/campaign) pricing.  
  - **`fpril1`** / **`frabl1`**: The primary “special price” and “discount matrix” files.  
  - **`fohel1`/`fodtlv`**: Order header and detail lines, used for direct order-specific pricing.  
  - **`rmknl2`, `rkunl1`, `fkprl1`**: Customer, customer project, and property associations (providing overrides and category data).  
  - **`vbrkl1`, `vbrkl5`, `rmbtl1`**: Logic for “bruksrett” (usage rights) or communal ownership discounts.

---

## Summary of Flow

1. **Initialize** input and output data structures (subroutine `init`).  
2. **Fetch item data**. If not found or invalid, exit. Possibly call `VL710R` for extended item details.  
3. **Set up defaults** for VAT code (subroutine `mva_kode`).  
4. **Load standard prices** (subroutine `hent_standard`).  
5. **Check if an order line is specified** (subroutine `ordre`). If so, use that price and skip further logic.  
6. **If a coverage percentage is given**, do coverage-based price computation (subroutine `dekning`).  
7. **If needed, fetch specialized or discount-matrix-based prices** (subroutine `hent_matrise`), then apply usage-right discounts (subroutine `hent_bruksrett`).  
8. **Compare, finalize, and build the final price** (subroutine `beregn_pris`).  
9. **Populate output data structure** with final price, discount, coverage factor, or other relevant fields.  
10. **Return** to the caller.

Overall, **VP905R** ensures that the caller receives the correct selling price, cost price, relevant discounts, and coverage adjustments for a particular item and date/time context, with multiple fallbacks and matrix-based logic.