## Program Overview

This RPG program (`VE722R`) is designed to fetch GTIN codes (Global Trade Item Number, commonly EAN/barcodes) and supplier part numbers based on provided item number, unit, and supplier for a given company. The program reads from several physical and logical files (tables), using a key-based approach to locate the needed data.

- **Inputs:** Company (firma), Supplier (leverand√∏r), Item number (varenr.), Unit (enhet)
- **Outputs:** GTIN number, Supplier item number (Lev.varenr), Status (1=OK)
- **Files Accessed:** `vvarlr`, `vveplr`, `jvarl1`, `jvpkl1`, `jlevl3`, `jvlel1`

---

## Key Sections Explained

### 1. File Declarations

Each file used for queries is declared as keyed and externally described, with renaming for record format clarity:

```rpg
fvvarlr    if   e           k disk    rename(vvarpfr:vvarlrr)
fvveplr    if   e           k disk    rename(vveppfr:vveplrr)
fjvarl1    if   e           k disk    rename(jvarpfr:jvarl1r)
fjvpkl1    if   e           k disk    rename(jvpkpfr:jvpkl1r)
fjlevl3    if   e           k disk    rename(jlevpfr:jlevl3r)
fjvlel1    if   e           k disk    rename(jvlepfr:jvlel1r)
```

### 2. Variable Definitions

Variables are defined (`d`) for use as keys or output variables, many using the `like()` keyword for data consistency with file fields. Parameters defined here correspond to function inputs/outputs.

- `p_firm`, `p_ldor`, `p_vare`, `p_enhe`: Inputs
- `p_eann`, `p_lvar`, `p_stat`: Outputs

### 3. Main Logic Flow

#### a. Parameter Initialization

The output parameters are initialized:

```rpg
c                   eval      p_eann = 0
c                   eval      p_lvar = *blank
c                   eval      p_stat = *blank
```
---
#### b. Try to Find Item in `vvarlr`

- Set company and item number, do a keyed CHAIN to `vvarlr`.
- If not found, jump to supplier-agnostic checks (`sjk_VA`).

```rpg
c                   eval      vvarlr_firm = p_firm
c                   eval      vvarlr_vare = p_vare
c     vvarlr_key    chain     vvarlr
c                   if        not %found(vvarlr)
c                   goto      sjk_VA
c                   endif
```

#### c. GTIN Lookup for the Given Supplier in `vveplr`

If supplier input (`p_ldor`) is provided, check for GTIN code (barcode) for this item/supplier/unit:

```rpg
c                   eval      vveplr_pfir = p_firm
c                   eval      vveplr_pvar = p_vare
c                   eval      vveplr_penh = p_enhe
c                   eval      vveplr_pldo = p_ldor
c     vveplr_key    chain     vveplr
c                   if        %found(vveplr) and
c                             vepgti <> 0
c                   eval      p_eann = vepgti
c                   eval      p_stat = '1'
c                   goto      les_lvar
c                   endif
```

If not found, double-check `vveplr` again but *without* supplier constraint, just item/unit:

```rpg
c                   eval      vvepl1_pfir = p_firm
c                   eval      vvepl1_pvar = p_vare
c                   eval      vvepl1_penh = p_enhe
c     vvepl1_key    setll     vveplr
c     vvepl1_key    reade     vveplr                                 91
c                   dow       *in91 = *off
c                   if        p_enhe = vepenh and
c                             vepgti <> 0
c                   eval      p_eann = vepgti
c                   eval      p_stat = '1'
c                   goto      les_lvar
c                   endif
c     vvepl1_key    reade     vveplr                                 91
c                   enddo
```

If still not found, proceed to the next section (`sjk_gtinVA`).

---
#### d. If GTIN Not Found: Check Alternate Repositories

##### i. Supplier Administration (`jvarl1`)

Attempt to find matching item with `jvarl1`. If not found, continue; if found, continue GTIN search.

##### ii. GTIN in VA (`jvpkl1`)

First, try to find a matching supplier, item, and unit with GTIN not zero:

```rpg
c                   eval      jvpkl1_vare = p_vare
c                   eval      jvpkl1_ldor = w_ldor
c     jvpkl1_key    setll     jvpkl1
c     jvpkl1_key    reade     jvpkl1
c                   dow       not %eof(jvpkl1)
c                   if        jwldor = w_ldor and
c                             jwenhe = p_enhe and
c                             jwgtin <> 0
c                   eval      p_eann = jwgtin
c                   eval      p_stat = '1'
c                   goto      les_lvar
c                   endif
c     jvpkl1_key    reade     jvpkl1
c                   enddo
```

If still not found, try again ignoring supplier (`jvpkl1_key2`):

```rpg
c                   eval      jvpkl1_vare = p_vare
c     jvpkl1_key2   setll     jvpkl1
c     jvpkl1_key2   reade     jvpkl1
c                   dow       not %eof(jvpkl1)
c                   if        jwgtin <> 0   and
c                             jwenhe = p_enhe
c                   eval      p_eann = jwgtin
c                   eval      p_stat = '1'
c                   goto      les_lvar
c                   endif
c     jvpkl1_key2   reade     jvpkl1
c                   enddo
```

---
#### e. Supplier Item Number Fetch

After any successful lookup, jump to `les_lvar` to determine the supplier part number:

```rpg
c     les_lvar      tag
c                   eval      p_lvar = vvlvar
c                   eval      jvlel1_lvnr = p_vare
c                   eval      jvlel1_lldo = w_ldor
c     jvlel1_key    chain     jvlel1
c                   if        %found(jvlel1)  and
c                             jvllva <> *blank
c                   movel     jvllva        p_lvar
c                   endif
```
- This checks for a matching supplier part number (`jvllva`). If found and not blank, move it to the output.

---
#### f. Program End/Cleanup

Standard RPG ending: set LR (last record) indicator to `*on` for proper object closure and return.

---

### 4. *INZSR Subroutine

The initialization subroutine (`*inzsr`):

- Reads program parameters (`*entry`/`plist`, `parm ...`)
- Constructs all relevant key lists for chained accesses throughout the program.
- Looks up the supplied supplier code (`p_ldor`) in `jlevl3` to possibly determine the internal supplier number.

---

## Summary of Logic

1. **Try to find item in main item file (`vvarlr`).**
2. **Look for EAN/GTIN code in unit- and supplier-specific register (`vveplr`).**
   - If not, look for EAN/GTIN by unit only.
3. **If not found, check alternate sources (VA):**
   - Item administration (`jvarl1`)
   - VA GTIN cross-reference (`jvpkl1`)
4. **After any match, find the supplier's item number, if available.**
5. **Set outputs accordingly and end.**

---

## Key Takeaways for Developers

- The program tries to find a unique GTIN for a given item/unit/supplier in a prioritized sequence.
- If a supplier-specific barcode is not found, it tries to get the closest match (by unit, then by item only, etc.).
- Output is both the standardized GTIN and the supplier's item number (if available).
- Multiple physical/logical files are involved, and key lists are widely used to ensure efficient lookups.
- All parameters and keys are typed using `like()` for data integrity across files.
- All main logic is in the start block; subroutine `*inzsr` is for parameter and variable initialization.

---

This is a typical example of an RPG batch-style lookup program integrating several data sources to resolve coding and referencing issues in a supply chain context.