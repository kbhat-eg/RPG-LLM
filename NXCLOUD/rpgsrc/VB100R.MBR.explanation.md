# RPG Program VB100R Code Walkthrough

## Overview

This RPG (ILE RPG/400) program manages maintenance for "Bruksrett-knytning" — likely a form of entitlement or rights linkage, possibly related to items, modules, or groupings. It is written in Norwegian and consists of traditional fixed-format RPG with subfile (subfil) handling, several database files, multiple key-lists, and subroutines for various user actions.

Below, we'll walk through how the code is organized and provide context for each segment.

---

## 1. **Header and Documentation**

- `h option(*nodebugio) datedit(*dmy)` sets program options: no I/O debugging, and default date format *DMY*.
- The large comment block describes the program (VB100R), its usage, version history, and explains the usage of indicators (like *LR, *IN10...*IN99).

---

## 2. **File Definitions**

### a. **Physical/Logical Files**

Each `f` entry defines a file usage. For example:

- `fvbrkl1    if   e           k disk    rename(vbrkpfr:vbrkl1r)`
  - Input file ("i"), full procedural ("f"), externally described ("e"), keyed ("k"), disk file, with record format renamed.

There are multiple similarly defined files—these represent various groupings, items, or types (`vbrkl1`, `vbrkl2`, etc.) with different access paths, used for reading/updating database information.

### b. **Display Files**

- `fvb100d ... workstn sfile(b1sfl:w_srrn)`
  - The main display file is a workstation file with subfile support (for lists on screen).

---

## 3. **Data and Working Fields**

### a. **Parameters**

- `p_firm`, `p_alme`: Company and department/area identifiers, passed as parameters.

### b. **Data Area Variables**

- From user space, e.g., `l_user`, `l_fnav`.

### c. **Information Data Structure**

- `dspfbk`: Holds feedback from display file (e.g., `d_fcrn` = first record number displayed on page).

### d. **Key Variables**

- Fields for each file's key structure (e.g., `vbrkl1_ogrp`, `vbrkl1_hgrp`, etc.), used to access records in the different files with various keys.

### e. **Working Variables**

- Used for navigation, subfile control, error flags, and temporary storage.
- `w_fcrn`, `w_stel`, `w_spge`, `w_srrn`, `w_sfrn`, `w_ssrn`: Used to control subfile page size, current record, total records, etc.
- `w_seqe`: Decides which grouping level (O/U/M/V).
- `b_oppr`, `b_forn`, `b_anul`, `b_feil`: Boolean flags for different process conditions.

### f. **Constants**

- `c_sfil`: Constant for subfile page size.

---

## 4. **Indicator Usage (from comments)**

- **LR**: End-of-program indicator.
- **10-15, 21-22, 30, 31-79, 80-99**: Various function keys, error messages, screen indicators, and internal flags.

---

## 5. **Main Program Flow and Subroutine Usage**

### a. **Main Loop**

- The program works around a main subfile display and edit loop using tags and GOTO/EXSR (subroutine call) instructions.

#### b. **Display and Function Key Processing**

- **b2taga**: Initial entry—displays command screen (`b2cmd`).
- **b2tagb**: Refresh subfile display, manage function key processing.

#### c. **Function Key Actions (`select ... when`)**

- Exit, Query, Refresh, New record, Page-up/down, Home, Cursor, etc., are mapped to function keys via indicators.

#### d. **Positioning**

- If a positioning field is set (for any grouping level), the program positions to the requested record ("posisjoner"), then refreshes the display.

---

## 6. **Subroutines**

### a. **forny** (Refresh subfile)
- Repositions in the current subfile, clears it, and loads it again based on the active positioning level.

### b. **posisjoner** (Position to record)
- Determines which grouping level (over, main, under, module, item) the user wants to position on, sets appropriate keys, and loads the matching records into the subfile.

### c. **subfile** (Subfile handling)
- Reads through subfile records (`readc`), processes user choices for each line (edit, copy, delete, view).
- For each processed record, the matching edit window (xc2bld), copy window (xk1win), delete window (xd1win) is called as needed.

### d. **xc1bld / xc2bld / xc1msg** (Screen handling)
- **xc1bld**: Handles adding new records (C1BLD screen).
- **xc2bld**: Handles edit/view of an existing row.
- **xc1msg**: Shows duplicate-warning message if trying to add a record that already exists.

### e. **xd1win / xk1win** (Delete and Copy)
- **xd1win**: Display and confirmation for deleting a record.
- **xk1win**: UI flow for copying a record.

### f. **clr_subfile/crt_subfile/bck_subfile/dsp_subfile**
- Clear subfile, load (next page), page-back, and display subfile routines.

### g. **spørring** (Lookup/inquiry)
- Handles F4/help queries (calls other programs to lookup groups, modules, items, etc.) depending on the currently active field.

### h. **sjekk_input** (Input validation)
- Checks validity of entered values, cross-references existence, retrieves descriptions, and sets error indicators.

### i. **hent_info** (Fetch description)
- Retrieves text/descriptions for the current overgroup, main group, undergroup, module, or item.


---

## 7. **Initialization (*INZSR)**

- Sets up parameters, initializes key-lists, positions the file to first record, and loads the first page of the subfile.

---

## 8. **Key Lists**

Defined at the end — these group fields into access keys for the various files, to manage reading/positioning in files according to the active context (grouping level, item, etc.), e.g.:

```rpg
c     vbrkl1_key    klist
c                   kfld      w_firm
c                   kfld      w_alme
c                   kfld      vbrkl1_ogrp
...
```
These are used with `CHAIN`, `SETLL`, etc., for quick record access.

---

## 9. **Error and Indicator Handling**

- Whenever validation fails or a duplicate is found, corresponding indicators (`*IN31`, `*IN32`, etc.) are set, which will likely trigger fields to highlight or error messages to appear in the UI panels.

---

## 10. **Program Structure Summary**

1. **Initialize**: Set up parameters, prepare the first subfile page.
2. **Main loop**: Show subfile, capture and process function key input.
3. **Positioning**: Jump/filter subfile to selected group/item.
4. **Edit/Delete/Copy**: Open up corresponding screens for edit, delete, copy, and persist the changes to the database.
5. **Validation**: Cross-checks user input for each grouping or item, both for existence and data integrity.
6. **Lookup/Dialogues**: On user request (often F4), open lookup dialogs (another RPG program) for code selection and field fill-in.

---

## 11. **Notable RPG/AS400 Concepts Illustrated**

- **Subfiles**: Used extensively for paginated list display and editing.
- **Keyed Access**: Use of SETLL/CHAIN/READ/READP with klist for fast navigation and lookup.
- **Indicators/Screen Variables**: RPG uses numeric indicators (`*INnn`) for both program and UI state.
- **Legacy RPG**: Uses fixed-format (C-specs, D-specs, F-specs, H-specs).
- **External Calls**: Uses `CALL` statement for launching lookup dialogs or validations in separate programs.
- **Feedback Data Structures**: Uses INFDS in display file for reading cursor/record placement info.

---

## 12. **Typical Program Flow for the User**

1. User enters filter fields (overgroup, main group, etc.), presses a key to search/position.
2. Subfile is loaded and displayed.
3. User navigates (page up/down, home) or selects an action (edit, copy, delete, view) on a record.
4. Edit/Copy/Delete windows are displayed accordingly.
5. User can use F4/help to look up valid codes for groupings/items.
6. Upon completion/exit, program sets *INLR to end.

---

## 13. **Common Norwegian Terms**

- `Bruksrett` = Usage rights
- `Knytning` = linkage/association
- `Overgruppe/Hovedgruppe/Undergruppe` = Overgroup/Main group/Under group
- `Modul` = Module
- `Vare` = Item
- `Forny` = Refresh
- `Slett` = Delete
- `Kopier` = Copy
- `Vis` = View
- `Opprett` = Create

---

## 14. **Onboarding Tips**

- **Subfile handling is central**: Make sure to understand how the display file (VB100D) and subfile (B1SFL/B2CTL/B2CMD/etc.) are set up, as it drives user interaction.
- **Key-lists match DSPF keys**: Understand the various access paths, as different screens operate at different grouping levels.
- **Program is procedural and heavily indicator-driven**: Most logic is encoded via *INnn indicators and GOTO/EXSR usage.
- **Testing**: Test each user action (edit/copy/delete) in the UI and observe the corresponding subroutine and file activity.

---

**In summary:**  
This is a classical ILE RPG program for a layered entity/item/rights structure, using subfiles for interactive list display and maintenance. It is a good example of robust (though somewhat dated) RPG applications combining database, display, user input validation, and external launch of supplementary programs for lookup and selection.