# Program Overview

This IBM ILE RPG program retrieves invoice header and line information for a web shop (Nettbutikk) and writes it to a data queue. It’s designed as a batch server that reads requests from an input data queue, processes them, and sends the results to an output data queue. The program interacts with several database files, processes headers and details for invoices, and formats the information for output.  

## File Declarations

- **sohel1**: Invoice header file (`sohepfr`, renamed `sohel1r`)
- **rkunl1**: Customer master file (`rkunpfr`, renamed `rkunl1r`)
- **sodtl1**: Invoice line file (`sodtpfr`, renamed `sodtl1r`)
- **vpkol1**: Item price code file (`vpkopfr`, renamed `vpkol1r`)
- **aforlr**: Routine configuration file (`aforpfr`, renamed `aforlrr`)

## Parameter Definitions

Parameters for queue and processing control:

- `p_uniq` – Unique key
- `p_dtqi`, `p_dtqo` – Input and output data queue names
- `p_bibl` – Library
- `p_feil` – Error indicator
- `p_firm` – Company number
- `p_lage` – Warehouse/stock location
- `p_inpl`, `p_outl` – Input and output data lengths
- `p_wait` – Data queue wait time
- `p_keyo`, `p_keyl` – Input/output keys
- `p_sndl`, `p_sndi` – Send-related parameters

## Data Structures

Three main data structures:

- **d_inpu**: Structure for input queue data (fields: year, invoice number)
- **d_outh**: Output structure for invoice header details (declared as a single string with overlays for each field)
- **d_outl**: Output structure for invoice line details (as above, for line-specific data)

Fields are "overlayed" on a base string, meaning the actual output is a fixed block of bytes, with each field mapped to a specific offset.

## Working Variables

Includes variables for:

- Dates in ISO format
- Status characters
- Amounts and counters
- Various fields for company, invoice, customer, etc.

## Key Lists (KLISTs)

Defines compound keys for database accesses, e.g., for finding invoice headers or lines based on company, year, and invoice number.

---

# Main Program Flow

## 1. Initialization (`*inzsr`)

- Receives parameters from the caller.
- Sets up KLISTs for file access.
- Retrieves company from parameter.
- Gets current date/time.

## 2. Main Loop

Repeats until the input data queue contains all blanks:

- Reads from the input data queue using `QRCVDTAQ`.
- If data exists, calls the `behandling` (process) subroutine.
- Loops to wait for the next request.

## 3. Processing (`behandling`)

- Extracts year and invoice number from input queue (moves to `w_aarr` and `w_binr`).
- If year is blank, uses the current date as fallback.
- Uses the KLIST to try to find the invoice header in `sohel1`:
    - If not found, sets `p_feil` to indicate an error and exits.
- Calls:
    - `faktura_hode`: Writes header information to the output queue.
    - `faktura_linje`: Writes the lines for the invoice to the output queue.

---

# Subroutines

## `faktura_hode`

- Loops through all invoice headers for the current invoice and sums up various sales and discount fields.
- Counts the number of invoice lines.
- Fills in the output structure `d_outh` with fields from the invoice header and customer.
    - Handles special logic for the KID number (customer reference/ID).
    - Formats totals and counts for output.
    - Handles conversion of dates.
    - Looks up and fills customer details.
    - Placeholder (commented out) for fetching payment terms.
- Calls `QSNDDTAQ` to write the header record to the output queue.

## `faktura_linje`

- Loops through all invoice lines for the current invoice.
- Fills fields in `d_outl`.
- If the line has a price code, looks it up in `vpkol1` for description.
- Calculates and formats discounts and net prices.
- Handles different layouts for text and item lines.
- Calls `QSNDDTAQ` to write each line record to the output queue.

## Error Routine (`*pssr`)

- Sets error flag
- Jumps to program end

---

# Data Queue Interface

- **QRCVDTAQ**: Receives request from the data queue (blocking/waiting if needed).
- **QSNDDTAQ**: Writes output to the data queue (header/line).

---

# Error and Exit Handling

- If a requested invoice is not found, `p_feil` is set and the program exits.
- PSSR routine catches unexpected errors, sets error, and exits.

---

# Comments and Documentation

- Header comments list version/changes, program function, and authors.
- Various Norwegian terms are used for field/variable names, reflecting original business logic.

---

# Summary for New Developers

- The program is a batch server for a web shop, reading requests off a data queue, fetching invoice headers/lines, formatting the results, and returning them.
- Uses overlay data structures for queue interactions.
- Key database lookups are done using compound keys built from company, year, invoice number, etc.
- Calculations are performed for sales, discounts, net prices, and line counts.
- Care is taken with formatting and localization (e.g., converting decimal points to commas).
- The code is written in fixed-format RPG IV, with some extensions (prototypical of late RPG III-IV migration code).
- Special attention should be given to understanding the data mapping via overlays for both input and output data.

---

# Typical Flow

1. **Waits for a request** (invoice number/year) on an input queue.
2. **Looks up the invoice header** and validates its existence.
3. **Collects and formats header and line details**.
4. **Sends results to an output queue**, handling both summary (header) and detail (lines).
5. **Handles errors gracefully**, always returning status via the error flag.

---

# Key Takeaways for Onboarding

- **Business logic is invoice-centric**: It revolves around retrieving and formatting invoice data.
- **Data queue handling**: Queue-based inter-process communication is central.
- **Overlayed data structures**: Output is built as fixed-format string blocks, which is essential to understand for any interface work.
- **Legacy constructs**: Code is traditional RPG IV, using `C` specs, overlays, and subroutines.
- **Commenting**: Inline comments (in Norwegian) explain the purpose of chunks of code—useful for future maintenance.

---

If you need a deeper explanation of a specific routine, file structure, or business logic, just ask!