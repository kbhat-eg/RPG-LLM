# ILE RPG Program: VA510R – Unit Inquiry with Subfile

This ILE RPG (OPM-style, fixed-format) program implements a subfile-based interactive display for querying units ("enheter"). The program is well-documented, in Norwegian, and utilizes several display files and physical files. Here’s a walkthrough for onboarding new developers:

---

## **Header and General Info**
- `h option(*nodebugio)` disables the debug I/O feature.
- `h datedit(*dmy)` sets the default date editing to day/month/year.

### **Description and Versioning**
- The main function: "Enhet, spørring" (Unit, inquiry).
- Comments mention change history, code conventions, and purpose.

---

## **Indicators Usage**
- Indicator (`*INxx`) assignments are provided in comments (e.g., `LR` for End of Program, `10` for Roll, `14` for `SFLCLR`).

---

## **File Declarations**

```rpg
fvenhl1    if   e           k disk    rename(venhpfr:venhl1r)
fvenhl2    if   e           k disk    rename(venhpfr:venhl2r)
fva510d    cf   e             workstn sfile(b1sfl:w_srrn)
f                                     infds(dspfbk)
```

- Two database files (`venhl1`, `venhl2`) are declared with a rename to specific record formats.
- `fva510d`: Workstation display file, uses subfile record format `b1sfl`, controlled by `w_srrn`.
- `infds(dspfbk)`: Information Data Structure for feedback/status from I/O operations.

---

## **Data Structures and Variables**

### **Parameters**
- `p_firm`, `p_eenh`, `p_etxt`: Program input parameters, typed from corresponding database fields.

### **Display File Feedback DS**
- `dspfbk`: Data structure holding display file feedback, including cursor row (`d_fcrn`).

### **Key and Work Variables**
- `venhl1_eenh`, `venhl2_etxt`: Used for key positioning into `venhl1`/`venhl2`.
- `w_fcrn`, `w_stel`, `w_spge`, `w_srrn`, etc.: Subfile control variables.
- `w_seqe`: Search sequence ('B' for description search, blank for unit).
- `b_valg_ok`: Flag for successful user selection.
- Constants and other control variables.

### **Subfile Field Explanations**
- Extensive comments explain each subfile and control variable (record numbers, page size, etc.)

---

## **Mainline Logic**

The main program flow operates as a loop responding to user actions with subroutines for different function keys and actions.

### **Main Tags**
- `b2taga`: Tag for displaying command screen.
- `b2tagb`: Tag for processing/displaying the subfile.

### **Functions (Keys/Events)**
- **Exit Program**: If Exit or Cancel pressed (`*INKC` or `*INKL`), goto `avslutt`.
- **Refresh**: On `*INKE` (Enter), refresh subfile (`forny`).
- **Page Down**: On `*IN10`, call `crt_subfile` (create subfile/page).
- **Page Up**: On `*IN11`, call `bck_subfile` (move back one page).
- **Home Key**: On `*IN21`, reposition cursor.
- **Positioning**: If position fields are provided, position using `posisjoner`.
- **Subfile Processing**: Handle subfile events (e.g., user selection).

---

## **Subroutines**

### **forny** (Refresh Subfile)
- Re-chains to the current record if set.
- Determines search sequence and sets the file pointer accordingly.
- Clears and recreates the subfile page.

### **posisjoner** (Position in Subfile)
- Sets search mode based on which field is entered (unit or description).
- Positions file pointer (`SETLL`) accordingly.
- Clears and creates new subfile page.
- Resets positioning fields.

### **subfile** (Handle Subfile)
- Toggles indicator for selection field.
- Loops through the subfile, reading changed records (`READC`).
- If the user selects a record (e.g., marks `b1valg = 1`), outputs selected values and sets `b_valg_ok`.

### **clr_subfile** (Clear Subfile)
- Sets and clears indicators to blank the subfile.
- Sets all subfile control variables to zero.

### **crt_subfile** (Create/Fill Subfile)
- Increases page size and sets record numbers.
- Loops to read and write subfile entries until page full or EOF.
- Writes each record to subfile and updates control variables.
- Handles both 'unit' and 'description' search scenarios.

### **bck_subfile** (Page Up in Subfile)
- If at the last page, positions the file pointer one page back using `READP`.
- Loops to read the previous page's records, handling both search modes.
- After reading records, resets file pointer and refreshes the subfile page.

### **dsp_subfile** (Display Subfile)
- Sets display indicators and presents the control record (`EXFMT b2ctl`).
- Updates work variables for the current/cursor record.

### **\*INZSR** (Initialization / Entry Parameters)
- Loads input parameters.
- Sets up the key lists for positioning.
- Initializes by setting firm ID and positions to the start of the data/table and fills the subfile page.

---

## **Key Points for Developers**

- **Subfile Processing**: Central to the logic. Handles paging, refreshing, and selection.
- **Indicators**: Many features and flow controls rely on classic indicator usage—be familiar with their conventions.
- **Positioning**: Enables search/positioning by either unit or description, controlled by a mode variable.
- **Initialization**: All file pointers, keys, and subfiles are set up in the initialization subroutine.
- **UI/UX**: Uses tagged sections and looping logic to manage user input and subfile navigation.

---

## **Summary Table of Record Formats and Screens**

| Record Format | Purpose                      |
|---------------|-----------------------------|
| `b1sfl`       | Subfile record (list entry) |
| `b2ctl`       | Control record for subfile  |
| `b2cmd`       | Command keys display        |

---

## **Development Tips**

- If adding new function keys or modifying subfile behavior, update indicator mapping and ensure proper subfile handling (clear, create, refresh).
- When working with search/positioning logic, ensure the key lists and work variables (`w_seqe`, etc.) are set appropriately.
- FAQs about which indicator does what can often be answered by the exhaustive comments at the top.

---

**In summary:**  
This program manages a paged, searchable subfile listing units, allowing navigation, positioning, selection, and display using classic RPG cycle and indicator-based programming. It’s well-commented and structured by subroutine, making it possible to enhance or refactor as needed for new requirements.