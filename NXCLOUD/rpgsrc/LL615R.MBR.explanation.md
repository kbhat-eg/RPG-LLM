## Overview

This program (LL615R) collects and validates the input criteria for generating an ABC analysis. It provides a display interface (using the LL615D display file) where a user can enter ranges (e.g., item numbers, groups, subgroups, supplier numbers, etc.) and sort preferences, then checks for validity. Finally, it assembles those parameters into a single data structure (d_prec) and returns the result to its caller.

Key points:
- It uses a screen format (A1BLD) to prompt the user for the “from”/“to” fields (e.g., a1fvar / a1tvar for item ranges, a1fogr / a1togr for overgroups, a1flag / a1tlag for warehouse flags, etc.).  
- Validation checks ensure that each “from” value does not exceed the corresponding “to” value, and that entered codes (supplier, buyer, etc.) exist in the respective files.  
- If any validation fails, the program sets an indicator (e.g., *IN30, *IN31, etc.) to display an error message on the screen, then returns to the same display.  
- When everything is valid, it stores the user’s entries in the parameter data structure (d_prec) and copies that into w_parm for returning to the caller.

## File Definitions

• rlevl1 / ra26l1  
  These are disk files holding supplier (rlevl1) and buyer (ra26l1) data. The program renames their record formats to rlevl1r and ra26l1r to avoid naming conflicts.  

• ll615d (WORKSTN)  
  This is the display file definition. The format A1BLD is used for gathering user input.

## Data Structures

• d_prec (128 bytes)  
  Acts as a communication area. It’s overlaid with multiple fields, each representing a user input range or code. For example, d_fvar/d_tvar for item ranges, d_flag/d_tlag for warehouse flags, and d_sakb for buyer code.

• Local Data Area (l_firm, l_fnav)  
  l_firm indicates the firm (company) number. The program uses w_firm as the working field for database read keys.

## Flow and Navigation

1. The program begins in the *INZSR subroutine, which initializes the default ranges (e.g., item from 0 to 99999999, overgroup from 0 to 99, etc.) and sets w_firm from the local data area.  
2. The main logic starts at label A1TAGA, where the program displays the screen (A1BLD) and waits for user input.  
3. If the user presses F3 (*INKC), it sets w_in03 = '1' and ends the program immediately (GOTO end_pgm).  
4. If the user presses F4 (*INKD), it calls the subroutine SP_INPUT to perform lookups by calling external programs (e.g., VV500R to search items, VG510R for overgroups, etc.). Then it returns to the display for further input.  
5. When the user confirms input with Enter, the program validates:  
   - Checks that each “from” value is <= its corresponding “to” value (e.g., a1fvar <= a1tvar, etc.).  
   - Verifies supplier (chain on rlevl1r) and buyer (chain on ra26l1r) exist.  
   - Ensures sort codes (a1sort) are in a valid range.  
6. If any errors occur, the program sets display indicators to show messages and redisplays. Otherwise, it consolidates the fields into the parameter data structure (d_prec).  
7. It copies d_prec into w_parm (the program’s second parameter), then jumps to end_pgm and sets *INLR = *ON.

## Subroutines

### SP_INPUT  
Handles calls to external inquiry programs. For example, if the user is trying to look up an item (A1FVAR or A1TVAR), it calls VV500R. Similarly:  
- VG510R for overgroup lookups.  
- VG511R for main group lookups.  
- VG512R for sub-group lookups.  
- RA510R for warehouse flags.  
- RL500R for suppliers.  
- RA526R for buyer codes.  

Each call populates the corresponding field(s) if the user selects a value from the lookup.

### *INZSR  
Initializes the program defaults. The “*entry plist” receives two parameters (w_in03, w_parm). After some setup—like constructing keys for the supplier and buyer files, and setting the standard “from”/“to” ranges—it transitions to the main display loop.

## Business/Domain Logic Details

- “ABC analysis” typically means categorizing items/suppliers/etc. based on certain usage or cost criteria. This program’s role is to gather numeric ranges and codes that filter which items or suppliers should appear in the analysis.  
- Overgroups (a1fogr / a1togr), main groups (a1fhgr / a1thgr), and subgroups (a1fugr / a1tugr) represent hierarchical groupings of items. This is common in inventory classification.  
- The user can also filter by supplier (a1lvnr) and buyer (a1sakb) or specify a particular warehouse range (a1flag / a1tlag).  

## Notable Design Decisions

- The “tag” and “goto” structure: Instead of a more modern structured loop, the program uses labeled blocks (A1TAGA, END_PGM) and explicit GOTOs to re-display or end. This is a traditional style seen in older RPG code.  
- The large parameter DS (d_prec) with overlays allows the program to return a “single chunk” of data to the caller, rather than many individual parameters. It is a common approach in legacy RPG where parameter passing can be restricted or must match exact lengths.  
- The call-and-return subroutine (SP_INPUT) delegates lookups to specialized programs. Each called program returns the user’s selection, which is then assigned back to the relevant field. This modular approach keeps the search logic outside of the main parameter screen.  

## Interactions With Other Modules

- VV500R: Searches or retrieves item information (a1fvar, a1tvar).  
- VG510R, VG511R, VG512R: Manage item group hierarchy (overgroup, main group, sub-group).  
- RA510R: Warehouse or “lager” lookups.  
- RL500R: Supplier (leverandør) lookups.  
- RA526R: “Saksbehandler” or buyer code lookups.  

These calls reinforce that this program relies heavily on external modules for searching and validating user entries.  

By the end, LL615R has a fully populated parameter string (w_parm) reflecting the user’s options and concurrency-checked data (supplier, buyer, grouping, etc.), ready for the actual ABC analysis process.