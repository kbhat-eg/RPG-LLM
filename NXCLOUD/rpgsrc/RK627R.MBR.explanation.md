# RPG Program Explanation: RK625R â€“ Print Quality Report for Customer Register

This RPG (Report Program Generator) source code is a classic ILE RPG program for IBM i (AS/400) designed to print a quality report of customer registry data. It's written in traditional RPG/400 (fixed format RPG), mostly using C-specs and D-specs.

---

## General Overview

- **Purpose**: To print a report showing missing or incomplete data for customers, according to user-selected parameters.
- **Main Data Source:** File `rkunl1`, which holds customer master data.
- **Report Output:** File `rk625p`, a printer file used to generate the report.
- **Logic:** For each customer record, fields are validated as per input parameters. Records with incomplete/missing data are flagged and reported.

---

## Header, Description and Comments

- The header explains:
    - Program name: RK625R
    - System: ASOKON
    - Purpose: Print quality report of customer registry
    - Special version and reference information.
    - Indicator usage conventions (e.g., 60-69 = file indicators, 80-89 = work indicators, etc.).

---

## File Declarations

```rpg
frkunl1    if   e           k disk    rename(rkunpfr:rkunl1r)
frk625p    o    e             printer oflind(*in30)
```
- **rkunl1**: Input file (customer master), keyed access, renamed record format
- **rk625p**: Output printer file, uses indicator 30 for page overflow

---

## Data Definitions

```rpg
d l_katf                300    303  0
d l_katt                         4  0
d l_kadr                         1
...
d w_user          s                   like(l_user)
d w_firm          s                   like(rkfirm)
d w_feil          s              1
```

- **l_***: Parameters from the user ("l" for "local" or "input"). These control what is checked.
    - `l_katf`, `l_katt`: Customer category range (from/to)
    - `l_kadr`, ..., `l_kfax`: Flags indicating which fields must be validated (likely 'J' = Yes)
- **w_***: Working storage fields.
    - `w_user`, `w_firm`: Work variables for user and firm.
    - `w_feil`: Indicates if a fault was found in the record ("1" = error).

---

## Main Program Loop

### 1. Read First Customer Record

```rpg
c     rkunl1_key    reade     rkunl1                                 60
```
- Reads the first customer record using a key (from the setll/klist), sets file indicator 60 if EOF.

### 2. Main Processing Loop

```rpg
c     dow       *in60 = *off
    ...
c     rkunl1_key    reade     rkunl1                                 60
c     enddo
```
- Loops through all customer records until EOF (`*in60 = *on`).

---

### 3. Within the Loop: Per-Record Processing

#### a. EOF Check

```rpg
c     if        %eof
c               leave
c     endif
```
- Leaves loop if at end of file.

#### b. Customer Category Range Check

```rpg
c     if        rkkatg < l_katf or rkkatg > l_katt
c               leave
c     endif
```
- Skips customers not within selected category range.

#### c. Reset Fault Indicators

```rpg
c     eval      w_feil = ' '
c     eval      a1kadr = ' '
c     ... (similar for all a1kxx fields)
```
- Clears per-field error indicators and the overall fault flag.

#### d. Field Checks (Validation Section)

Each field with a corresponding 'l_kxxx' flag set to 'J' (yes) is checked for being blank/zero. If the value is missing:
- The specific `a1kxxx` indicator is set to `'X'`,
- The overall error flag `w_feil` is set to `'1'`.

For example:
```rpg
c     if        l_kadr = 'J' and rkgate = ' '
c               eval      a1kadr = 'X'
c               eval      w_feil = '1'
c     endif
```
- If user wants address checked (`l_kadr = 'J'`) and address is blank, mark as error.

(Similar logic repeats for standard (l_kstd), category (l_kkat), organization number (l_korg), person number (l_kpnr), contact person (l_kkpe), email (l_kema), phone (l_ktlf), fax (l_kfax).)

#### e. Output the Record if There Are Errors

```rpg
c     if        w_feil = '1'
c           write     skriv
c     endif
```
- If any error was found for the record, output the line to the report.

#### f. Handle Page Overflow

```rpg
c     if        *in30 = *on
c           write     head1
c           eval      *in30 = *off
c     endif
```
- If the printout needs a new page, write heading and reset overflow indicator.

---

### 4. Read Next Record

```rpg
c     rkunl1_key    reade     rkunl1                                 60
```
- Read next customer record and repeat the process.

---

### 5. Program End Logic

```rpg
c     eval      *inlr = *on
```
- Set last record indicator (`*inlr`) to `*on`, ending the program and closing files.

---

## Subroutine: *INZSR (Initialization)

```rpg
c     *inzsr        begsr
    ...
c     endsr
```

- Moves input parameters into work fields.
- Initializes file by positioning to first key.
- Writes heading on first page.

---

## Parameter List and Indicator Documentation

- The program receives a variety of selection flags (`l_kadr`, `l_kstd`, ...), range selectors, and user/firm info.
- Indicators (used here as *inNN variables) are carefully documented in the comments for maintainability.

---

## Summary of Process Flow

1. **Initialize** user/firm context and output heading.
2. **Loop through customers,** selecting only those in the specified category range.
3. **For each customer,** check required fields as per user-supplied flags.
4. **If missing data found,** flag the record and write the entry to the report.
5. **Handle print output,** including page overflow and headings.
6. **Finish** by setting last record indicator and ending program.

---

## Typical Customization Points

- Adjust input parameters for the specific checks required.
- Extend or change field validation logic as needed.
- Update output formatting in the printer file (`rk625p`) and output statements.

---

## Best Practices Noted

- Good use of indicator documentation.
- Modular use of input flags controlling validation.
- Separation of initialization and reporting logic.
- Clear comments (in Norwegian!) to explain indicator conventions and program structure.

---

If you are a new developer on this program, you should start by understanding how input parameters control which validity checks are performed. The core logic is a loop over customer records, with each field's presence or absence flagged as required by the user. Output only includes records needing correction. The printout layout is controlled by the printer file, and headings are managed with overflow indicators.