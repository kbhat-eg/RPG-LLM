# RPG Program Onboarding Explanation

---

## General Overview

This is an IBM ILE RPG (RPG IV / RPGLE) program, structured in fixed-format RPG. The program's primary purpose is to provide maintenance (view/edit/update) for "Priskode" (price code) records, likely from a database, using a subfile-driven user interface. It's typical for administrative or master data applications.

---

## Header and Documentation

- **`h option(*nodebugio) datedit(*dmy)`**  
  - Compiler options: No debug I/O, date editing in *DMY (Day/Month/Year) format.
- Program name: `VV160R`
- Description: Maintenance of price codes (Priskode, vedlikehold)
- Comments include details like change history, developer signatures, versioning.

---

## Files and Device Declarations

```rpg
fvpkol1    if   e           k disk    rename(vpkopfr:vpkol1r)
fvpkolr    if   e           k disk    rename(vpkopfr:vpkolrr)
fvpkolu    uf a e           k disk    rename(vpkopfr:vpkolur)
```
- Three logical views over what seems to be the same physical file (`vpkopfr`), for reading, updating, and chaining, each renamed for clarity.

```rpg
fva160d    cf   e             workstn sfile(b1sfl:w_srrn)
f                                     infds(dspfbk)
```
- A display file (`va160d`) in workstation mode, using subfile `b1sfl` and a feedback data structure (`dspfbk`).

---

## Data Structure and Variable Declarations

### Local Data Area

- Defined with substring notation for retrieving user/firma/info from the LDA
  - `l_user` - user ID
  - `l_firm` - company code
  - `l_fnav` - name

### Display Feedback

- Used to capture the current record number or cursor position from the display device.

### Key Variables

- Used for chaining/positioning in the files: 
  - `vpkol1_pkod`, `vpkolr_pkod`, `vpkolu_pkod`

### Working Variables

- Subfile/page/record counters (`w_fcrn`, `w_stel`, etc.)
- Control variables: `w_seqe`, `b_feil`
- Constants: `c_sfil` (subfile size/page size, initialized as 14)

### Subfile/Screen Field Explanations

- Extensive comments explain subfile-related fields, page numbers, and subfile behavior.

---

## Main Program Structure

The program is organized as a main tag/label loop with subroutines (`exsr`) for modular logic.

### Main Tag and Event Loop

Pseudocode interpretation:

1. **Display initial command screen (`b2cmd`).**
2. **Enter main processing tag (`b2tagb`):**
    - Call subroutine to display subfile (`dsp_subfile`).
    - Handle function key actions (ROLL, ROLLDOWN, ENTER, HOME, etc.) through SELECT/WHEN logic.
    - For each, call corresponding subroutines or reposition/go back as required.
    - If positioning field filled, handle position routine (`posisjoner`).
    - Subfile processing in `exsr subfile`.
    - Loop back to `b2taga`.

3. **Exit:**  
   When function keys KC/KL (commonly F3/Exit/Cancel) pressed, set LR indicator and return.

---

## Subroutines (`exsr`/`begsr`/`endsr`)

### forny

- Refreshes the subfile display from the file.
- Positions to record if paging was in place.
- Clears and re-creates the subfile.

### posisjoner

- If a price code is entered, positions to that code in the file.
- Clears and refills the subfile page to show the positioned code.

### subfile

- Toggles a display indicator.
- Loops over the subfile records:
    - If a change or display request (via `b1valg`), calls `xc2bld` to bring up the edit/view screen for that record, then updates the subfile.
- Handles *eof and skips out of the loop as required.

### xc2bld

- Handles the edit/view screen for a price code.
- Loads record, populates fields, and if viewing, protects fields.
- Waits for user input, validates, and updates the record if necessary.

### clr_subfile

- Turns on SFLCLR to clear the subfile on the display.
- Resets record and page counters.

### crt_subfile

- Fills the subfile with records from the file up to the page size.
- Sets end indicators when reaching EOF or end of page.

### bck_subfile

- Handles "roll back" in the subfile (paging backward).
- Reads back one page in the file, then re-displays the subfile.

### dsp_subfile

- Displays the subfile using either a format or a prompt.
- Sets up required indicators and stores page position.

### *inzsr

- Initialization subroutine, runs once at program start.
- Sets up keys, retrieves company from LDA, initializes display and subfile.

---

## Screen Layouts

The comments detail several display formats used:

- **B1SFL**   - Subfile record format
- **B2CTL**   - Subfile control/display record
- **B2CMD**   - Command key screen
- **C2BLD**   - Full-screen display for create/edit/view

---

## Indicator Usage

The code follows a strict convention for the classic 99 indicators.

- LR = last record/program end
- 10/11 = roll/rolldown
- 12-15 = subfile control (display, clear, end, etc.)
- 21/22 = home/cursor
- 30 = field protection when viewing
- 31-79 = error/warning indicators
- 80-99 = work indicators

---

## Workflow Summary

1. **Startup:** Initialize keys, retrieve company, position at start, fill subfile.
2. **Main Loop:** Display subfile screen. Wait for user function key input.
3. **Paging:** PgUp/PgDn/ROLL/ROLLDOWN handled by reloading records into subfile.
4. **Editing:** Selecting a record (e.g., change or display) brings up the full-screen editor for that record.
5. **Update:** Data is validated. If valid, record(s) updated in the file.
6. **Exit:** Program ends cleanly, closing files and setting LR.

---

## Key Takeaways

- **Subfile-driven UI:** Allows paged display/edit of records.
- **File Handling:** Logical files and key lists used for effective record navigation.
- **Indicator Control:** RPG classic indicator-based flow, essential for understanding navigation and screen control.
- **Modular Logic:** Heavily reliant on subroutines for maintainability.

---

### New Developer Hints

- Understand subfile mechanics (clear, load, update, page back/forth).
- Get familiar with indicator values: they are essential in classic RPG.
- The core business field is the "priskode" (price code), and almost all actions are around viewing/editing those records for a specific company (`firma`).
- Search for logic in subroutines for easier troubleshooting and enhancementsâ€”each main action is performed in its own `begsr/endsr` block.

---

If you need to trace the logic, start from the main tagged sections (`b2tag*`) and see which `exsr` branches are hit for each user action, then follow subroutine logic for business rules and file access.