# Explanation of the ILE RPG Program

This RPG program is for the **receipting of returned items** ("Kvittering av innkomne returer" in Norwegian). Below is a walkthrough and explanation of the code, its data structures, and major logic steps to help new developers understand its flow and purpose.

---

## File Specifications

```rpg
fgretpf    ip   e             disk
fgavtl1    if   e           k disk    rename(gavtpfr:gavtl1r)
**liste     o    f  132        printer oflind(*inof)
fgl151p    o    e             printer
```

- **fgretpf**: Input Primary file, a disk file, probably contains the incoming return data.
- **fgavtl1**: Input Full-Procedural keyed file, renamed record format, likely a register of agreements/accounts.
- **liste**: Output printer file, 132 characters wide, with overflow indicator.
- **gl151p**: Another output printer file.

---

## Data Structures and Variables

### Simple Arrays and Variables

```rpg
d kto             s             11    dim(999)
d txt             s             20    dim(4) ctdata perrcd(1)
```
- `kto`: Array of account numbers.
- `txt`: Array of up to 4 textual messages, loaded from compile-time data.

### Working Variables

```rpg
d w_jkey          s             41
d w_jsta          s              2  0
d w_jmld          s            200
d w_stat          s              1  0
```
- Variables for error handling/status messaging.

### Data Structure Overlays

```rpg
d                 ds
d gdqret                       160
d  ocrret                        8    overlay(gdqret)
d  ocrkto                       11    overlay(gdqret:25)
d  betf21                        8    overlay(gdqret:41)
d  betfkt                       11    overlay(gdqret:60)
```
- Overlaying fields on a 160-byte area, extracting key fields from a record buffer.

### User Data Areas

```rpg
d                uds
d l_user                911    920
d l_firm                944    946  0
d l_navn                951    980
```
- Positions for user, firm, and name in a user data (likely LDA or *UDS).

---

## Main Logic

### Entry/Initialization

- The program initializes with the `*inzsr` subroutine.
- Receives initial parameters (`w_jkey`, `w_stat`) via parameter list.
- Initializes `ix` (counter for `kto` array).
- Sets up key list for agreement register (`avtkey klist` with `gcbgir` as key).
- Prints report header (`write a1hdr`).

---

### Read and Process Returns

The main process is tagged by `lesrk` and iterates over return records:

#### Update Konto Array

```rpg
if betf21 = 'BETFOR21' or betf21 = 'BETFOR01'
    lookup betfkt kto 50
    if *in50 = *off
        ix = ix + 1
        move betfkt kto(ix)
    endif
endif
```
- If a return record type matches certain indicators, it checks if its account (`betfkt`) is already in the `kto` array.
- If not, adds it.

#### Special Case for ocrret

```rpg
if ocrret = 'NY090020'
    lookup ocrkto kto 50
    if *in50 = *off
        ix = ix + 1
        move ocrkto kto(ix)
    endif
endif
```
- For a specific return code, checks if `ocrkto` is known; adds if not.

---

### Finalization and Output

- At end, calls `subskr` subroutine for printing ("utskrift av kvittering av returmottak").

---

## Subroutines

### subskr – Print Receipts

```rpg
subskr begsr
    except h101    // Print report heading (template)
    it = 1
    dou it > ix
        iu = 4
        move kto(it) gcbgir
        avtkey chain gavtl1 41
        if *in41 = *on
            iu = 3
            gcbgir = *zeros
            d1txt = txt(3)
            move kto(it) d1kto
        else
            d1filg = gcfilg
            d1firm = gcfirm
            move kto(it) d1kto
        endif
        write d1det 30
        if *in30 = *on
            write a1hdr
        endif
        [Clear working variables]
        it = it + 1
    enddo
endsr
```

- Loops through each account in `kto`.
- Tries to find each account in the agreement file (`gavtl1`).
- If account is **not found**: sets certain values, fills in "Konto uten avtale" message.
- Outputs a detail line for each account, and reprints the header on page overflow.
- Clears (zeros/blanks) used variables after each account.

---

### *pssr – Error Routine

If a fatal error occurs:

- Sets status, error code, and message.
- Calls error message handler program `AB705R`.
- Ends program (`*inlr` and `goto slutt`).

---

## Compile-Time Text

```rpg
**   TEKSTER
Motaksretur (1. gang)
Motaksretur (2. gang)
Konto uten avtale
.
```
- These lines provide the values for the `txt` array used when printing messages.

---

## Summary Table

| Item         | Description                                  |
|--------------|----------------------------------------------|
| fgretpf      | Input file: Returns                          |
| fgavtl1      | Input Keyed file: Account agreements         |
| kto[]        | Array holding unique account numbers         |
| txt[]        | Array with messages for printing             |
| subskr       | Subroutine for printing receipts             |
| *pssr        | Error reporting/handling subroutine          |

---

## High-Level Process Flow

1. **Initialization**
   - Set up work areas, print initial header.
2. **Read Returns**
   - For each return: extract account number(s), ensure they're tracked in `kto[]`.
3. **Final Receipt Print**
   - For each account:
     - Attempt to find agreement.
     - Print detail (with message if not found).
     - Handle page overflows with headers.
4. **Error Handling**
   - If fatal error, call error handler, end program.

---

## Key Points for New Developers

- Program reads returns and builds a list of unique account numbers.
- Checks if each account has an agreement; prints a confirmation receipt/report.
- Uses overlays and direct field movements for efficiency and legacy compatibility.
- Error handling is centralized in `*pssr` with a call to an external program for logging.
- Print logic is separated into a subroutine and uses `EXCEPT` and `WRITE` for output.
- Norwegian variable names and comments; understanding the business context will help.

---

**End of Explanation**