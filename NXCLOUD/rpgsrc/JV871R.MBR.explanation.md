# RPG Program JV871R - Code Explanation

This explanation will help bring new developers up to speed on what this RPG (ILE RPG, IBM i) program (`JV871R`) is doing, including data definitions, logic, and subroutine flow. The code is standard fixed-format RPG IV (RPGLE), with usage of database files, subroutines, and parameter passing.

---

## 1. **Program Overview**

- **Purpose:**  
  The program is used when scanning items. If the item is not found in the EVR (probably the main item registry), it checks VA (a secondary source). If still not found, it saves the scan as "not registered" (with a status code 2).
- **Domain:**  
  Likely warehouse/inventory, focused on registering scanned items via barcode/EAN.

---

## 2. **Header and Documentation**

- **Date Edit:** `*dmy` indicates the date format is Day-Month-Year.
- **Option:** `*nodebugio` disables debug input/output.

- **Indicator Usage:**  
  Outlines which indicator lights are used for program control, field protection, file operations, etc.
  
- **Revision History:**  
  Shows the program's version history and brief change notes.

---

## 3. **File Declarations**

- Multiple physical files are declared with renaming of record formats for clarity:
    ```rpg
    fjvsclu    uf a e           k disk    rename(jvscpfr:jvsclur)
    fjvscl2    if   e           k disk    rename(jvscpfr:jvscl1r)
    fjvarl1    if   e           k disk    rename(jvarpfr:jvarl1r)
    fjvarl4    if   e           k disk    rename(jvarpfr:jvarl4r)
    fjvpkl3    if   e           k disk    rename(jvpkpfr:jvpkl3r)
    fjv871d    cf   e             workstn
    ```
- These represent, respectively:  
  - The main scanning register  
  - An alternate register/file  
  - Item master tables  
  - EAN/GTIN package file  
  - Workstation device

---

## 4. **Data Definitions**

### A. **Parameters**
- `p_scan` (26A): The scanned value (barcode or similar).
- `p_text` (30A): Descriptive text (used in some versions).

### B. **Local Data Area (LDA):**
- Example:  
  - `l_wsid` (10A): Workstation ID  
  - `l_user` (10A): User  
  - `l_filg` (3A): File group or similar

### C. **EAN128 Data Structure**
- `d_e128` (26A): Holds an EAN128 scan.
- Subfields (overlaying positions):
  - `d_fast` (2P0): Leading data
  - `d_eann` (14P0): EAN number (offset 3)
  - `d_kode` (4P0): Code (offset 17)
  - `d_anta` (6P2): Amount (offset 21)

### D. **Other Variables**
- Variables for holding keys, temporary values, and constants for scan processing.

---

## 5. **Scan Identification Logic**

The heart of the program is in subroutine `scanning` (beginning with `c scanning begsr`).

### **Classification Logic:**
Depending on contents and length, the scan is categorized for lookup in various files:

1. **Alphanumeric (`alfa`):**  
   - If `w_scan` contains any non-digit, treat as supplier item number (first 15 positions).
   - Lookup in `jvarl4` (probably supplier item master).

2. **Numeric, Length = 26:**  
   - EAN-128 code.
   - Parse with overlays.  
   - Lookup in `jvpkl3` (GTIN/EAN package file), then `jvarl1` (item master).

3. **Numeric, Length <= 8:**  
   - Standard item number, pad with leading zeroes.
   - Lookup in `jvarl1`.

4. **Numeric, Length <= 14:**  
   - EAN-13/14 number, pad with leading zeroes.
   - Lookup in `jvpkl3`, then `jvarl1`.

5. **Numeric, Length < 26 ("samlepost"):**
   - Treat as supplier number (again), lookup in `jvarl4`.

If no match found in each case, call `ikke_VA` (not found in VA).

---

## 6. **Subroutines (SR)**

### **A. `scanning`**
- Steps through the classification logic above.
- If item found, updates the scan register by calling `oppd_scan`.
- Uses `goto` to jump to cleanup steps as soon as a match is found.

### **B. `oppd_scan`**
- Handles updating/writing the scan register (`jvsclur`):
  - Calls `finn_teller` to get the counter value.
  - Prepares a new record with the scan values.
  - Writes to file if unique key.

### **C. `ikke_VA`**
- Invoked when item is not found in VA.
- Prompts/display (`exfmt g1bld`), then writes a scan record with status = 2 ("not found").
- Calls `finn_teller` for counter before write.

### **D. `finn_teller`**
- Determines the highest current counter value (`jsctel`) from the file, for use as the next record's sequence.

### **E. `*INZSR` (Initialization)**
- Loads entry parameter(s) (`p_scan`).
- Builds the various key lists for lookups.

---

## 7. **Miscellaneous Details**

- **Constants:**  
  - `c_digi`: Digits and blank for validation.
  - `c_null`: Used for left-padding zeros for numeric keys.

- **Subfile/Workstation Screens:**  
  - Comments describe which display files/subfiles are used for different UI operations.

---

## 8. **Typical Call Flow**

1. **Program invoked** (receives `p_scan` as entry parameter).
2. **Subroutine `scanning` runs**:
    - Determines scan type,
    - Performs lookups, updates register if found.
    - If not found, records as "not present" with status 2.
3. **Program ends, with *INLR = *ON** (end-of-program).

---

## 9. **Error/Message Handling**

- Uses status codes and message fields (`jsctxt`) to describe processing results.
- Indicators are reserved for further expansions: error display, UI feedback, etc.

---

## 10. **Conclusion and Maintenance Tips**

- The program is written in a clear, modular styleâ€”lookup and writing logic is handled via subroutines.
- Pay special attention to:
    - Key composition for file access/updates.
    - How EAN128 barcodes are parsed using data structure overlays.
    - The sequence for handling different barcode types.
- Modify lookup logic with care, and always coordinate changes with display files due to the use of subfiles/screens described in comments.

---

## Summary Table

| Subroutine      | Purpose                                         |
|-----------------|-------------------------------------------------|
| scanning        | Classifies/looks up scanned value               |
| oppd_scan       | Updates scan register with found item info       |
| ikke_VA         | Handles scan values not found in system         |
| finn_teller     | Retrieves latest counter value for new entries  |
| *INZSR          | Initializes keys, variables on program start    |

---

This program is a typical example of a scan-and-register process in warehouse or retail systems, efficiently handling barcodes and item numbers through prioritized lookup and registration logic.