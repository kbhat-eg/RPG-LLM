# Explanation of the Source Code

This RPG/400 (ILE RPG) program produces a "Balance Report" (`Utskrift av saldobalanse`). It processes balance and budget records, organizes results by various keys (account, department, "cost bearer"), and prints multi-level subtotals and comparisons.

## Overview

- **Purpose:** Print balance/budget summaries (`kostnadsbærerrapport` - cost bearer report), comparing actuals with budget, previous years, or group averages, and displaying them grouped and subtotaled by various classifications (account, group, class, department, cost bearer).
- **Structure:** Classic RPG with *fixed-format* spec (`C`, `I`, `D` lines), multiple subroutines, multiple input files, and printer output.

---

## Program Structure

### Header and Documentation

- The `/TITLE` and initial comments document the purpose, version history, and authorship.
- **Program name:** `RH627R`
- **System:** `ASOKON`

---

### File Declarations

- **Input files:**
  - `rhsal1`, `rhsal2`, `rhsal3`: Balance registers, input via disk files with different sort orders (“konto”, “avdeling”, “kostnadsbærer”).
  - `rhovlr`: Chart of accounts (for fetching descriptive texts).
  - `ra28lr`: Cost bearer group register.

- **Output file:**
  - `rh627p`: Printer file with overflow indicator.

---

### Data Declarations

- **Working arrays/fields:**
  - `sal(13)`: Array for period balances.
  - `txt(2)`: Array for label texts.
  - `uav(8)`: Work array (purpose not specified here).
- **Break (summary/grouping) structures:**
  - Data structures for grouping keys: `nybrd`/`gmbrd` (new/current key, old/group key) with overlays for department, account, group, class, cost bearer.
- **Totals and work fields:** Many fields named `l1bevp`, `l1salh`, etc., used for accumulating values at different summary levels (L1-L5).
- **Text fields:** For descriptions from account/group/class/etc. registers.

---

### Input Record Format Descriptions

- The `I` (input) specs load period values from each input file into the `sal(1-13)` array, regardless of sort order.

---

## Main Logic

### 1. File Selection and Initial Read

- Program determines which input file to process based on the `rhpsrt` parameter:
  - `'K'`: Account-order
  - `'A'`: Department-order
  - `'B'`: Cost bearer-order
- Executes a keyed setll/reade to position and read the first record.

### 2. Main Loop

- The main processing loop iterates over all relevant records, performing filtering and summarization.

#### a. Key Preparation

- Loads the current record's department, account, cost bearer, etc., into work fields (`nyavd`, `nykto`, `nysps`, etc.).

#### b. Filtering

Checks if the record is within selection parameters:
- **Year filtering** (`riraar`, `rhprår`, etc.): Only process years relevant to the requested report.
- **Account and department ranges** (`nykto`, `nyavd` within `rhpktf`, `rhpavf`, etc.).
- **Cost bearer group/cost bearer filtering** (for specific versions only).

#### c. First-time Processing

- If this is the first relevant record, initialize the break fields and run `sr_forst` to get description texts.

#### d. Break (Subtotal) Handling

- If grouping keys have changed compared to the last record (`nybrd ≠ gmbrd`), the program:
  - Calls subroutines for break-handling at **all relevant detail levels**, writing subtotal lines and zeroing accumulators.

#### e. Accumulating Values

- Always runs `rsum` subroutine to accumulate values (actual, budget, previous year, etc.) into summary fields.

#### f. Update Break Fields

- Copies new grouping keys to old before reading the next record.

#### g. Read Next Record

- Reads next record from the chosen file and repeats until EOF.

---

### 3. Final Break Processing

- After the last record, all break-handling subroutines are called to flush remaining totals.

---

### 4. Subroutines (Key Functions)

#### a. rsum

- Accumulates balances for each record by type and period:
  - **Type 1:** Actuals
  - **Type 3/4:** Budgets
- Sums “this period” and “year-to-date” for each level.

#### b. hsum

- Helper to sum movements within a period or range; called by `rsum`.

#### c. brhel / brkto / brgrp / brkla / bravd / brsps

- Each handles a subtotal break at a different report level (specification, account, group, class, department, cost bearer).
- Each:
  - Calculates comparison amounts (actuals minus comparison base).
  - Optionally calculates usage percentages (`brukt` subroutine).
  - Fetches descriptive text for the group from appropriate code register (external program calls).
  - Writes subtotal lines and headings.
  - Resets work fields for the level.

#### d. sr_forst

- On the first relevant record, fetches and stores description texts for department/cost bearer and writes report headings.

#### e. brukt

- If comparison basis is nonzero, calculates percent used/achieved, with bounds checking.
- If denominator is zero but numerator is not, sets flags for potential divide-by-zero error.

#### f. skriv

- Writes report page headings, increments page count.

#### g. *inzsr

- Program initialization:
  - Zeros totals, prepares year comparisons, sets flags based on report parameters.
  - Fetches initial description texts and writes the first page heading.
  - Defines all key lists for setll/read/chain operations.

---

## Key RPG Idioms & Features Used

- **Overlay fields:** “Overlays” in data structures create subfields for easier key management in grouping.
- **KLIST/KFLD usage:** RPG key lists for file access; sets up keys for setll, reade, chain.
- **Program calls for text descriptions:** External programs called to get the description for account, group, class, department, cost bearer.
- **Classic fixed-form RPG:** Full use of C-Spec, I-Spec, D-Spec, E-Spec, with subroutines (BEGSR/ENDSR), tags, and indicators.

---

## Processing Flow Example

1. **Read record**
2. **Populate grouping fields**
3. **Apply filters** (by year, account, department, cost bearer, etc.)
4. **If first, initialize group and print headings**
5. **If group key has changed:**
   - Call subtotal subroutines for all relevant break levels, print subtotal lines
   - Zero break accumulators
6. **Accumulate values**
7. **Copy ‘current’ grouping keys to ‘previous’**
8. **Loop / Read next**

---

## Customization and Extensibility

- The report can be sorted/grouped by account, department, or cost bearer via parameter.
- For each, it prints subtotals at every grouping (class, group, account, specification, etc.)
- Program calls (like `RS707R`, `RS719R`, `RS720R`, `RS728R`) enable flexible externalization of code-to-text translation.
- Filters are highly parameterized (years, accounts, departments, cost bearers, group).

---

## Notable Code Characteristics

- **Multi-level subtotaling:** Supports complex, nested subtotaling with clean break-detection and accumulator management.
- **External lookups:** Dynamic fetching of description texts enables updates without code changes.
- **Robust error/edge handling:** Protects against divide-by-zero and overflows in percent calculations.
- **Indicator usage:** RPG indicators (`*in`) for printer overflow, page breaks, and error flags.

---

## Typical Developer Touchpoints

- **Adding/removing grouping levels:** Would involve modifying data structures, break handling, and subtotal logic.
- **New sort/filter options:** Adjust grouping logic, add new parameters, update field overlays as needed.
- **Changing/adding text descriptions:** Update external code tables or the programs called for text lookup.

---

## Final Notes

- **Legacy code:** Heavy “classic” RPG fixed-format, but well-structured for its era/purpose.
- **Documentation:** Well-commented, with clear break markers and explanatory comments per section.
- **Onboarding:** New developers should focus on understanding the break logic, accumulator management across subroutines, and the file access methods used.

**If you need more clarification on a specific report break, accumulator, or routine, please ask!**