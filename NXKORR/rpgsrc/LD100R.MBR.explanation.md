# RPG Program LD100R - Onboarding and Explanation

This RPG program, identified as `LD100R`, is a central component in handling purchase order lines (bestilling-linje) and the registration, maintenance, and synchronization of purchase and sales orders. It is used in a business application for order processing (bestilling/innkj√∏p) and tightly interacts with inventory, price, supplier, and order records.

Below you'll find a breakdown of the major components, operations, and flow of the program, aiming to help new developers understand its structure and logic.

---

## 1. **Header and Revision History**

- The header includes a detailed changelog, providing historical context, bug fixes, enhancements, and references to related business changes.
- The `h` spec controls compile-time options, such as no debug IO and date editing format.

---

## 2. **File Declarations**

- **Physical Files (DB Tables):**  
  Multiple external files are declared (e.g., `rlevl1`, `vvarl1`, `vltyl1`, `lohel1`, `lodtl1`, etc.), each corresponding to a logical or physical file in the database.
- **Workstation File:**  
  `ld100d` is the DSPF (display file) used for screen interactions, including a subfile (`b1sfl:w_srrn`) for displaying a list of lines.
- **Internal Data Structures:**  
  Data structures for feedback (`dspfbk`), the Local Data Area (LDA), and for EAN128 codes and inventory updates are defined.

---

## 3. **Global Variable and Data Structure Declarations**

- **Parameters:**  
  Variables are used for passing status, firm, order number, suffix, etc., both as program parameters and as working storage.
- **Working Variables:**  
  A large set of scalar variables (e.g., flags, counters, total sums) are used across the program for state tracking and calculations.
- **Arrays:**  
  Example: `a_meld` is a message array loaded from compile-time data for display messages.

---

## 4. **Entry and Initialization**

- **Entry Parameters:**  
  The program receives input parameters at start for status, firm no, order number, suffix, etc.
- **Initialization Subroutine (`*inzsr`):**  
  - Loads LDA.
  - Initializes key lists for most files (for `CHAIN`, `SETLL`, etc.),
  - Retrieves setup/status data from user/master records.
  - Calls external program `CO402R` to determine feature flags or system settings (e.g., for custom logic).

---

## 5. **Main Processing Flow**

### a. **Main Screen and Subfile Population**

- **`d1tag`:**  
  Initial label for main logic.
  - Positions database cursor (based on current record or line number).
  - Calls routines to clear (`clr_subfile`) and populate (`crt_subfile`) the subfile with purchase order lines for display.

### b. **Order Header and Line Information**

- **`hent_best`:**  
  Retrieves order header details (supplier, order type, address, etc.), calculates totals and fetches relevant descriptions/codes, including currency handling.

### c. **Subfile Screen Loop**

- **Display Loop:**  
  Handles user input from the main subfile screen. Possible actions via function keys:
    - F1: Toggle display totals.
    - F2: Insert a text line.
    - F3: Update/print/transfer.
    - F4: Item file inquiry.
    - F5: Commit changes and exit.
    - F6: Retrieve campaign items.
    - F9: Item/stock inquiry.
    - F10/F11: Maintain master/text data.
    - F14: View supplier info.
    - F20: Toggle between item# and NOBB#.
    - F21: Item/price inquiry.
    - F23: Toggle cost price visibility.

### d. **Line registration, validation, and update**

- **Registration:**  
  Subroutine `registrer` validates line type and item, ensures data integrity (e.g., no text item and stock item together), and calls `reg_vare` or `tekstlinje` for actual line creation.
- **Validation:**  
  The `ident_vare` subroutine identifies item numbers by checking if they are alphanumeric, EAN128, "pure" item numbers, or supplier item numbers, and handles length-specific logic (e.g., EAN is 14/26 chars).
- **Inventory Update:**  
  `oppdat_lager` transfers values to a structure and calls an external inventory update program.

### e. **Subfile Maintenance**

- **Subfile routines:**  
  Handles screen navigation, page-up/page-down, and calling appropriate subroutines for editing, deleting, viewing, or adding lines.

---

## 6. **Order and Synchronization Logic**

- **Order Sync (`synk_subr`):**
  - Handles logic to keep purchase order lines and sales orders synchronized.
  - Decides if manual or automatic changes should be made, depending on access and flags.
  - Calls external programs for updating orders, logging changes, and sending notifications.
- **Line Logging:**  
  Extensive subroutines (`logg_bline`, `logg_txt`, `oppd_logg`) for recording changes made to lines for auditing and traceability.

---

## 7. **Supporting and Utility Routines**

- **Campaign management (F6):**  
  Loads all campaign items into the order.
- **Calculations:**  
  - `cal_line` determines weight and volume for individual lines, pulling data from item master and package tables.
  - Subroutines for re-calculating and updating totals after changes.
- **Data cleansing:**  
  `newlo_vask` cleans/normalizes displayed text for UI compatibility (esp. with Newlook GUI).
- **Split/shipment validation (`sjk_dellev`):**  
  Ensures all lines in an order point to the same suffix for consistent partial deliveries.

---

## 8. **External Program Calls**

- Many routines delegate business logic or updates to external RPG programs (`LD105R`, `LD102R`, `VL710R`, `FD108R`, etc.).
- This allows for modularity and separation of concerns (e.g., price calculations, item checks, audit log writing, ERP synchronization).

---

## 9. **Business Logic Highlights**

- **Data integrity:**  
  Multiple validation layers for reference integrity between order lines, items, and supplier info.
- **User Access & Security:**  
  Special checks for user permissions before performing order/order-line updates.
- **Notifications:**  
  Email notification routines to flag users/sellers if relevant changes or errors occur.
- **Partial Delivery Handling:**  
  Confirm all lines are compatible before allowing split shipments or changes.
- **Custom/Cloud Feature Switches:**  
  Uses external configuration (via `CO402R`) to switch on/off certain behaviors, especially for cloud-based deployments.

---

## 10. **Screen Flow and Subfile Logic**

- The subfile structure allows for multi-line display, navigation, and actions directly from the main order line screen.
- Key indicators (e.g., `*in10`, `*in11`) are tightly mapped to function key behavior for the IBM i display station.

---

## 11. **Key Data Structures**

- **Order header/line:**  
  Structures mirror DB file layouts, often with overlays for fast field access.
- **Feedback & UI state:**  
  Structures for tracking cursor, error position, and UI indicators.
- **Arrays:**  
  Used for message text and handling variable-length descriptions for dynamic display.

---

## 12. **Best Practices Used**

- **Modular Design:**  
  Heavy use of subroutines for functional decomposition and clarity.
- **Separation of Display and Logic:**  
  Screen handling is mainly orchestrated via subfile routines, keeping business logic isolated.
- **Extensive Error Handling:**  
  Each step in the process is validated, with UI feedback for users (input errors, missing keys, etc.).
- **Revision Tracking:**  
  Code modifications are meticulously documented with timestamps and change reasons.
- **SQL Integration:**  
  Embedded SQL is used for some queries (e.g., fetching logistic numbers, currency rates).
- **Scalability:**  
  Code is versioned and "switchable" via external configuration, making it adaptable for different sites or business requirements.

---

## 13. **Summary**

**In short:**  
This is a feature-rich, robust RPG program for interactive purchase order line management on IBM i. It provides a full UI for line maintenance, sophisticated validation, business rule enforcement, and tight coupling/synchronization with sales order modules, as well as comprehensive audit and notification features.

**If you are onboarding:**  
- Start by understanding the data model (headers, lines, item master).
- Explore the main display and subfile interaction logic.
- Review how line registration and validation is performed.
- Examine the order synchronization and notification logic for end-to-end data flows.
- Read the revision history for context about recent changes or open issues.

**Tip:**  
Mapping the mainline logic (from entry to screen loop, to updates, to exit) on a whiteboard can be helpful, as well as stepping through a sample transaction in debug.

---

**You can ask for explanations for subroutines, file definitions, or particular business rules for even more detail!**